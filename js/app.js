! function(t) {
    function e(n) {
        if (i[n]) return i[n].exports;
        var r = i[n] = {
            exports: {},
            id: n,
            loaded: !1
        };
        return t[n].call(r.exports, r, r.exports, e), r.loaded = !0, r.exports
    }
    var i = {};
    return e.m = t, e.c = i, e.p = "", e(0)
}([function(t, e, i) {
    (function(t) {
        "use strict";

        function e(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }
        var n = i(1),
            r = e(n),
            o = i(2),
            a = e(o),
            s = i(3),
            l = e(s),
            c = i(5),
            h = e(c),
            u = i(9),
            d = e(u),
            p = i(12),
            f = e(p),
            m = i(13),
            g = e(m),
            v = i(32),
            y = e(v),
            _ = i(33),
            x = e(_),
            b = i(34),
            w = e(b),
            T = i(35),
            S = e(T),
            M = i(36),
            E = e(M),
            A = i(37),
            C = e(A),
            P = i(28),
            R = e(P),
            L = i(4);
        L.CSSPlugin.defaultForce3D = !0, r.default.fn.unslick = function() {
            var t = void 0;
            return t.each(function(t, e) {
                e.slick && e.slick.destroy()
            })
        }, t.$ = window.$ = window.jQuery = r.default, (0, y.default)(), (0, r.default)("document").ready(function() {
            var t = (0, r.default)(".home-services").length ? (0, r.default)(".home-services") : (0, r.default)(".web-holder");
            (0, r.default)(".arrow-down").on("click", function(e) {
                (0, r.default)("html,body").animate({
                    scrollTop: t.offset().top - 100
                }, 1e3)
            }), (0, r.default)(document).on("click", ".star a", function() {
                r.default.ajax({
                    type: "GET",
                    url: (0, r.default)(this).data("href"),
                    success: function() {
                        window.location.reload()
                    }
                })
            }), (0, d.default)(), (0, E.default)(), (0, h.default)(), (0, l.default)(), (0, w.default)(), (0, x.default)(), (0, C.default)(), new f.default({
                selector: ".home-tabs",
                tabLinks: "li",
                attribute: "data-tab"
            }), new f.default({
                selector: ".tabs",
                tabLinks: "a"
            });
            var e = navigator.hardwareConcurrency,
                i = function() {
                    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream ? window.indexedDB ? "8>" : window.SpeechSynthesisUtterance ? "iOS 7" : window.webkitAudioContext ? "iOS 6" : window.matchMedia ? "iOS 5" : window.history && "pushState" in window.history ? "iOS 4" : "iOS 3 or earlier" : "Not an iOS device"
                },
                n = e >= 2 || "8>" === i() && e > 1 || "8>" === i() && void 0 === e;
            if (n)(0, g.default)();
            else {
                document.querySelector("html").classList.remove("can-animate");
                var o = document.querySelectorAll(".video-counter__text");
                if (o.forEach(function(t) {
                        t.textContent = t.dataset.text
                    }), document.getElementById("dots")) {
                    R.default.prepare();
                    var a = document.getElementById("dots"),
                        s = document.querySelector(".video-home .arrow-down");
                    window.innerWidth < 768 && a && s && s.parentNode.insertBefore(a, s.nextSibling)
                }
            }
            "3000" !== window.location.port && (0, S.default)();
            var c = document.querySelector(".video-home"),
                u = '<video muted loop autoplay>\n        <source src="data/video/home-video.webm" type="video/webm">\n        <source src="data/video/home-video.mp4" type="video/mp4">\n      </video>\n      <span class="video-home__volume disabled"><span>';
            if (c && window.innerWidth > 767) {
                c.insertAdjacentHTML("afterBegin", u);
                var p = c.querySelector("video");
                p.volume = 0;
                (0, r.default)(".video-home video").prop("unmuted", !0), (0, r.default)(".video-home__volume").on("click", function() {
                    (0, r.default)(this).toggleClass("disabled"), (0, r.default)(".video-home video").prop("muted") ? ((0, r.default)(".video-home video").prop("muted", !1), (0, r.default)(".video-home video")[0].volume = 1) : (0, r.default)(".video-home video").prop("muted", !0)
                })
            }(0, r.default)(".input-group input, .input-group texarea").change(function() {
                "" !== (0, r.default)(this).prop("value") && (0, r.default)(this).addClass("notempty")
            })
        }), (0, r.default)(window).on("scroll", function(t) {
            (0, r.default)(this).scrollTop() > 100 ? (0, r.default)(".home-header-holder").addClass("fixed") : (0, r.default)(".home-header-holder").removeClass("fixed")
        }), window.videoControllOnScroll = function() {
            setTimeout(function() {
                (0, a.default)(".cover-img video, .video-home video").on("enter", function(t) {
                    setTimeout(function() {
                        var e = (0, r.default)(t).currentTime > 0 && !(0, r.default)(t).paused && !(0, r.default)(t).ended && (0, r.default)(t).readyState > 2;
                        e || (0, r.default)(t).get(0).play()
                    }, 10)
                }), (0, a.default)(".cover-img video, .video-home video").on("exit", function(t) {
                    (0, r.default)(t).get(0).pause(), (0, r.default)(t).get(0).removeAttribute("autoplay")
                })
            }, 100)
        }, (0, r.default)(window).on("load", function() {
            window.videoControllOnScroll()
        }), (0, r.default)(".succes-popup__close, .succes-popup__overlay").on("click", function() {
            (0, r.default)(".succes-popup").css("display", "none")
        })
    }).call(e, function() {
        return this
    }())
}, function(t, e, i) {
    var n, r;
    ! function(e, i) {
        "use strict";
        "object" == typeof t && "object" == typeof t.exports ? t.exports = e.document ? i(e, !0) : function(t) {
            if (!t.document) throw new Error("jQuery requires a window with a document");
            return i(t)
        } : i(e)
    }("undefined" != typeof window ? window : this, function(i, o) {
        "use strict";

        function a(t, e, i) {
            i = i || dt;
            var n, r, o = i.createElement("script");
            if (o.text = t, e)
                for (n in Et) r = e[n] || e.getAttribute && e.getAttribute(n), r && o.setAttribute(n, r);
            i.head.appendChild(o).parentNode.removeChild(o)
        }

        function s(t) {
            return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? yt[_t.call(t)] || "object" : typeof t
        }

        function l(t) {
            var e = !!t && "length" in t && t.length,
                i = s(t);
            return !St(t) && !Mt(t) && ("array" === i || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
        }

        function c(t, e) {
            return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
        }

        function h(t, e, i) {
            return St(e) ? Ct.grep(t, function(t, n) {
                return !!e.call(t, n, t) !== i
            }) : e.nodeType ? Ct.grep(t, function(t) {
                return t === e !== i
            }) : "string" != typeof e ? Ct.grep(t, function(t) {
                return vt.call(e, t) > -1 !== i
            }) : Ct.filter(e, t, i)
        }

        function u(t, e) {
            for (;
                (t = t[e]) && 1 !== t.nodeType;);
            return t
        }

        function d(t) {
            var e = {};
            return Ct.each(t.match(zt) || [], function(t, i) {
                e[i] = !0
            }), e
        }

        function p(t) {
            return t
        }

        function f(t) {
            throw t
        }

        function m(t, e, i, n) {
            var r;
            try {
                t && St(r = t.promise) ? r.call(t).done(e).fail(i) : t && St(r = t.then) ? r.call(t, e, i) : e.apply(void 0, [t].slice(n))
            } catch (t) {
                i.apply(void 0, [t])
            }
        }

        function g() {
            dt.removeEventListener("DOMContentLoaded", g), i.removeEventListener("load", g), Ct.ready()
        }

        function v(t, e) {
            return e.toUpperCase()
        }

        function y(t) {
            return t.replace(Vt, "ms-").replace(Wt, v)
        }

        function _() {
            this.expando = Ct.expando + _.uid++
        }

        function x(t) {
            return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : Yt.test(t) ? JSON.parse(t) : t)
        }

        function b(t, e, i) {
            var n;
            if (void 0 === i && 1 === t.nodeType)
                if (n = "data-" + e.replace(Zt, "-$&").toLowerCase(), i = t.getAttribute(n), "string" == typeof i) {
                    try {
                        i = x(i)
                    } catch (t) {}
                    $t.set(t, e, i)
                } else i = void 0;
            return i
        }

        function w(t, e, i, n) {
            var r, o, a = 20,
                s = n ? function() {
                    return n.cur()
                } : function() {
                    return Ct.css(t, e, "")
                },
                l = s(),
                c = i && i[3] || (Ct.cssNumber[e] ? "" : "px"),
                h = t.nodeType && (Ct.cssNumber[e] || "px" !== c && +l) && Jt.exec(Ct.css(t, e));
            if (h && h[3] !== c) {
                for (l /= 2, c = c || h[3], h = +l || 1; a--;) Ct.style(t, e, h + c), (1 - o) * (1 - (o = s() / l || .5)) <= 0 && (a = 0), h /= o;
                h *= 2, Ct.style(t, e, h + c), i = i || []
            }
            return i && (h = +h || +l || 0, r = i[1] ? h + (i[1] + 1) * i[2] : +i[2], n && (n.unit = c, n.start = h, n.end = r)), r
        }

        function T(t) {
            var e, i = t.ownerDocument,
                n = t.nodeName,
                r = oe[n];
            return r ? r : (e = i.body.appendChild(i.createElement(n)), r = Ct.css(e, "display"), e.parentNode.removeChild(e), "none" === r && (r = "block"), oe[n] = r, r)
        }

        function S(t, e) {
            for (var i, n, r = [], o = 0, a = t.length; o < a; o++) n = t[o], n.style && (i = n.style.display, e ? ("none" === i && (r[o] = qt.get(n, "display") || null, r[o] || (n.style.display = "")), "" === n.style.display && ne(n) && (r[o] = T(n))) : "none" !== i && (r[o] = "none", qt.set(n, "display", i)));
            for (o = 0; o < a; o++) null != r[o] && (t[o].style.display = r[o]);
            return t
        }

        function M(t, e) {
            var i;
            return i = "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e || "*") : "undefined" != typeof t.querySelectorAll ? t.querySelectorAll(e || "*") : [], void 0 === e || e && c(t, e) ? Ct.merge([t], i) : i
        }

        function E(t, e) {
            for (var i = 0, n = t.length; i < n; i++) qt.set(t[i], "globalEval", !e || qt.get(e[i], "globalEval"))
        }

        function A(t, e, i, n, r) {
            for (var o, a, l, c, h, u, d = e.createDocumentFragment(), p = [], f = 0, m = t.length; f < m; f++)
                if (o = t[f], o || 0 === o)
                    if ("object" === s(o)) Ct.merge(p, o.nodeType ? [o] : o);
                    else if (he.test(o)) {
                for (a = a || d.appendChild(e.createElement("div")), l = (se.exec(o) || ["", ""])[1].toLowerCase(), c = ce[l] || ce._default, a.innerHTML = c[1] + Ct.htmlPrefilter(o) + c[2], u = c[0]; u--;) a = a.lastChild;
                Ct.merge(p, a.childNodes), a = d.firstChild, a.textContent = ""
            } else p.push(e.createTextNode(o));
            for (d.textContent = "", f = 0; o = p[f++];)
                if (n && Ct.inArray(o, n) > -1) r && r.push(o);
                else if (h = ee(o), a = M(d.appendChild(o), "script"), h && E(a), i)
                for (u = 0; o = a[u++];) le.test(o.type || "") && i.push(o);
            return d
        }

        function C() {
            return !0
        }

        function P() {
            return !1
        }

        function R(t, e) {
            return t === L() == ("focus" === e)
        }

        function L() {
            try {
                return dt.activeElement
            } catch (t) {}
        }

        function k(t, e, i, n, r, o) {
            var a, s;
            if ("object" == typeof e) {
                "string" != typeof i && (n = n || i, i = void 0);
                for (s in e) k(t, s, i, n, e[s], o);
                return t
            }
            if (null == n && null == r ? (r = i, n = i = void 0) : null == r && ("string" == typeof i ? (r = n, n = void 0) : (r = n, n = i, i = void 0)), r === !1) r = P;
            else if (!r) return t;
            return 1 === o && (a = r, r = function(t) {
                return Ct().off(t), a.apply(this, arguments)
            }, r.guid = a.guid || (a.guid = Ct.guid++)), t.each(function() {
                Ct.event.add(this, e, r, n, i)
            })
        }

        function O(t, e, i) {
            return i ? (qt.set(t, e, !1), void Ct.event.add(t, e, {
                namespace: !1,
                handler: function(t) {
                    var n, r, o = qt.get(this, e);
                    if (1 & t.isTrigger && this[e]) {
                        if (o.length)(Ct.event.special[e] || {}).delegateType && t.stopPropagation();
                        else if (o = ft.call(arguments), qt.set(this, e, o), n = i(this, e), this[e](), r = qt.get(this, e), o !== r || n ? qt.set(this, e, !1) : r = {}, o !== r) return t.stopImmediatePropagation(), t.preventDefault(), r.value
                    } else o.length && (qt.set(this, e, {
                        value: Ct.event.trigger(Ct.extend(o[0], Ct.Event.prototype), o.slice(1), this)
                    }), t.stopImmediatePropagation())
                }
            })) : void(void 0 === qt.get(t, e) && Ct.event.add(t, e, C))
        }

        function D(t, e) {
            return c(t, "table") && c(11 !== e.nodeType ? e : e.firstChild, "tr") ? Ct(t).children("tbody")[0] || t : t
        }

        function I(t) {
            return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t
        }

        function N(t) {
            return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"), t
        }

        function B(t, e) {
            var i, n, r, o, a, s, l, c;
            if (1 === e.nodeType) {
                if (qt.hasData(t) && (o = qt.access(t), a = qt.set(e, o), c = o.events)) {
                    delete a.handle, a.events = {};
                    for (r in c)
                        for (i = 0, n = c[r].length; i < n; i++) Ct.event.add(e, r, c[r][i])
                }
                $t.hasData(t) && (s = $t.access(t), l = Ct.extend({}, s), $t.set(e, l))
            }
        }

        function U(t, e) {
            var i = e.nodeName.toLowerCase();
            "input" === i && ae.test(t.type) ? e.checked = t.checked : "input" !== i && "textarea" !== i || (e.defaultValue = t.defaultValue)
        }

        function F(t, e, i, n) {
            e = mt.apply([], e);
            var r, o, s, l, c, h, u = 0,
                d = t.length,
                p = d - 1,
                f = e[0],
                m = St(f);
            if (m || d > 1 && "string" == typeof f && !Tt.checkClone && ge.test(f)) return t.each(function(r) {
                var o = t.eq(r);
                m && (e[0] = f.call(this, r, o.html())), F(o, e, i, n)
            });
            if (d && (r = A(e, t[0].ownerDocument, !1, t, n), o = r.firstChild, 1 === r.childNodes.length && (r = o), o || n)) {
                for (s = Ct.map(M(r, "script"), I), l = s.length; u < d; u++) c = r, u !== p && (c = Ct.clone(c, !0, !0), l && Ct.merge(s, M(c, "script"))), i.call(t[u], c, u);
                if (l)
                    for (h = s[s.length - 1].ownerDocument, Ct.map(s, N), u = 0; u < l; u++) c = s[u], le.test(c.type || "") && !qt.access(c, "globalEval") && Ct.contains(h, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? Ct._evalUrl && !c.noModule && Ct._evalUrl(c.src, {
                        nonce: c.nonce || c.getAttribute("nonce")
                    }) : a(c.textContent.replace(ve, ""), c, h))
            }
            return t
        }

        function z(t, e, i) {
            for (var n, r = e ? Ct.filter(e, t) : t, o = 0; null != (n = r[o]); o++) i || 1 !== n.nodeType || Ct.cleanData(M(n)), n.parentNode && (i && ee(n) && E(M(n, "script")), n.parentNode.removeChild(n));
            return t
        }

        function H(t, e, i) {
            var n, r, o, a, s = t.style;
            return i = i || _e(t), i && (a = i.getPropertyValue(e) || i[e], "" !== a || ee(t) || (a = Ct.style(t, e)), !Tt.pixelBoxStyles() && ye.test(a) && xe.test(e) && (n = s.width, r = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = i.width, s.width = n, s.minWidth = r, s.maxWidth = o)), void 0 !== a ? a + "" : a
        }

        function j(t, e) {
            return {
                get: function() {
                    return t() ? void delete this.get : (this.get = e).apply(this, arguments)
                }
            }
        }

        function G(t) {
            for (var e = t[0].toUpperCase() + t.slice(1), i = be.length; i--;)
                if (t = be[i] + e, t in we) return t
        }

        function V(t) {
            var e = Ct.cssProps[t] || Te[t];
            return e ? e : t in we ? t : Te[t] = G(t) || t
        }

        function W(t, e, i) {
            var n = Jt.exec(e);
            return n ? Math.max(0, n[2] - (i || 0)) + (n[3] || "px") : e
        }

        function X(t, e, i, n, r, o) {
            var a = "width" === e ? 1 : 0,
                s = 0,
                l = 0;
            if (i === (n ? "border" : "content")) return 0;
            for (; a < 4; a += 2) "margin" === i && (l += Ct.css(t, i + Kt[a], !0, r)), n ? ("content" === i && (l -= Ct.css(t, "padding" + Kt[a], !0, r)), "margin" !== i && (l -= Ct.css(t, "border" + Kt[a] + "Width", !0, r))) : (l += Ct.css(t, "padding" + Kt[a], !0, r), "padding" !== i ? l += Ct.css(t, "border" + Kt[a] + "Width", !0, r) : s += Ct.css(t, "border" + Kt[a] + "Width", !0, r));
            return !n && o >= 0 && (l += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - o - l - s - .5)) || 0), l
        }

        function q(t, e, i) {
            var n = _e(t),
                r = !Tt.boxSizingReliable() || i,
                o = r && "border-box" === Ct.css(t, "boxSizing", !1, n),
                a = o,
                s = H(t, e, n),
                l = "offset" + e[0].toUpperCase() + e.slice(1);
            if (ye.test(s)) {
                if (!i) return s;
                s = "auto"
            }
            return (!Tt.boxSizingReliable() && o || "auto" === s || !parseFloat(s) && "inline" === Ct.css(t, "display", !1, n)) && t.getClientRects().length && (o = "border-box" === Ct.css(t, "boxSizing", !1, n), a = l in t, a && (s = t[l])), s = parseFloat(s) || 0, s + X(t, e, i || (o ? "border" : "content"), a, n, s) + "px"
        }

        function $(t, e, i, n, r) {
            return new $.prototype.init(t, e, i, n, r)
        }

        function Y() {
            Pe && (dt.hidden === !1 && i.requestAnimationFrame ? i.requestAnimationFrame(Y) : i.setTimeout(Y, Ct.fx.interval), Ct.fx.tick())
        }

        function Z() {
            return i.setTimeout(function() {
                Ce = void 0
            }), Ce = Date.now()
        }

        function Q(t, e) {
            var i, n = 0,
                r = {
                    height: t
                };
            for (e = e ? 1 : 0; n < 4; n += 2 - e) i = Kt[n], r["margin" + i] = r["padding" + i] = t;
            return e && (r.opacity = r.width = t), r
        }

        function J(t, e, i) {
            for (var n, r = (et.tweeners[e] || []).concat(et.tweeners["*"]), o = 0, a = r.length; o < a; o++)
                if (n = r[o].call(i, e, t)) return n
        }

        function K(t, e, i) {
            var n, r, o, a, s, l, c, h, u = "width" in e || "height" in e,
                d = this,
                p = {},
                f = t.style,
                m = t.nodeType && ne(t),
                g = qt.get(t, "fxshow");
            i.queue || (a = Ct._queueHooks(t, "fx"), null == a.unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function() {
                a.unqueued || s()
            }), a.unqueued++, d.always(function() {
                d.always(function() {
                    a.unqueued--, Ct.queue(t, "fx").length || a.empty.fire()
                })
            }));
            for (n in e)
                if (r = e[n], Re.test(r)) {
                    if (delete e[n], o = o || "toggle" === r, r === (m ? "hide" : "show")) {
                        if ("show" !== r || !g || void 0 === g[n]) continue;
                        m = !0
                    }
                    p[n] = g && g[n] || Ct.style(t, n)
                }
            if (l = !Ct.isEmptyObject(e), l || !Ct.isEmptyObject(p)) {
                u && 1 === t.nodeType && (i.overflow = [f.overflow, f.overflowX, f.overflowY], c = g && g.display, null == c && (c = qt.get(t, "display")), h = Ct.css(t, "display"), "none" === h && (c ? h = c : (S([t], !0), c = t.style.display || c, h = Ct.css(t, "display"), S([t]))), ("inline" === h || "inline-block" === h && null != c) && "none" === Ct.css(t, "float") && (l || (d.done(function() {
                    f.display = c
                }), null == c && (h = f.display, c = "none" === h ? "" : h)), f.display = "inline-block")), i.overflow && (f.overflow = "hidden", d.always(function() {
                    f.overflow = i.overflow[0], f.overflowX = i.overflow[1], f.overflowY = i.overflow[2]
                })), l = !1;
                for (n in p) l || (g ? "hidden" in g && (m = g.hidden) : g = qt.access(t, "fxshow", {
                    display: c
                }), o && (g.hidden = !m), m && S([t], !0), d.done(function() {
                    m || S([t]), qt.remove(t, "fxshow");
                    for (n in p) Ct.style(t, n, p[n])
                })), l = J(m ? g[n] : 0, n, d), n in g || (g[n] = l.start, m && (l.end = l.start, l.start = 0))
            }
        }

        function tt(t, e) {
            var i, n, r, o, a;
            for (i in t)
                if (n = y(i), r = e[n], o = t[i], Array.isArray(o) && (r = o[1], o = t[i] = o[0]), i !== n && (t[n] = o, delete t[i]), a = Ct.cssHooks[n], a && "expand" in a) {
                    o = a.expand(o), delete t[n];
                    for (i in o) i in t || (t[i] = o[i], e[i] = r)
                } else e[n] = r
        }

        function et(t, e, i) {
            var n, r, o = 0,
                a = et.prefilters.length,
                s = Ct.Deferred().always(function() {
                    delete l.elem
                }),
                l = function() {
                    if (r) return !1;
                    for (var e = Ce || Z(), i = Math.max(0, c.startTime + c.duration - e), n = i / c.duration || 0, o = 1 - n, a = 0, l = c.tweens.length; a < l; a++) c.tweens[a].run(o);
                    return s.notifyWith(t, [c, o, i]), o < 1 && l ? i : (l || s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c]), !1)
                },
                c = s.promise({
                    elem: t,
                    props: Ct.extend({}, e),
                    opts: Ct.extend(!0, {
                        specialEasing: {},
                        easing: Ct.easing._default
                    }, i),
                    originalProperties: e,
                    originalOptions: i,
                    startTime: Ce || Z(),
                    duration: i.duration,
                    tweens: [],
                    createTween: function(e, i) {
                        var n = Ct.Tween(t, c.opts, e, i, c.opts.specialEasing[e] || c.opts.easing);
                        return c.tweens.push(n), n
                    },
                    stop: function(e) {
                        var i = 0,
                            n = e ? c.tweens.length : 0;
                        if (r) return this;
                        for (r = !0; i < n; i++) c.tweens[i].run(1);
                        return e ? (s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c, e])) : s.rejectWith(t, [c, e]), this
                    }
                }),
                h = c.props;
            for (tt(h, c.opts.specialEasing); o < a; o++)
                if (n = et.prefilters[o].call(c, t, h, c.opts)) return St(n.stop) && (Ct._queueHooks(c.elem, c.opts.queue).stop = n.stop.bind(n)), n;
            return Ct.map(h, J, c), St(c.opts.start) && c.opts.start.call(t, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), Ct.fx.timer(Ct.extend(l, {
                elem: t,
                anim: c,
                queue: c.opts.queue
            })), c
        }

        function it(t) {
            var e = t.match(zt) || [];
            return e.join(" ")
        }

        function nt(t) {
            return t.getAttribute && t.getAttribute("class") || ""
        }

        function rt(t) {
            return Array.isArray(t) ? t : "string" == typeof t ? t.match(zt) || [] : []
        }

        function ot(t, e, i, n) {
            var r;
            if (Array.isArray(e)) Ct.each(e, function(e, r) {
                i || je.test(t) ? n(t, r) : ot(t + "[" + ("object" == typeof r && null != r ? e : "") + "]", r, i, n)
            });
            else if (i || "object" !== s(e)) n(t, e);
            else
                for (r in e) ot(t + "[" + r + "]", e[r], i, n)
        }

        function at(t) {
            return function(e, i) {
                "string" != typeof e && (i = e, e = "*");
                var n, r = 0,
                    o = e.toLowerCase().match(zt) || [];
                if (St(i))
                    for (; n = o[r++];) "+" === n[0] ? (n = n.slice(1) || "*", (t[n] = t[n] || []).unshift(i)) : (t[n] = t[n] || []).push(i)
            }
        }

        function st(t, e, i, n) {
            function r(s) {
                var l;
                return o[s] = !0, Ct.each(t[s] || [], function(t, s) {
                    var c = s(e, i, n);
                    return "string" != typeof c || a || o[c] ? a ? !(l = c) : void 0 : (e.dataTypes.unshift(c), r(c), !1)
                }), l
            }
            var o = {},
                a = t === ti;
            return r(e.dataTypes[0]) || !o["*"] && r("*")
        }

        function lt(t, e) {
            var i, n, r = Ct.ajaxSettings.flatOptions || {};
            for (i in e) void 0 !== e[i] && ((r[i] ? t : n || (n = {}))[i] = e[i]);
            return n && Ct.extend(!0, t, n), t
        }

        function ct(t, e, i) {
            for (var n, r, o, a, s = t.contents, l = t.dataTypes;
                "*" === l[0];) l.shift(), void 0 === n && (n = t.mimeType || e.getResponseHeader("Content-Type"));
            if (n)
                for (r in s)
                    if (s[r] && s[r].test(n)) {
                        l.unshift(r);
                        break
                    }
            if (l[0] in i) o = l[0];
            else {
                for (r in i) {
                    if (!l[0] || t.converters[r + " " + l[0]]) {
                        o = r;
                        break
                    }
                    a || (a = r)
                }
                o = o || a
            }
            if (o) return o !== l[0] && l.unshift(o), i[o]
        }

        function ht(t, e, i, n) {
            var r, o, a, s, l, c = {},
                h = t.dataTypes.slice();
            if (h[1])
                for (a in t.converters) c[a.toLowerCase()] = t.converters[a];
            for (o = h.shift(); o;)
                if (t.responseFields[o] && (i[t.responseFields[o]] = e), !l && n && t.dataFilter && (e = t.dataFilter(e, t.dataType)), l = o, o = h.shift())
                    if ("*" === o) o = l;
                    else if ("*" !== l && l !== o) {
                if (a = c[l + " " + o] || c["* " + o], !a)
                    for (r in c)
                        if (s = r.split(" "), s[1] === o && (a = c[l + " " + s[0]] || c["* " + s[0]])) {
                            a === !0 ? a = c[r] : c[r] !== !0 && (o = s[0], h.unshift(s[1]));
                            break
                        }
                if (a !== !0)
                    if (a && t.throws) e = a(e);
                    else try {
                        e = a(e)
                    } catch (t) {
                        return {
                            state: "parsererror",
                            error: a ? t : "No conversion from " + l + " to " + o
                        }
                    }
            }
            return {
                state: "success",
                data: e
            }
        }
        var ut = [],
            dt = i.document,
            pt = Object.getPrototypeOf,
            ft = ut.slice,
            mt = ut.concat,
            gt = ut.push,
            vt = ut.indexOf,
            yt = {},
            _t = yt.toString,
            xt = yt.hasOwnProperty,
            bt = xt.toString,
            wt = bt.call(Object),
            Tt = {},
            St = function(t) {
                return "function" == typeof t && "number" != typeof t.nodeType
            },
            Mt = function(t) {
                return null != t && t === t.window
            },
            Et = {
                type: !0,
                src: !0,
                nonce: !0,
                noModule: !0
            },
            At = "3.4.1",
            Ct = function(t, e) {
                return new Ct.fn.init(t, e)
            },
            Pt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        Ct.fn = Ct.prototype = {
            jquery: At,
            constructor: Ct,
            length: 0,
            toArray: function() {
                return ft.call(this)
            },
            get: function(t) {
                return null == t ? ft.call(this) : t < 0 ? this[t + this.length] : this[t]
            },
            pushStack: function(t) {
                var e = Ct.merge(this.constructor(), t);
                return e.prevObject = this, e
            },
            each: function(t) {
                return Ct.each(this, t)
            },
            map: function(t) {
                return this.pushStack(Ct.map(this, function(e, i) {
                    return t.call(e, i, e)
                }))
            },
            slice: function() {
                return this.pushStack(ft.apply(this, arguments))
            },
            first: function() {
                return this.eq(0)
            },
            last: function() {
                return this.eq(-1)
            },
            eq: function(t) {
                var e = this.length,
                    i = +t + (t < 0 ? e : 0);
                return this.pushStack(i >= 0 && i < e ? [this[i]] : [])
            },
            end: function() {
                return this.prevObject || this.constructor()
            },
            push: gt,
            sort: ut.sort,
            splice: ut.splice
        }, Ct.extend = Ct.fn.extend = function() {
            var t, e, i, n, r, o, a = arguments[0] || {},
                s = 1,
                l = arguments.length,
                c = !1;
            for ("boolean" == typeof a && (c = a, a = arguments[s] || {}, s++), "object" == typeof a || St(a) || (a = {}), s === l && (a = this, s--); s < l; s++)
                if (null != (t = arguments[s]))
                    for (e in t) n = t[e], "__proto__" !== e && a !== n && (c && n && (Ct.isPlainObject(n) || (r = Array.isArray(n))) ? (i = a[e], o = r && !Array.isArray(i) ? [] : r || Ct.isPlainObject(i) ? i : {}, r = !1, a[e] = Ct.extend(c, o, n)) : void 0 !== n && (a[e] = n));
            return a
        }, Ct.extend({
            expando: "jQuery" + (At + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function(t) {
                throw new Error(t)
            },
            noop: function() {},
            isPlainObject: function(t) {
                var e, i;
                return !(!t || "[object Object]" !== _t.call(t)) && (!(e = pt(t)) || (i = xt.call(e, "constructor") && e.constructor, "function" == typeof i && bt.call(i) === wt))
            },
            isEmptyObject: function(t) {
                var e;
                for (e in t) return !1;
                return !0
            },
            globalEval: function(t, e) {
                a(t, {
                    nonce: e && e.nonce
                })
            },
            each: function(t, e) {
                var i, n = 0;
                if (l(t))
                    for (i = t.length; n < i && e.call(t[n], n, t[n]) !== !1; n++);
                else
                    for (n in t)
                        if (e.call(t[n], n, t[n]) === !1) break;
                return t
            },
            trim: function(t) {
                return null == t ? "" : (t + "").replace(Pt, "")
            },
            makeArray: function(t, e) {
                var i = e || [];
                return null != t && (l(Object(t)) ? Ct.merge(i, "string" == typeof t ? [t] : t) : gt.call(i, t)), i
            },
            inArray: function(t, e, i) {
                return null == e ? -1 : vt.call(e, t, i)
            },
            merge: function(t, e) {
                for (var i = +e.length, n = 0, r = t.length; n < i; n++) t[r++] = e[n];
                return t.length = r, t
            },
            grep: function(t, e, i) {
                for (var n, r = [], o = 0, a = t.length, s = !i; o < a; o++) n = !e(t[o], o), n !== s && r.push(t[o]);
                return r
            },
            map: function(t, e, i) {
                var n, r, o = 0,
                    a = [];
                if (l(t))
                    for (n = t.length; o < n; o++) r = e(t[o], o, i), null != r && a.push(r);
                else
                    for (o in t) r = e(t[o], o, i), null != r && a.push(r);
                return mt.apply([], a)
            },
            guid: 1,
            support: Tt
        }), "function" == typeof Symbol && (Ct.fn[Symbol.iterator] = ut[Symbol.iterator]), Ct.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(t, e) {
            yt["[object " + e + "]"] = e.toLowerCase()
        });
        var Rt = function(t) {
            function e(t, e, i, n) {
                var r, o, a, s, l, c, h, d = e && e.ownerDocument,
                    f = e ? e.nodeType : 9;
                if (i = i || [], "string" != typeof t || !t || 1 !== f && 9 !== f && 11 !== f) return i;
                if (!n && ((e ? e.ownerDocument || e : H) !== O && k(e), e = e || O, I)) {
                    if (11 !== f && (l = _t.exec(t)))
                        if (r = l[1]) {
                            if (9 === f) {
                                if (!(a = e.getElementById(r))) return i;
                                if (a.id === r) return i.push(a), i
                            } else if (d && (a = d.getElementById(r)) && F(e, a) && a.id === r) return i.push(a), i
                        } else {
                            if (l[2]) return K.apply(i, e.getElementsByTagName(t)), i;
                            if ((r = l[3]) && w.getElementsByClassName && e.getElementsByClassName) return K.apply(i, e.getElementsByClassName(r)), i
                        }
                    if (w.qsa && !q[t + " "] && (!N || !N.test(t)) && (1 !== f || "object" !== e.nodeName.toLowerCase())) {
                        if (h = t, d = e, 1 === f && ut.test(t)) {
                            for ((s = e.getAttribute("id")) ? s = s.replace(Tt, St) : e.setAttribute("id", s = z), c = E(t), o = c.length; o--;) c[o] = "#" + s + " " + p(c[o]);
                            h = c.join(","), d = xt.test(t) && u(e.parentNode) || e
                        }
                        try {
                            return K.apply(i, d.querySelectorAll(h)), i
                        } catch (e) {
                            q(t, !0)
                        } finally {
                            s === z && e.removeAttribute("id")
                        }
                    }
                }
                return C(t.replace(lt, "$1"), e, i, n)
            }

            function i() {
                function t(i, n) {
                    return e.push(i + " ") > T.cacheLength && delete t[e.shift()], t[i + " "] = n
                }
                var e = [];
                return t
            }

            function n(t) {
                return t[z] = !0, t
            }

            function r(t) {
                var e = O.createElement("fieldset");
                try {
                    return !!t(e)
                } catch (t) {
                    return !1
                } finally {
                    e.parentNode && e.parentNode.removeChild(e), e = null
                }
            }

            function o(t, e) {
                for (var i = t.split("|"), n = i.length; n--;) T.attrHandle[i[n]] = e
            }

            function a(t, e) {
                var i = e && t,
                    n = i && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
                if (n) return n;
                if (i)
                    for (; i = i.nextSibling;)
                        if (i === e) return -1;
                return t ? 1 : -1
            }

            function s(t) {
                return function(e) {
                    var i = e.nodeName.toLowerCase();
                    return "input" === i && e.type === t
                }
            }

            function l(t) {
                return function(e) {
                    var i = e.nodeName.toLowerCase();
                    return ("input" === i || "button" === i) && e.type === t
                }
            }

            function c(t) {
                return function(e) {
                    return "form" in e ? e.parentNode && e.disabled === !1 ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && Et(e) === t : e.disabled === t : "label" in e && e.disabled === t
                }
            }

            function h(t) {
                return n(function(e) {
                    return e = +e, n(function(i, n) {
                        for (var r, o = t([], i.length, e), a = o.length; a--;) i[r = o[a]] && (i[r] = !(n[r] = i[r]))
                    })
                })
            }

            function u(t) {
                return t && "undefined" != typeof t.getElementsByTagName && t
            }

            function d() {}

            function p(t) {
                for (var e = 0, i = t.length, n = ""; e < i; e++) n += t[e].value;
                return n
            }

            function f(t, e, i) {
                var n = e.dir,
                    r = e.next,
                    o = r || n,
                    a = i && "parentNode" === o,
                    s = G++;
                return e.first ? function(e, i, r) {
                    for (; e = e[n];)
                        if (1 === e.nodeType || a) return t(e, i, r);
                    return !1
                } : function(e, i, l) {
                    var c, h, u, d = [j, s];
                    if (l) {
                        for (; e = e[n];)
                            if ((1 === e.nodeType || a) && t(e, i, l)) return !0
                    } else
                        for (; e = e[n];)
                            if (1 === e.nodeType || a)
                                if (u = e[z] || (e[z] = {}), h = u[e.uniqueID] || (u[e.uniqueID] = {}), r && r === e.nodeName.toLowerCase()) e = e[n] || e;
                                else {
                                    if ((c = h[o]) && c[0] === j && c[1] === s) return d[2] = c[2];
                                    if (h[o] = d, d[2] = t(e, i, l)) return !0
                                } return !1
                }
            }

            function m(t) {
                return t.length > 1 ? function(e, i, n) {
                    for (var r = t.length; r--;)
                        if (!t[r](e, i, n)) return !1;
                    return !0
                } : t[0]
            }

            function g(t, i, n) {
                for (var r = 0, o = i.length; r < o; r++) e(t, i[r], n);
                return n
            }

            function v(t, e, i, n, r) {
                for (var o, a = [], s = 0, l = t.length, c = null != e; s < l; s++)(o = t[s]) && (i && !i(o, n, r) || (a.push(o), c && e.push(s)));
                return a
            }

            function y(t, e, i, r, o, a) {
                return r && !r[z] && (r = y(r)), o && !o[z] && (o = y(o, a)), n(function(n, a, s, l) {
                    var c, h, u, d = [],
                        p = [],
                        f = a.length,
                        m = n || g(e || "*", s.nodeType ? [s] : s, []),
                        y = !t || !n && e ? m : v(m, d, t, s, l),
                        _ = i ? o || (n ? t : f || r) ? [] : a : y;
                    if (i && i(y, _, s, l), r)
                        for (c = v(_, p), r(c, [], s, l), h = c.length; h--;)(u = c[h]) && (_[p[h]] = !(y[p[h]] = u));
                    if (n) {
                        if (o || t) {
                            if (o) {
                                for (c = [], h = _.length; h--;)(u = _[h]) && c.push(y[h] = u);
                                o(null, _ = [], c, l)
                            }
                            for (h = _.length; h--;)(u = _[h]) && (c = o ? et(n, u) : d[h]) > -1 && (n[c] = !(a[c] = u))
                        }
                    } else _ = v(_ === a ? _.splice(f, _.length) : _), o ? o(null, a, _, l) : K.apply(a, _)
                })
            }

            function _(t) {
                for (var e, i, n, r = t.length, o = T.relative[t[0].type], a = o || T.relative[" "], s = o ? 1 : 0, l = f(function(t) {
                        return t === e
                    }, a, !0), c = f(function(t) {
                        return et(e, t) > -1
                    }, a, !0), h = [function(t, i, n) {
                        var r = !o && (n || i !== P) || ((e = i).nodeType ? l(t, i, n) : c(t, i, n));
                        return e = null, r
                    }]; s < r; s++)
                    if (i = T.relative[t[s].type]) h = [f(m(h), i)];
                    else {
                        if (i = T.filter[t[s].type].apply(null, t[s].matches), i[z]) {
                            for (n = ++s; n < r && !T.relative[t[n].type]; n++);
                            return y(s > 1 && m(h), s > 1 && p(t.slice(0, s - 1).concat({
                                value: " " === t[s - 2].type ? "*" : ""
                            })).replace(lt, "$1"), i, s < n && _(t.slice(s, n)), n < r && _(t = t.slice(n)), n < r && p(t))
                        }
                        h.push(i)
                    }
                return m(h)
            }

            function x(t, i) {
                var r = i.length > 0,
                    o = t.length > 0,
                    a = function(n, a, s, l, c) {
                        var h, u, d, p = 0,
                            f = "0",
                            m = n && [],
                            g = [],
                            y = P,
                            _ = n || o && T.find.TAG("*", c),
                            x = j += null == y ? 1 : Math.random() || .1,
                            b = _.length;
                        for (c && (P = a === O || a || c); f !== b && null != (h = _[f]); f++) {
                            if (o && h) {
                                for (u = 0, a || h.ownerDocument === O || (k(h), s = !I); d = t[u++];)
                                    if (d(h, a || O, s)) {
                                        l.push(h);
                                        break
                                    }
                                c && (j = x)
                            }
                            r && ((h = !d && h) && p--, n && m.push(h))
                        }
                        if (p += f, r && f !== p) {
                            for (u = 0; d = i[u++];) d(m, g, a, s);
                            if (n) {
                                if (p > 0)
                                    for (; f--;) m[f] || g[f] || (g[f] = Q.call(l));
                                g = v(g)
                            }
                            K.apply(l, g), c && !n && g.length > 0 && p + i.length > 1 && e.uniqueSort(l)
                        }
                        return c && (j = x, P = y), m
                    };
                return r ? n(a) : a
            }
            var b, w, T, S, M, E, A, C, P, R, L, k, O, D, I, N, B, U, F, z = "sizzle" + 1 * new Date,
                H = t.document,
                j = 0,
                G = 0,
                V = i(),
                W = i(),
                X = i(),
                q = i(),
                $ = function(t, e) {
                    return t === e && (L = !0), 0
                },
                Y = {}.hasOwnProperty,
                Z = [],
                Q = Z.pop,
                J = Z.push,
                K = Z.push,
                tt = Z.slice,
                et = function(t, e) {
                    for (var i = 0, n = t.length; i < n; i++)
                        if (t[i] === e) return i;
                    return -1
                },
                it = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                nt = "[\\x20\\t\\r\\n\\f]",
                rt = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
                ot = "\\[" + nt + "*(" + rt + ")(?:" + nt + "*([*^$|!~]?=)" + nt + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + rt + "))|)" + nt + "*\\]",
                at = ":(" + rt + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + ot + ")*)|.*)\\)|)",
                st = new RegExp(nt + "+", "g"),
                lt = new RegExp("^" + nt + "+|((?:^|[^\\\\])(?:\\\\.)*)" + nt + "+$", "g"),
                ct = new RegExp("^" + nt + "*," + nt + "*"),
                ht = new RegExp("^" + nt + "*([>+~]|" + nt + ")" + nt + "*"),
                ut = new RegExp(nt + "|>"),
                dt = new RegExp(at),
                pt = new RegExp("^" + rt + "$"),
                ft = {
                    ID: new RegExp("^#(" + rt + ")"),
                    CLASS: new RegExp("^\\.(" + rt + ")"),
                    TAG: new RegExp("^(" + rt + "|[*])"),
                    ATTR: new RegExp("^" + ot),
                    PSEUDO: new RegExp("^" + at),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + nt + "*(even|odd|(([+-]|)(\\d*)n|)" + nt + "*(?:([+-]|)" + nt + "*(\\d+)|))" + nt + "*\\)|)", "i"),
                    bool: new RegExp("^(?:" + it + ")$", "i"),
                    needsContext: new RegExp("^" + nt + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + nt + "*((?:-\\d)?\\d*)" + nt + "*\\)|)(?=[^-]|$)", "i")
                },
                mt = /HTML$/i,
                gt = /^(?:input|select|textarea|button)$/i,
                vt = /^h\d$/i,
                yt = /^[^{]+\{\s*\[native \w/,
                _t = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                xt = /[+~]/,
                bt = new RegExp("\\\\([\\da-f]{1,6}" + nt + "?|(" + nt + ")|.)", "ig"),
                wt = function(t, e, i) {
                    var n = "0x" + e - 65536;
                    return n !== n || i ? e : n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)
                },
                Tt = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                St = function(t, e) {
                    return e ? "\0" === t ? "ï¿½" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
                },
                Mt = function() {
                    k()
                },
                Et = f(function(t) {
                    return t.disabled === !0 && "fieldset" === t.nodeName.toLowerCase()
                }, {
                    dir: "parentNode",
                    next: "legend"
                });
            try {
                K.apply(Z = tt.call(H.childNodes), H.childNodes), Z[H.childNodes.length].nodeType
            } catch (t) {
                K = {
                    apply: Z.length ? function(t, e) {
                        J.apply(t, tt.call(e))
                    } : function(t, e) {
                        for (var i = t.length, n = 0; t[i++] = e[n++];);
                        t.length = i - 1
                    }
                }
            }
            w = e.support = {}, M = e.isXML = function(t) {
                var e = t.namespaceURI,
                    i = (t.ownerDocument || t).documentElement;
                return !mt.test(e || i && i.nodeName || "HTML")
            }, k = e.setDocument = function(t) {
                var e, i, n = t ? t.ownerDocument || t : H;
                return n !== O && 9 === n.nodeType && n.documentElement ? (O = n, D = O.documentElement, I = !M(O), H !== O && (i = O.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", Mt, !1) : i.attachEvent && i.attachEvent("onunload", Mt)), w.attributes = r(function(t) {
                    return t.className = "i", !t.getAttribute("className")
                }), w.getElementsByTagName = r(function(t) {
                    return t.appendChild(O.createComment("")), !t.getElementsByTagName("*").length
                }), w.getElementsByClassName = yt.test(O.getElementsByClassName), w.getById = r(function(t) {
                    return D.appendChild(t).id = z, !O.getElementsByName || !O.getElementsByName(z).length
                }), w.getById ? (T.filter.ID = function(t) {
                    var e = t.replace(bt, wt);
                    return function(t) {
                        return t.getAttribute("id") === e
                    }
                }, T.find.ID = function(t, e) {
                    if ("undefined" != typeof e.getElementById && I) {
                        var i = e.getElementById(t);
                        return i ? [i] : []
                    }
                }) : (T.filter.ID = function(t) {
                    var e = t.replace(bt, wt);
                    return function(t) {
                        var i = "undefined" != typeof t.getAttributeNode && t.getAttributeNode("id");
                        return i && i.value === e
                    }
                }, T.find.ID = function(t, e) {
                    if ("undefined" != typeof e.getElementById && I) {
                        var i, n, r, o = e.getElementById(t);
                        if (o) {
                            if (i = o.getAttributeNode("id"), i && i.value === t) return [o];
                            for (r = e.getElementsByName(t), n = 0; o = r[n++];)
                                if (i = o.getAttributeNode("id"), i && i.value === t) return [o]
                        }
                        return []
                    }
                }), T.find.TAG = w.getElementsByTagName ? function(t, e) {
                    return "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t) : w.qsa ? e.querySelectorAll(t) : void 0
                } : function(t, e) {
                    var i, n = [],
                        r = 0,
                        o = e.getElementsByTagName(t);
                    if ("*" === t) {
                        for (; i = o[r++];) 1 === i.nodeType && n.push(i);
                        return n
                    }
                    return o
                }, T.find.CLASS = w.getElementsByClassName && function(t, e) {
                    if ("undefined" != typeof e.getElementsByClassName && I) return e.getElementsByClassName(t)
                }, B = [], N = [], (w.qsa = yt.test(O.querySelectorAll)) && (r(function(t) {
                    D.appendChild(t).innerHTML = "<a id='" + z + "'></a><select id='" + z + "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll("[msallowcapture^='']").length && N.push("[*^$]=" + nt + "*(?:''|\"\")"), t.querySelectorAll("[selected]").length || N.push("\\[" + nt + "*(?:value|" + it + ")"), t.querySelectorAll("[id~=" + z + "-]").length || N.push("~="), t.querySelectorAll(":checked").length || N.push(":checked"), t.querySelectorAll("a#" + z + "+*").length || N.push(".#.+[+~]")
                }), r(function(t) {
                    t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    var e = O.createElement("input");
                    e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll("[name=d]").length && N.push("name" + nt + "*[*^$|!~]?="), 2 !== t.querySelectorAll(":enabled").length && N.push(":enabled", ":disabled"), D.appendChild(t).disabled = !0, 2 !== t.querySelectorAll(":disabled").length && N.push(":enabled", ":disabled"), t.querySelectorAll("*,:x"), N.push(",.*:")
                })), (w.matchesSelector = yt.test(U = D.matches || D.webkitMatchesSelector || D.mozMatchesSelector || D.oMatchesSelector || D.msMatchesSelector)) && r(function(t) {
                    w.disconnectedMatch = U.call(t, "*"), U.call(t, "[s!='']:x"), B.push("!=", at)
                }), N = N.length && new RegExp(N.join("|")), B = B.length && new RegExp(B.join("|")), e = yt.test(D.compareDocumentPosition), F = e || yt.test(D.contains) ? function(t, e) {
                    var i = 9 === t.nodeType ? t.documentElement : t,
                        n = e && e.parentNode;
                    return t === n || !(!n || 1 !== n.nodeType || !(i.contains ? i.contains(n) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(n)))
                } : function(t, e) {
                    if (e)
                        for (; e = e.parentNode;)
                            if (e === t) return !0;
                    return !1
                }, $ = e ? function(t, e) {
                    if (t === e) return L = !0, 0;
                    var i = !t.compareDocumentPosition - !e.compareDocumentPosition;
                    return i ? i : (i = (t.ownerDocument || t) === (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1, 1 & i || !w.sortDetached && e.compareDocumentPosition(t) === i ? t === O || t.ownerDocument === H && F(H, t) ? -1 : e === O || e.ownerDocument === H && F(H, e) ? 1 : R ? et(R, t) - et(R, e) : 0 : 4 & i ? -1 : 1)
                } : function(t, e) {
                    if (t === e) return L = !0, 0;
                    var i, n = 0,
                        r = t.parentNode,
                        o = e.parentNode,
                        s = [t],
                        l = [e];
                    if (!r || !o) return t === O ? -1 : e === O ? 1 : r ? -1 : o ? 1 : R ? et(R, t) - et(R, e) : 0;
                    if (r === o) return a(t, e);
                    for (i = t; i = i.parentNode;) s.unshift(i);
                    for (i = e; i = i.parentNode;) l.unshift(i);
                    for (; s[n] === l[n];) n++;
                    return n ? a(s[n], l[n]) : s[n] === H ? -1 : l[n] === H ? 1 : 0
                }, O) : O
            }, e.matches = function(t, i) {
                return e(t, null, null, i)
            }, e.matchesSelector = function(t, i) {
                if ((t.ownerDocument || t) !== O && k(t), w.matchesSelector && I && !q[i + " "] && (!B || !B.test(i)) && (!N || !N.test(i))) try {
                    var n = U.call(t, i);
                    if (n || w.disconnectedMatch || t.document && 11 !== t.document.nodeType) return n
                } catch (t) {
                    q(i, !0)
                }
                return e(i, O, null, [t]).length > 0
            }, e.contains = function(t, e) {
                return (t.ownerDocument || t) !== O && k(t), F(t, e)
            }, e.attr = function(t, e) {
                (t.ownerDocument || t) !== O && k(t);
                var i = T.attrHandle[e.toLowerCase()],
                    n = i && Y.call(T.attrHandle, e.toLowerCase()) ? i(t, e, !I) : void 0;
                return void 0 !== n ? n : w.attributes || !I ? t.getAttribute(e) : (n = t.getAttributeNode(e)) && n.specified ? n.value : null
            }, e.escape = function(t) {
                return (t + "").replace(Tt, St)
            }, e.error = function(t) {
                throw new Error("Syntax error, unrecognized expression: " + t)
            }, e.uniqueSort = function(t) {
                var e, i = [],
                    n = 0,
                    r = 0;
                if (L = !w.detectDuplicates, R = !w.sortStable && t.slice(0), t.sort($), L) {
                    for (; e = t[r++];) e === t[r] && (n = i.push(r));
                    for (; n--;) t.splice(i[n], 1)
                }
                return R = null, t
            }, S = e.getText = function(t) {
                var e, i = "",
                    n = 0,
                    r = t.nodeType;
                if (r) {
                    if (1 === r || 9 === r || 11 === r) {
                        if ("string" == typeof t.textContent) return t.textContent;
                        for (t = t.firstChild; t; t = t.nextSibling) i += S(t)
                    } else if (3 === r || 4 === r) return t.nodeValue
                } else
                    for (; e = t[n++];) i += S(e);
                return i
            }, T = e.selectors = {
                cacheLength: 50,
                createPseudo: n,
                match: ft,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {
                        dir: "parentNode",
                        first: !0
                    },
                    " ": {
                        dir: "parentNode"
                    },
                    "+": {
                        dir: "previousSibling",
                        first: !0
                    },
                    "~": {
                        dir: "previousSibling"
                    }
                },
                preFilter: {
                    ATTR: function(t) {
                        return t[1] = t[1].replace(bt, wt), t[3] = (t[3] || t[4] || t[5] || "").replace(bt, wt), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
                    },
                    CHILD: function(t) {
                        return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || e.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && e.error(t[0]), t
                    },
                    PSEUDO: function(t) {
                        var e, i = !t[6] && t[2];
                        return ft.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : i && dt.test(i) && (e = E(i, !0)) && (e = i.indexOf(")", i.length - e) - i.length) && (t[0] = t[0].slice(0, e), t[2] = i.slice(0, e)), t.slice(0, 3))
                    }
                },
                filter: {
                    TAG: function(t) {
                        var e = t.replace(bt, wt).toLowerCase();
                        return "*" === t ? function() {
                            return !0
                        } : function(t) {
                            return t.nodeName && t.nodeName.toLowerCase() === e
                        }
                    },
                    CLASS: function(t) {
                        var e = V[t + " "];
                        return e || (e = new RegExp("(^|" + nt + ")" + t + "(" + nt + "|$)")) && V(t, function(t) {
                            return e.test("string" == typeof t.className && t.className || "undefined" != typeof t.getAttribute && t.getAttribute("class") || "")
                        })
                    },
                    ATTR: function(t, i, n) {
                        return function(r) {
                            var o = e.attr(r, t);
                            return null == o ? "!=" === i : !i || (o += "", "=" === i ? o === n : "!=" === i ? o !== n : "^=" === i ? n && 0 === o.indexOf(n) : "*=" === i ? n && o.indexOf(n) > -1 : "$=" === i ? n && o.slice(-n.length) === n : "~=" === i ? (" " + o.replace(st, " ") + " ").indexOf(n) > -1 : "|=" === i && (o === n || o.slice(0, n.length + 1) === n + "-"))
                        }
                    },
                    CHILD: function(t, e, i, n, r) {
                        var o = "nth" !== t.slice(0, 3),
                            a = "last" !== t.slice(-4),
                            s = "of-type" === e;
                        return 1 === n && 0 === r ? function(t) {
                            return !!t.parentNode
                        } : function(e, i, l) {
                            var c, h, u, d, p, f, m = o !== a ? "nextSibling" : "previousSibling",
                                g = e.parentNode,
                                v = s && e.nodeName.toLowerCase(),
                                y = !l && !s,
                                _ = !1;
                            if (g) {
                                if (o) {
                                    for (; m;) {
                                        for (d = e; d = d[m];)
                                            if (s ? d.nodeName.toLowerCase() === v : 1 === d.nodeType) return !1;
                                        f = m = "only" === t && !f && "nextSibling"
                                    }
                                    return !0
                                }
                                if (f = [a ? g.firstChild : g.lastChild], a && y) {
                                    for (d = g, u = d[z] || (d[z] = {}), h = u[d.uniqueID] || (u[d.uniqueID] = {}), c = h[t] || [], p = c[0] === j && c[1], _ = p && c[2], d = p && g.childNodes[p]; d = ++p && d && d[m] || (_ = p = 0) || f.pop();)
                                        if (1 === d.nodeType && ++_ && d === e) {
                                            h[t] = [j, p, _];
                                            break
                                        }
                                } else if (y && (d = e, u = d[z] || (d[z] = {}), h = u[d.uniqueID] || (u[d.uniqueID] = {}), c = h[t] || [], p = c[0] === j && c[1], _ = p), _ === !1)
                                    for (;
                                        (d = ++p && d && d[m] || (_ = p = 0) || f.pop()) && ((s ? d.nodeName.toLowerCase() !== v : 1 !== d.nodeType) || !++_ || (y && (u = d[z] || (d[z] = {}), h = u[d.uniqueID] || (u[d.uniqueID] = {}), h[t] = [j, _]), d !== e)););
                                return _ -= r, _ === n || _ % n === 0 && _ / n >= 0
                            }
                        }
                    },
                    PSEUDO: function(t, i) {
                        var r, o = T.pseudos[t] || T.setFilters[t.toLowerCase()] || e.error("unsupported pseudo: " + t);
                        return o[z] ? o(i) : o.length > 1 ? (r = [t, t, "", i], T.setFilters.hasOwnProperty(t.toLowerCase()) ? n(function(t, e) {
                            for (var n, r = o(t, i), a = r.length; a--;) n = et(t, r[a]), t[n] = !(e[n] = r[a])
                        }) : function(t) {
                            return o(t, 0, r)
                        }) : o
                    }
                },
                pseudos: {
                    not: n(function(t) {
                        var e = [],
                            i = [],
                            r = A(t.replace(lt, "$1"));
                        return r[z] ? n(function(t, e, i, n) {
                            for (var o, a = r(t, null, n, []), s = t.length; s--;)(o = a[s]) && (t[s] = !(e[s] = o))
                        }) : function(t, n, o) {
                            return e[0] = t, r(e, null, o, i), e[0] = null, !i.pop()
                        }
                    }),
                    has: n(function(t) {
                        return function(i) {
                            return e(t, i).length > 0
                        }
                    }),
                    contains: n(function(t) {
                        return t = t.replace(bt, wt),
                            function(e) {
                                return (e.textContent || S(e)).indexOf(t) > -1
                            }
                    }),
                    lang: n(function(t) {
                        return pt.test(t || "") || e.error("unsupported lang: " + t), t = t.replace(bt, wt).toLowerCase(),
                            function(e) {
                                var i;
                                do
                                    if (i = I ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return i = i.toLowerCase(), i === t || 0 === i.indexOf(t + "-"); while ((e = e.parentNode) && 1 === e.nodeType);
                                return !1
                            }
                    }),
                    target: function(e) {
                        var i = t.location && t.location.hash;
                        return i && i.slice(1) === e.id
                    },
                    root: function(t) {
                        return t === D
                    },
                    focus: function(t) {
                        return t === O.activeElement && (!O.hasFocus || O.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
                    },
                    enabled: c(!1),
                    disabled: c(!0),
                    checked: function(t) {
                        var e = t.nodeName.toLowerCase();
                        return "input" === e && !!t.checked || "option" === e && !!t.selected
                    },
                    selected: function(t) {
                        return t.parentNode && t.parentNode.selectedIndex, t.selected === !0
                    },
                    empty: function(t) {
                        for (t = t.firstChild; t; t = t.nextSibling)
                            if (t.nodeType < 6) return !1;
                        return !0
                    },
                    parent: function(t) {
                        return !T.pseudos.empty(t)
                    },
                    header: function(t) {
                        return vt.test(t.nodeName)
                    },
                    input: function(t) {
                        return gt.test(t.nodeName)
                    },
                    button: function(t) {
                        var e = t.nodeName.toLowerCase();
                        return "input" === e && "button" === t.type || "button" === e
                    },
                    text: function(t) {
                        var e;
                        return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
                    },
                    first: h(function() {
                        return [0]
                    }),
                    last: h(function(t, e) {
                        return [e - 1]
                    }),
                    eq: h(function(t, e, i) {
                        return [i < 0 ? i + e : i]
                    }),
                    even: h(function(t, e) {
                        for (var i = 0; i < e; i += 2) t.push(i);
                        return t
                    }),
                    odd: h(function(t, e) {
                        for (var i = 1; i < e; i += 2) t.push(i);
                        return t
                    }),
                    lt: h(function(t, e, i) {
                        for (var n = i < 0 ? i + e : i > e ? e : i; --n >= 0;) t.push(n);
                        return t
                    }),
                    gt: h(function(t, e, i) {
                        for (var n = i < 0 ? i + e : i; ++n < e;) t.push(n);
                        return t
                    })
                }
            }, T.pseudos.nth = T.pseudos.eq;
            for (b in {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) T.pseudos[b] = s(b);
            for (b in {
                    submit: !0,
                    reset: !0
                }) T.pseudos[b] = l(b);
            return d.prototype = T.filters = T.pseudos, T.setFilters = new d, E = e.tokenize = function(t, i) {
                var n, r, o, a, s, l, c, h = W[t + " "];
                if (h) return i ? 0 : h.slice(0);
                for (s = t, l = [], c = T.preFilter; s;) {
                    n && !(r = ct.exec(s)) || (r && (s = s.slice(r[0].length) || s), l.push(o = [])), n = !1, (r = ht.exec(s)) && (n = r.shift(), o.push({
                        value: n,
                        type: r[0].replace(lt, " ")
                    }), s = s.slice(n.length));
                    for (a in T.filter) !(r = ft[a].exec(s)) || c[a] && !(r = c[a](r)) || (n = r.shift(), o.push({
                        value: n,
                        type: a,
                        matches: r
                    }), s = s.slice(n.length));
                    if (!n) break
                }
                return i ? s.length : s ? e.error(t) : W(t, l).slice(0)
            }, A = e.compile = function(t, e) {
                var i, n = [],
                    r = [],
                    o = X[t + " "];
                if (!o) {
                    for (e || (e = E(t)), i = e.length; i--;) o = _(e[i]), o[z] ? n.push(o) : r.push(o);
                    o = X(t, x(r, n)), o.selector = t
                }
                return o
            }, C = e.select = function(t, e, i, n) {
                var r, o, a, s, l, c = "function" == typeof t && t,
                    h = !n && E(t = c.selector || t);
                if (i = i || [], 1 === h.length) {
                    if (o = h[0] = h[0].slice(0), o.length > 2 && "ID" === (a = o[0]).type && 9 === e.nodeType && I && T.relative[o[1].type]) {
                        if (e = (T.find.ID(a.matches[0].replace(bt, wt), e) || [])[0], !e) return i;
                        c && (e = e.parentNode), t = t.slice(o.shift().value.length)
                    }
                    for (r = ft.needsContext.test(t) ? 0 : o.length; r-- && (a = o[r], !T.relative[s = a.type]);)
                        if ((l = T.find[s]) && (n = l(a.matches[0].replace(bt, wt), xt.test(o[0].type) && u(e.parentNode) || e))) {
                            if (o.splice(r, 1), t = n.length && p(o), !t) return K.apply(i, n), i;
                            break
                        }
                }
                return (c || A(t, h))(n, e, !I, i, !e || xt.test(t) && u(e.parentNode) || e), i
            }, w.sortStable = z.split("").sort($).join("") === z, w.detectDuplicates = !!L, k(), w.sortDetached = r(function(t) {
                return 1 & t.compareDocumentPosition(O.createElement("fieldset"))
            }), r(function(t) {
                return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
            }) || o("type|href|height|width", function(t, e, i) {
                if (!i) return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
            }), w.attributes && r(function(t) {
                return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value")
            }) || o("value", function(t, e, i) {
                if (!i && "input" === t.nodeName.toLowerCase()) return t.defaultValue
            }), r(function(t) {
                return null == t.getAttribute("disabled")
            }) || o(it, function(t, e, i) {
                var n;
                if (!i) return t[e] === !0 ? e.toLowerCase() : (n = t.getAttributeNode(e)) && n.specified ? n.value : null
            }), e
        }(i);
        Ct.find = Rt, Ct.expr = Rt.selectors, Ct.expr[":"] = Ct.expr.pseudos, Ct.uniqueSort = Ct.unique = Rt.uniqueSort, Ct.text = Rt.getText, Ct.isXMLDoc = Rt.isXML, Ct.contains = Rt.contains, Ct.escapeSelector = Rt.escape;
        var Lt = function(t, e, i) {
                for (var n = [], r = void 0 !== i;
                    (t = t[e]) && 9 !== t.nodeType;)
                    if (1 === t.nodeType) {
                        if (r && Ct(t).is(i)) break;
                        n.push(t)
                    }
                return n
            },
            kt = function(t, e) {
                for (var i = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && i.push(t);
                return i
            },
            Ot = Ct.expr.match.needsContext,
            Dt = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        Ct.filter = function(t, e, i) {
            var n = e[0];
            return i && (t = ":not(" + t + ")"), 1 === e.length && 1 === n.nodeType ? Ct.find.matchesSelector(n, t) ? [n] : [] : Ct.find.matches(t, Ct.grep(e, function(t) {
                return 1 === t.nodeType
            }))
        }, Ct.fn.extend({
            find: function(t) {
                var e, i, n = this.length,
                    r = this;
                if ("string" != typeof t) return this.pushStack(Ct(t).filter(function() {
                    for (e = 0; e < n; e++)
                        if (Ct.contains(r[e], this)) return !0
                }));
                for (i = this.pushStack([]), e = 0; e < n; e++) Ct.find(t, r[e], i);
                return n > 1 ? Ct.uniqueSort(i) : i
            },
            filter: function(t) {
                return this.pushStack(h(this, t || [], !1))
            },
            not: function(t) {
                return this.pushStack(h(this, t || [], !0))
            },
            is: function(t) {
                return !!h(this, "string" == typeof t && Ot.test(t) ? Ct(t) : t || [], !1).length
            }
        });
        var It, Nt = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
            Bt = Ct.fn.init = function(t, e, i) {
                var n, r;
                if (!t) return this;
                if (i = i || It, "string" == typeof t) {
                    if (n = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : Nt.exec(t), !n || !n[1] && e) return !e || e.jquery ? (e || i).find(t) : this.constructor(e).find(t);
                    if (n[1]) {
                        if (e = e instanceof Ct ? e[0] : e, Ct.merge(this, Ct.parseHTML(n[1], e && e.nodeType ? e.ownerDocument || e : dt, !0)), Dt.test(n[1]) && Ct.isPlainObject(e))
                            for (n in e) St(this[n]) ? this[n](e[n]) : this.attr(n, e[n]);
                        return this
                    }
                    return r = dt.getElementById(n[2]), r && (this[0] = r, this.length = 1), this
                }
                return t.nodeType ? (this[0] = t, this.length = 1, this) : St(t) ? void 0 !== i.ready ? i.ready(t) : t(Ct) : Ct.makeArray(t, this)
            };
        Bt.prototype = Ct.fn, It = Ct(dt);
        var Ut = /^(?:parents|prev(?:Until|All))/,
            Ft = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };
        Ct.fn.extend({
            has: function(t) {
                var e = Ct(t, this),
                    i = e.length;
                return this.filter(function() {
                    for (var t = 0; t < i; t++)
                        if (Ct.contains(this, e[t])) return !0
                })
            },
            closest: function(t, e) {
                var i, n = 0,
                    r = this.length,
                    o = [],
                    a = "string" != typeof t && Ct(t);
                if (!Ot.test(t))
                    for (; n < r; n++)
                        for (i = this[n]; i && i !== e; i = i.parentNode)
                            if (i.nodeType < 11 && (a ? a.index(i) > -1 : 1 === i.nodeType && Ct.find.matchesSelector(i, t))) {
                                o.push(i);
                                break
                            }
                return this.pushStack(o.length > 1 ? Ct.uniqueSort(o) : o)
            },
            index: function(t) {
                return t ? "string" == typeof t ? vt.call(Ct(t), this[0]) : vt.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            },
            add: function(t, e) {
                return this.pushStack(Ct.uniqueSort(Ct.merge(this.get(), Ct(t, e))))
            },
            addBack: function(t) {
                return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
            }
        }), Ct.each({
            parent: function(t) {
                var e = t.parentNode;
                return e && 11 !== e.nodeType ? e : null
            },
            parents: function(t) {
                return Lt(t, "parentNode")
            },
            parentsUntil: function(t, e, i) {
                return Lt(t, "parentNode", i)
            },
            next: function(t) {
                return u(t, "nextSibling")
            },
            prev: function(t) {
                return u(t, "previousSibling")
            },
            nextAll: function(t) {
                return Lt(t, "nextSibling")
            },
            prevAll: function(t) {
                return Lt(t, "previousSibling")
            },
            nextUntil: function(t, e, i) {
                return Lt(t, "nextSibling", i)
            },
            prevUntil: function(t, e, i) {
                return Lt(t, "previousSibling", i)
            },
            siblings: function(t) {
                return kt((t.parentNode || {}).firstChild, t)
            },
            children: function(t) {
                return kt(t.firstChild)
            },
            contents: function(t) {
                return "undefined" != typeof t.contentDocument ? t.contentDocument : (c(t, "template") && (t = t.content || t), Ct.merge([], t.childNodes))
            }
        }, function(t, e) {
            Ct.fn[t] = function(i, n) {
                var r = Ct.map(this, e, i);
                return "Until" !== t.slice(-5) && (n = i), n && "string" == typeof n && (r = Ct.filter(n, r)), this.length > 1 && (Ft[t] || Ct.uniqueSort(r), Ut.test(t) && r.reverse()), this.pushStack(r)
            }
        });
        var zt = /[^\x20\t\r\n\f]+/g;
        Ct.Callbacks = function(t) {
            t = "string" == typeof t ? d(t) : Ct.extend({}, t);
            var e, i, n, r, o = [],
                a = [],
                l = -1,
                c = function() {
                    for (r = r || t.once, n = e = !0; a.length; l = -1)
                        for (i = a.shift(); ++l < o.length;) o[l].apply(i[0], i[1]) === !1 && t.stopOnFalse && (l = o.length, i = !1);
                    t.memory || (i = !1), e = !1, r && (o = i ? [] : "")
                },
                h = {
                    add: function() {
                        return o && (i && !e && (l = o.length - 1, a.push(i)), function e(i) {
                            Ct.each(i, function(i, n) {
                                St(n) ? t.unique && h.has(n) || o.push(n) : n && n.length && "string" !== s(n) && e(n)
                            })
                        }(arguments), i && !e && c()), this
                    },
                    remove: function() {
                        return Ct.each(arguments, function(t, e) {
                            for (var i;
                                (i = Ct.inArray(e, o, i)) > -1;) o.splice(i, 1), i <= l && l--
                        }), this
                    },
                    has: function(t) {
                        return t ? Ct.inArray(t, o) > -1 : o.length > 0
                    },
                    empty: function() {
                        return o && (o = []), this
                    },
                    disable: function() {
                        return r = a = [], o = i = "", this
                    },
                    disabled: function() {
                        return !o
                    },
                    lock: function() {
                        return r = a = [], i || e || (o = i = ""), this
                    },
                    locked: function() {
                        return !!r
                    },
                    fireWith: function(t, i) {
                        return r || (i = i || [], i = [t, i.slice ? i.slice() : i], a.push(i), e || c()), this
                    },
                    fire: function() {
                        return h.fireWith(this, arguments), this
                    },
                    fired: function() {
                        return !!n
                    }
                };
            return h
        }, Ct.extend({
            Deferred: function(t) {
                var e = [
                        ["notify", "progress", Ct.Callbacks("memory"), Ct.Callbacks("memory"), 2],
                        ["resolve", "done", Ct.Callbacks("once memory"), Ct.Callbacks("once memory"), 0, "resolved"],
                        ["reject", "fail", Ct.Callbacks("once memory"), Ct.Callbacks("once memory"), 1, "rejected"]
                    ],
                    n = "pending",
                    r = {
                        state: function() {
                            return n
                        },
                        always: function() {
                            return o.done(arguments).fail(arguments), this
                        },
                        catch: function(t) {
                            return r.then(null, t)
                        },
                        pipe: function() {
                            var t = arguments;
                            return Ct.Deferred(function(i) {
                                Ct.each(e, function(e, n) {
                                    var r = St(t[n[4]]) && t[n[4]];
                                    o[n[1]](function() {
                                        var t = r && r.apply(this, arguments);
                                        t && St(t.promise) ? t.promise().progress(i.notify).done(i.resolve).fail(i.reject) : i[n[0] + "With"](this, r ? [t] : arguments)
                                    })
                                }), t = null
                            }).promise()
                        },
                        then: function(t, n, r) {
                            function o(t, e, n, r) {
                                return function() {
                                    var s = this,
                                        l = arguments,
                                        c = function() {
                                            var i, c;
                                            if (!(t < a)) {
                                                if (i = n.apply(s, l), i === e.promise()) throw new TypeError("Thenable self-resolution");
                                                c = i && ("object" == typeof i || "function" == typeof i) && i.then, St(c) ? r ? c.call(i, o(a, e, p, r), o(a, e, f, r)) : (a++, c.call(i, o(a, e, p, r), o(a, e, f, r), o(a, e, p, e.notifyWith))) : (n !== p && (s = void 0, l = [i]), (r || e.resolveWith)(s, l))
                                            }
                                        },
                                        h = r ? c : function() {
                                            try {
                                                c()
                                            } catch (i) {
                                                Ct.Deferred.exceptionHook && Ct.Deferred.exceptionHook(i, h.stackTrace), t + 1 >= a && (n !== f && (s = void 0, l = [i]), e.rejectWith(s, l))
                                            }
                                        };
                                    t ? h() : (Ct.Deferred.getStackHook && (h.stackTrace = Ct.Deferred.getStackHook()), i.setTimeout(h))
                                }
                            }
                            var a = 0;
                            return Ct.Deferred(function(i) {
                                e[0][3].add(o(0, i, St(r) ? r : p, i.notifyWith)), e[1][3].add(o(0, i, St(t) ? t : p)), e[2][3].add(o(0, i, St(n) ? n : f))
                            }).promise()
                        },
                        promise: function(t) {
                            return null != t ? Ct.extend(t, r) : r
                        }
                    },
                    o = {};
                return Ct.each(e, function(t, i) {
                    var a = i[2],
                        s = i[5];
                    r[i[1]] = a.add, s && a.add(function() {
                        n = s
                    }, e[3 - t][2].disable, e[3 - t][3].disable, e[0][2].lock, e[0][3].lock), a.add(i[3].fire), o[i[0]] = function() {
                        return o[i[0] + "With"](this === o ? void 0 : this, arguments), this
                    }, o[i[0] + "With"] = a.fireWith
                }), r.promise(o), t && t.call(o, o), o
            },
            when: function(t) {
                var e = arguments.length,
                    i = e,
                    n = Array(i),
                    r = ft.call(arguments),
                    o = Ct.Deferred(),
                    a = function(t) {
                        return function(i) {
                            n[t] = this, r[t] = arguments.length > 1 ? ft.call(arguments) : i, --e || o.resolveWith(n, r)
                        }
                    };
                if (e <= 1 && (m(t, o.done(a(i)).resolve, o.reject, !e), "pending" === o.state() || St(r[i] && r[i].then))) return o.then();
                for (; i--;) m(r[i], a(i), o.reject);
                return o.promise()
            }
        });
        var Ht = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        Ct.Deferred.exceptionHook = function(t, e) {
            i.console && i.console.warn && t && Ht.test(t.name) && i.console.warn("jQuery.Deferred exception: " + t.message, t.stack, e)
        }, Ct.readyException = function(t) {
            i.setTimeout(function() {
                throw t
            })
        };
        var jt = Ct.Deferred();
        Ct.fn.ready = function(t) {
            return jt.then(t).catch(function(t) {
                Ct.readyException(t)
            }), this
        }, Ct.extend({
            isReady: !1,
            readyWait: 1,
            ready: function(t) {
                (t === !0 ? --Ct.readyWait : Ct.isReady) || (Ct.isReady = !0, t !== !0 && --Ct.readyWait > 0 || jt.resolveWith(dt, [Ct]))
            }
        }), Ct.ready.then = jt.then, "complete" === dt.readyState || "loading" !== dt.readyState && !dt.documentElement.doScroll ? i.setTimeout(Ct.ready) : (dt.addEventListener("DOMContentLoaded", g), i.addEventListener("load", g));
        var Gt = function(t, e, i, n, r, o, a) {
                var l = 0,
                    c = t.length,
                    h = null == i;
                if ("object" === s(i)) {
                    r = !0;
                    for (l in i) Gt(t, e, l, i[l], !0, o, a)
                } else if (void 0 !== n && (r = !0, St(n) || (a = !0), h && (a ? (e.call(t, n), e = null) : (h = e, e = function(t, e, i) {
                        return h.call(Ct(t), i)
                    })), e))
                    for (; l < c; l++) e(t[l], i, a ? n : n.call(t[l], l, e(t[l], i)));
                return r ? t : h ? e.call(t) : c ? e(t[0], i) : o
            },
            Vt = /^-ms-/,
            Wt = /-([a-z])/g,
            Xt = function(t) {
                return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
            };
        _.uid = 1, _.prototype = {
            cache: function(t) {
                var e = t[this.expando];
                return e || (e = {}, Xt(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
                    value: e,
                    configurable: !0
                }))), e
            },
            set: function(t, e, i) {
                var n, r = this.cache(t);
                if ("string" == typeof e) r[y(e)] = i;
                else
                    for (n in e) r[y(n)] = e[n];
                return r
            },
            get: function(t, e) {
                return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][y(e)]
            },
            access: function(t, e, i) {
                return void 0 === e || e && "string" == typeof e && void 0 === i ? this.get(t, e) : (this.set(t, e, i), void 0 !== i ? i : e)
            },
            remove: function(t, e) {
                var i, n = t[this.expando];
                if (void 0 !== n) {
                    if (void 0 !== e) {
                        Array.isArray(e) ? e = e.map(y) : (e = y(e), e = e in n ? [e] : e.match(zt) || []), i = e.length;
                        for (; i--;) delete n[e[i]]
                    }(void 0 === e || Ct.isEmptyObject(n)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando])
                }
            },
            hasData: function(t) {
                var e = t[this.expando];
                return void 0 !== e && !Ct.isEmptyObject(e)
            }
        };
        var qt = new _,
            $t = new _,
            Yt = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            Zt = /[A-Z]/g;
        Ct.extend({
            hasData: function(t) {
                return $t.hasData(t) || qt.hasData(t)
            },
            data: function(t, e, i) {
                return $t.access(t, e, i)
            },
            removeData: function(t, e) {
                $t.remove(t, e)
            },
            _data: function(t, e, i) {
                return qt.access(t, e, i)
            },
            _removeData: function(t, e) {
                qt.remove(t, e)
            }
        }), Ct.fn.extend({
            data: function(t, e) {
                var i, n, r, o = this[0],
                    a = o && o.attributes;
                if (void 0 === t) {
                    if (this.length && (r = $t.get(o), 1 === o.nodeType && !qt.get(o, "hasDataAttrs"))) {
                        for (i = a.length; i--;) a[i] && (n = a[i].name, 0 === n.indexOf("data-") && (n = y(n.slice(5)), b(o, n, r[n])));
                        qt.set(o, "hasDataAttrs", !0)
                    }
                    return r
                }
                return "object" == typeof t ? this.each(function() {
                    $t.set(this, t)
                }) : Gt(this, function(e) {
                    var i;
                    if (o && void 0 === e) {
                        if (i = $t.get(o, t), void 0 !== i) return i;
                        if (i = b(o, t), void 0 !== i) return i
                    } else this.each(function() {
                        $t.set(this, t, e)
                    })
                }, null, e, arguments.length > 1, null, !0)
            },
            removeData: function(t) {
                return this.each(function() {
                    $t.remove(this, t)
                })
            }
        }), Ct.extend({
            queue: function(t, e, i) {
                var n;
                if (t) return e = (e || "fx") + "queue", n = qt.get(t, e), i && (!n || Array.isArray(i) ? n = qt.access(t, e, Ct.makeArray(i)) : n.push(i)), n || []
            },
            dequeue: function(t, e) {
                e = e || "fx";
                var i = Ct.queue(t, e),
                    n = i.length,
                    r = i.shift(),
                    o = Ct._queueHooks(t, e),
                    a = function() {
                        Ct.dequeue(t, e)
                    };
                "inprogress" === r && (r = i.shift(), n--), r && ("fx" === e && i.unshift("inprogress"), delete o.stop, r.call(t, a, o)), !n && o && o.empty.fire()
            },
            _queueHooks: function(t, e) {
                var i = e + "queueHooks";
                return qt.get(t, i) || qt.access(t, i, {
                    empty: Ct.Callbacks("once memory").add(function() {
                        qt.remove(t, [e + "queue", i])
                    })
                })
            }
        }), Ct.fn.extend({
            queue: function(t, e) {
                var i = 2;
                return "string" != typeof t && (e = t, t = "fx", i--), arguments.length < i ? Ct.queue(this[0], t) : void 0 === e ? this : this.each(function() {
                    var i = Ct.queue(this, t, e);
                    Ct._queueHooks(this, t), "fx" === t && "inprogress" !== i[0] && Ct.dequeue(this, t)
                })
            },
            dequeue: function(t) {
                return this.each(function() {
                    Ct.dequeue(this, t)
                })
            },
            clearQueue: function(t) {
                return this.queue(t || "fx", [])
            },
            promise: function(t, e) {
                var i, n = 1,
                    r = Ct.Deferred(),
                    o = this,
                    a = this.length,
                    s = function() {
                        --n || r.resolveWith(o, [o])
                    };
                for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; a--;) i = qt.get(o[a], t + "queueHooks"), i && i.empty && (n++, i.empty.add(s));
                return s(), r.promise(e)
            }
        });
        var Qt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            Jt = new RegExp("^(?:([+-])=|)(" + Qt + ")([a-z%]*)$", "i"),
            Kt = ["Top", "Right", "Bottom", "Left"],
            te = dt.documentElement,
            ee = function(t) {
                return Ct.contains(t.ownerDocument, t)
            },
            ie = {
                composed: !0
            };
        te.getRootNode && (ee = function(t) {
            return Ct.contains(t.ownerDocument, t) || t.getRootNode(ie) === t.ownerDocument
        });
        var ne = function(t, e) {
                return t = e || t, "none" === t.style.display || "" === t.style.display && ee(t) && "none" === Ct.css(t, "display")
            },
            re = function(t, e, i, n) {
                var r, o, a = {};
                for (o in e) a[o] = t.style[o], t.style[o] = e[o];
                r = i.apply(t, n || []);
                for (o in e) t.style[o] = a[o];
                return r
            },
            oe = {};
        Ct.fn.extend({
            show: function() {
                return S(this, !0)
            },
            hide: function() {
                return S(this)
            },
            toggle: function(t) {
                return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each(function() {
                    ne(this) ? Ct(this).show() : Ct(this).hide()
                })
            }
        });
        var ae = /^(?:checkbox|radio)$/i,
            se = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
            le = /^$|^module$|\/(?:java|ecma)script/i,
            ce = {
                option: [1, "<select multiple='multiple'>", "</select>"],
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: [0, "", ""]
            };
        ce.optgroup = ce.option, ce.tbody = ce.tfoot = ce.colgroup = ce.caption = ce.thead, ce.th = ce.td;
        var he = /<|&#?\w+;/;
        ! function() {
            var t = dt.createDocumentFragment(),
                e = t.appendChild(dt.createElement("div")),
                i = dt.createElement("input");
            i.setAttribute("type", "radio"), i.setAttribute("checked", "checked"), i.setAttribute("name", "t"), e.appendChild(i), Tt.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = "<textarea>x</textarea>", Tt.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue
        }();
        var ue = /^key/,
            de = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
            pe = /^([^.]*)(?:\.(.+)|)/;
        Ct.event = {
            global: {},
            add: function(t, e, i, n, r) {
                var o, a, s, l, c, h, u, d, p, f, m, g = qt.get(t);
                if (g)
                    for (i.handler && (o = i, i = o.handler, r = o.selector), r && Ct.find.matchesSelector(te, r), i.guid || (i.guid = Ct.guid++), (l = g.events) || (l = g.events = {}), (a = g.handle) || (a = g.handle = function(e) {
                            return "undefined" != typeof Ct && Ct.event.triggered !== e.type ? Ct.event.dispatch.apply(t, arguments) : void 0
                        }), e = (e || "").match(zt) || [""], c = e.length; c--;) s = pe.exec(e[c]) || [], p = m = s[1], f = (s[2] || "").split(".").sort(), p && (u = Ct.event.special[p] || {}, p = (r ? u.delegateType : u.bindType) || p, u = Ct.event.special[p] || {}, h = Ct.extend({
                        type: p,
                        origType: m,
                        data: n,
                        handler: i,
                        guid: i.guid,
                        selector: r,
                        needsContext: r && Ct.expr.match.needsContext.test(r),
                        namespace: f.join(".")
                    }, o), (d = l[p]) || (d = l[p] = [], d.delegateCount = 0, u.setup && u.setup.call(t, n, f, a) !== !1 || t.addEventListener && t.addEventListener(p, a)), u.add && (u.add.call(t, h), h.handler.guid || (h.handler.guid = i.guid)), r ? d.splice(d.delegateCount++, 0, h) : d.push(h), Ct.event.global[p] = !0)
            },
            remove: function(t, e, i, n, r) {
                var o, a, s, l, c, h, u, d, p, f, m, g = qt.hasData(t) && qt.get(t);
                if (g && (l = g.events)) {
                    for (e = (e || "").match(zt) || [""], c = e.length; c--;)
                        if (s = pe.exec(e[c]) || [], p = m = s[1], f = (s[2] || "").split(".").sort(), p) {
                            for (u = Ct.event.special[p] || {}, p = (n ? u.delegateType : u.bindType) || p, d = l[p] || [], s = s[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = d.length; o--;) h = d[o], !r && m !== h.origType || i && i.guid !== h.guid || s && !s.test(h.namespace) || n && n !== h.selector && ("**" !== n || !h.selector) || (d.splice(o, 1), h.selector && d.delegateCount--, u.remove && u.remove.call(t, h));
                            a && !d.length && (u.teardown && u.teardown.call(t, f, g.handle) !== !1 || Ct.removeEvent(t, p, g.handle), delete l[p])
                        } else
                            for (p in l) Ct.event.remove(t, p + e[c], i, n, !0);
                    Ct.isEmptyObject(l) && qt.remove(t, "handle events")
                }
            },
            dispatch: function(t) {
                var e, i, n, r, o, a, s = Ct.event.fix(t),
                    l = new Array(arguments.length),
                    c = (qt.get(this, "events") || {})[s.type] || [],
                    h = Ct.event.special[s.type] || {};
                for (l[0] = s, e = 1; e < arguments.length; e++) l[e] = arguments[e];
                if (s.delegateTarget = this, !h.preDispatch || h.preDispatch.call(this, s) !== !1) {
                    for (a = Ct.event.handlers.call(this, s, c), e = 0;
                        (r = a[e++]) && !s.isPropagationStopped();)
                        for (s.currentTarget = r.elem, i = 0;
                            (o = r.handlers[i++]) && !s.isImmediatePropagationStopped();) s.rnamespace && o.namespace !== !1 && !s.rnamespace.test(o.namespace) || (s.handleObj = o, s.data = o.data, n = ((Ct.event.special[o.origType] || {}).handle || o.handler).apply(r.elem, l), void 0 !== n && (s.result = n) === !1 && (s.preventDefault(), s.stopPropagation()));
                    return h.postDispatch && h.postDispatch.call(this, s), s.result
                }
            },
            handlers: function(t, e) {
                var i, n, r, o, a, s = [],
                    l = e.delegateCount,
                    c = t.target;
                if (l && c.nodeType && !("click" === t.type && t.button >= 1))
                    for (; c !== this; c = c.parentNode || this)
                        if (1 === c.nodeType && ("click" !== t.type || c.disabled !== !0)) {
                            for (o = [], a = {}, i = 0; i < l; i++) n = e[i], r = n.selector + " ", void 0 === a[r] && (a[r] = n.needsContext ? Ct(r, this).index(c) > -1 : Ct.find(r, this, null, [c]).length), a[r] && o.push(n);
                            o.length && s.push({
                                elem: c,
                                handlers: o
                            })
                        }
                return c = this, l < e.length && s.push({
                    elem: c,
                    handlers: e.slice(l)
                }), s
            },
            addProp: function(t, e) {
                Object.defineProperty(Ct.Event.prototype, t, {
                    enumerable: !0,
                    configurable: !0,
                    get: St(e) ? function() {
                        if (this.originalEvent) return e(this.originalEvent)
                    } : function() {
                        if (this.originalEvent) return this.originalEvent[t]
                    },
                    set: function(e) {
                        Object.defineProperty(this, t, {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: e
                        })
                    }
                })
            },
            fix: function(t) {
                return t[Ct.expando] ? t : new Ct.Event(t)
            },
            special: {
                load: {
                    noBubble: !0
                },
                click: {
                    setup: function(t) {
                        var e = this || t;
                        return ae.test(e.type) && e.click && c(e, "input") && O(e, "click", C), !1
                    },
                    trigger: function(t) {
                        var e = this || t;
                        return ae.test(e.type) && e.click && c(e, "input") && O(e, "click"), !0
                    },
                    _default: function(t) {
                        var e = t.target;
                        return ae.test(e.type) && e.click && c(e, "input") && qt.get(e, "click") || c(e, "a")
                    }
                },
                beforeunload: {
                    postDispatch: function(t) {
                        void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
                    }
                }
            }
        }, Ct.removeEvent = function(t, e, i) {
            t.removeEventListener && t.removeEventListener(e, i)
        }, Ct.Event = function(t, e) {
            return this instanceof Ct.Event ? (t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && t.returnValue === !1 ? C : P, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t, e && Ct.extend(this, e), this.timeStamp = t && t.timeStamp || Date.now(), void(this[Ct.expando] = !0)) : new Ct.Event(t, e)
        }, Ct.Event.prototype = {
            constructor: Ct.Event,
            isDefaultPrevented: P,
            isPropagationStopped: P,
            isImmediatePropagationStopped: P,
            isSimulated: !1,
            preventDefault: function() {
                var t = this.originalEvent;
                this.isDefaultPrevented = C, t && !this.isSimulated && t.preventDefault()
            },
            stopPropagation: function() {
                var t = this.originalEvent;
                this.isPropagationStopped = C, t && !this.isSimulated && t.stopPropagation()
            },
            stopImmediatePropagation: function() {
                var t = this.originalEvent;
                this.isImmediatePropagationStopped = C, t && !this.isSimulated && t.stopImmediatePropagation(), this.stopPropagation()
            }
        }, Ct.each({
            altKey: !0,
            bubbles: !0,
            cancelable: !0,
            changedTouches: !0,
            ctrlKey: !0,
            detail: !0,
            eventPhase: !0,
            metaKey: !0,
            pageX: !0,
            pageY: !0,
            shiftKey: !0,
            view: !0,
            char: !0,
            code: !0,
            charCode: !0,
            key: !0,
            keyCode: !0,
            button: !0,
            buttons: !0,
            clientX: !0,
            clientY: !0,
            offsetX: !0,
            offsetY: !0,
            pointerId: !0,
            pointerType: !0,
            screenX: !0,
            screenY: !0,
            targetTouches: !0,
            toElement: !0,
            touches: !0,
            which: function(t) {
                var e = t.button;
                return null == t.which && ue.test(t.type) ? null != t.charCode ? t.charCode : t.keyCode : !t.which && void 0 !== e && de.test(t.type) ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : t.which
            }
        }, Ct.event.addProp), Ct.each({
            focus: "focusin",
            blur: "focusout"
        }, function(t, e) {
            Ct.event.special[t] = {
                setup: function() {
                    return O(this, t, R), !1
                },
                trigger: function() {
                    return O(this, t), !0
                },
                delegateType: e
            }
        }), Ct.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, function(t, e) {
            Ct.event.special[t] = {
                delegateType: e,
                bindType: e,
                handle: function(t) {
                    var i, n = this,
                        r = t.relatedTarget,
                        o = t.handleObj;
                    return r && (r === n || Ct.contains(n, r)) || (t.type = o.origType, i = o.handler.apply(this, arguments), t.type = e), i
                }
            }
        }), Ct.fn.extend({
            on: function(t, e, i, n) {
                return k(this, t, e, i, n)
            },
            one: function(t, e, i, n) {
                return k(this, t, e, i, n, 1)
            },
            off: function(t, e, i) {
                var n, r;
                if (t && t.preventDefault && t.handleObj) return n = t.handleObj, Ct(t.delegateTarget).off(n.namespace ? n.origType + "." + n.namespace : n.origType, n.selector, n.handler), this;
                if ("object" == typeof t) {
                    for (r in t) this.off(r, e, t[r]);
                    return this
                }
                return e !== !1 && "function" != typeof e || (i = e, e = void 0), i === !1 && (i = P), this.each(function() {
                    Ct.event.remove(this, t, i, e)
                })
            }
        });
        var fe = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
            me = /<script|<style|<link/i,
            ge = /checked\s*(?:[^=]|=\s*.checked.)/i,
            ve = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
        Ct.extend({
            htmlPrefilter: function(t) {
                return t.replace(fe, "<$1></$2>")
            },
            clone: function(t, e, i) {
                var n, r, o, a, s = t.cloneNode(!0),
                    l = ee(t);
                if (!(Tt.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || Ct.isXMLDoc(t)))
                    for (a = M(s), o = M(t), n = 0, r = o.length; n < r; n++) U(o[n], a[n]);
                if (e)
                    if (i)
                        for (o = o || M(t), a = a || M(s), n = 0, r = o.length; n < r; n++) B(o[n], a[n]);
                    else B(t, s);
                return a = M(s, "script"), a.length > 0 && E(a, !l && M(t, "script")), s
            },
            cleanData: function(t) {
                for (var e, i, n, r = Ct.event.special, o = 0; void 0 !== (i = t[o]); o++)
                    if (Xt(i)) {
                        if (e = i[qt.expando]) {
                            if (e.events)
                                for (n in e.events) r[n] ? Ct.event.remove(i, n) : Ct.removeEvent(i, n, e.handle);
                            i[qt.expando] = void 0
                        }
                        i[$t.expando] && (i[$t.expando] = void 0)
                    }
            }
        }), Ct.fn.extend({
            detach: function(t) {
                return z(this, t, !0)
            },
            remove: function(t) {
                return z(this, t)
            },
            text: function(t) {
                return Gt(this, function(t) {
                    return void 0 === t ? Ct.text(this) : this.empty().each(function() {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t)
                    })
                }, null, t, arguments.length)
            },
            append: function() {
                return F(this, arguments, function(t) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var e = D(this, t);
                        e.appendChild(t)
                    }
                })
            },
            prepend: function() {
                return F(this, arguments, function(t) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var e = D(this, t);
                        e.insertBefore(t, e.firstChild)
                    }
                })
            },
            before: function() {
                return F(this, arguments, function(t) {
                    this.parentNode && this.parentNode.insertBefore(t, this)
                })
            },
            after: function() {
                return F(this, arguments, function(t) {
                    this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
                })
            },
            empty: function() {
                for (var t, e = 0; null != (t = this[e]); e++) 1 === t.nodeType && (Ct.cleanData(M(t, !1)), t.textContent = "");
                return this
            },
            clone: function(t, e) {
                return t = null != t && t, e = null == e ? t : e, this.map(function() {
                    return Ct.clone(this, t, e)
                })
            },
            html: function(t) {
                return Gt(this, function(t) {
                    var e = this[0] || {},
                        i = 0,
                        n = this.length;
                    if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
                    if ("string" == typeof t && !me.test(t) && !ce[(se.exec(t) || ["", ""])[1].toLowerCase()]) {
                        t = Ct.htmlPrefilter(t);
                        try {
                            for (; i < n; i++) e = this[i] || {}, 1 === e.nodeType && (Ct.cleanData(M(e, !1)), e.innerHTML = t);
                            e = 0
                        } catch (t) {}
                    }
                    e && this.empty().append(t)
                }, null, t, arguments.length)
            },
            replaceWith: function() {
                var t = [];
                return F(this, arguments, function(e) {
                    var i = this.parentNode;
                    Ct.inArray(this, t) < 0 && (Ct.cleanData(M(this)), i && i.replaceChild(e, this))
                }, t)
            }
        }), Ct.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function(t, e) {
            Ct.fn[t] = function(t) {
                for (var i, n = [], r = Ct(t), o = r.length - 1, a = 0; a <= o; a++) i = a === o ? this : this.clone(!0), Ct(r[a])[e](i), gt.apply(n, i.get());
                return this.pushStack(n)
            }
        });
        var ye = new RegExp("^(" + Qt + ")(?!px)[a-z%]+$", "i"),
            _e = function(t) {
                var e = t.ownerDocument.defaultView;
                return e && e.opener || (e = i), e.getComputedStyle(t)
            },
            xe = new RegExp(Kt.join("|"), "i");
        ! function() {
            function t() {
                if (c) {
                    l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", c.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", te.appendChild(l).appendChild(c);
                    var t = i.getComputedStyle(c);
                    n = "1%" !== t.top, s = 12 === e(t.marginLeft), c.style.right = "60%", a = 36 === e(t.right), r = 36 === e(t.width), c.style.position = "absolute", o = 12 === e(c.offsetWidth / 3), te.removeChild(l), c = null
                }
            }

            function e(t) {
                return Math.round(parseFloat(t))
            }
            var n, r, o, a, s, l = dt.createElement("div"),
                c = dt.createElement("div");
            c.style && (c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", Tt.clearCloneStyle = "content-box" === c.style.backgroundClip, Ct.extend(Tt, {
                boxSizingReliable: function() {
                    return t(), r
                },
                pixelBoxStyles: function() {
                    return t(), a
                },
                pixelPosition: function() {
                    return t(), n
                },
                reliableMarginLeft: function() {
                    return t(), s
                },
                scrollboxSize: function() {
                    return t(), o
                }
            }))
        }();
        var be = ["Webkit", "Moz", "ms"],
            we = dt.createElement("div").style,
            Te = {},
            Se = /^(none|table(?!-c[ea]).+)/,
            Me = /^--/,
            Ee = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            },
            Ae = {
                letterSpacing: "0",
                fontWeight: "400"
            };
        Ct.extend({
            cssHooks: {
                opacity: {
                    get: function(t, e) {
                        if (e) {
                            var i = H(t, "opacity");
                            return "" === i ? "1" : i
                        }
                    }
                }
            },
            cssNumber: {
                animationIterationCount: !0,
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                gridArea: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnStart: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowStart: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {},
            style: function(t, e, i, n) {
                if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                    var r, o, a, s = y(e),
                        l = Me.test(e),
                        c = t.style;
                    return l || (e = V(s)), a = Ct.cssHooks[e] || Ct.cssHooks[s], void 0 === i ? a && "get" in a && void 0 !== (r = a.get(t, !1, n)) ? r : c[e] : (o = typeof i, "string" === o && (r = Jt.exec(i)) && r[1] && (i = w(t, e, r), o = "number"), null != i && i === i && ("number" !== o || l || (i += r && r[3] || (Ct.cssNumber[s] ? "" : "px")), Tt.clearCloneStyle || "" !== i || 0 !== e.indexOf("background") || (c[e] = "inherit"), a && "set" in a && void 0 === (i = a.set(t, i, n)) || (l ? c.setProperty(e, i) : c[e] = i)), void 0)
                }
            },
            css: function(t, e, i, n) {
                var r, o, a, s = y(e),
                    l = Me.test(e);
                return l || (e = V(s)), a = Ct.cssHooks[e] || Ct.cssHooks[s], a && "get" in a && (r = a.get(t, !0, i)), void 0 === r && (r = H(t, e, n)), "normal" === r && e in Ae && (r = Ae[e]), "" === i || i ? (o = parseFloat(r), i === !0 || isFinite(o) ? o || 0 : r) : r
            }
        }), Ct.each(["height", "width"], function(t, e) {
            Ct.cssHooks[e] = {
                get: function(t, i, n) {
                    if (i) return !Se.test(Ct.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? q(t, e, n) : re(t, Ee, function() {
                        return q(t, e, n)
                    })
                },
                set: function(t, i, n) {
                    var r, o = _e(t),
                        a = !Tt.scrollboxSize() && "absolute" === o.position,
                        s = a || n,
                        l = s && "border-box" === Ct.css(t, "boxSizing", !1, o),
                        c = n ? X(t, e, n, l, o) : 0;
                    return l && a && (c -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(o[e]) - X(t, e, "border", !1, o) - .5)), c && (r = Jt.exec(i)) && "px" !== (r[3] || "px") && (t.style[e] = i, i = Ct.css(t, e)), W(t, i, c)
                }
            }
        }), Ct.cssHooks.marginLeft = j(Tt.reliableMarginLeft, function(t, e) {
            if (e) return (parseFloat(H(t, "marginLeft")) || t.getBoundingClientRect().left - re(t, {
                marginLeft: 0
            }, function() {
                return t.getBoundingClientRect().left
            })) + "px"
        }), Ct.each({
            margin: "",
            padding: "",
            border: "Width"
        }, function(t, e) {
            Ct.cssHooks[t + e] = {
                expand: function(i) {
                    for (var n = 0, r = {}, o = "string" == typeof i ? i.split(" ") : [i]; n < 4; n++) r[t + Kt[n] + e] = o[n] || o[n - 2] || o[0];
                    return r
                }
            }, "margin" !== t && (Ct.cssHooks[t + e].set = W)
        }), Ct.fn.extend({
            css: function(t, e) {
                return Gt(this, function(t, e, i) {
                    var n, r, o = {},
                        a = 0;
                    if (Array.isArray(e)) {
                        for (n = _e(t), r = e.length; a < r; a++) o[e[a]] = Ct.css(t, e[a], !1, n);
                        return o
                    }
                    return void 0 !== i ? Ct.style(t, e, i) : Ct.css(t, e)
                }, t, e, arguments.length > 1)
            }
        }), Ct.Tween = $, $.prototype = {
            constructor: $,
            init: function(t, e, i, n, r, o) {
                this.elem = t, this.prop = i, this.easing = r || Ct.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = n, this.unit = o || (Ct.cssNumber[i] ? "" : "px")
            },
            cur: function() {
                var t = $.propHooks[this.prop];
                return t && t.get ? t.get(this) : $.propHooks._default.get(this)
            },
            run: function(t) {
                var e, i = $.propHooks[this.prop];
                return this.options.duration ? this.pos = e = Ct.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : $.propHooks._default.set(this), this
            }
        }, $.prototype.init.prototype = $.prototype, $.propHooks = {
            _default: {
                get: function(t) {
                    var e;
                    return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = Ct.css(t.elem, t.prop, ""), e && "auto" !== e ? e : 0)
                },
                set: function(t) {
                    Ct.fx.step[t.prop] ? Ct.fx.step[t.prop](t) : 1 !== t.elem.nodeType || !Ct.cssHooks[t.prop] && null == t.elem.style[V(t.prop)] ? t.elem[t.prop] = t.now : Ct.style(t.elem, t.prop, t.now + t.unit)
                }
            }
        }, $.propHooks.scrollTop = $.propHooks.scrollLeft = {
            set: function(t) {
                t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
            }
        }, Ct.easing = {
            linear: function(t) {
                return t
            },
            swing: function(t) {
                return .5 - Math.cos(t * Math.PI) / 2
            },
            _default: "swing"
        }, Ct.fx = $.prototype.init, Ct.fx.step = {};
        var Ce, Pe, Re = /^(?:toggle|show|hide)$/,
            Le = /queueHooks$/;
        Ct.Animation = Ct.extend(et, {
                tweeners: {
                    "*": [function(t, e) {
                        var i = this.createTween(t, e);
                        return w(i.elem, t, Jt.exec(e), i), i
                    }]
                },
                tweener: function(t, e) {
                    St(t) ? (e = t, t = ["*"]) : t = t.match(zt);
                    for (var i, n = 0, r = t.length; n < r; n++) i = t[n], et.tweeners[i] = et.tweeners[i] || [], et.tweeners[i].unshift(e)
                },
                prefilters: [K],
                prefilter: function(t, e) {
                    e ? et.prefilters.unshift(t) : et.prefilters.push(t)
                }
            }), Ct.speed = function(t, e, i) {
                var n = t && "object" == typeof t ? Ct.extend({}, t) : {
                    complete: i || !i && e || St(t) && t,
                    duration: t,
                    easing: i && e || e && !St(e) && e
                };
                return Ct.fx.off ? n.duration = 0 : "number" != typeof n.duration && (n.duration in Ct.fx.speeds ? n.duration = Ct.fx.speeds[n.duration] : n.duration = Ct.fx.speeds._default), null != n.queue && n.queue !== !0 || (n.queue = "fx"), n.old = n.complete, n.complete = function() {
                    St(n.old) && n.old.call(this), n.queue && Ct.dequeue(this, n.queue)
                }, n
            }, Ct.fn.extend({
                fadeTo: function(t, e, i, n) {
                    return this.filter(ne).css("opacity", 0).show().end().animate({
                        opacity: e
                    }, t, i, n)
                },
                animate: function(t, e, i, n) {
                    var r = Ct.isEmptyObject(t),
                        o = Ct.speed(e, i, n),
                        a = function() {
                            var e = et(this, Ct.extend({}, t), o);
                            (r || qt.get(this, "finish")) && e.stop(!0)
                        };
                    return a.finish = a, r || o.queue === !1 ? this.each(a) : this.queue(o.queue, a)
                },
                stop: function(t, e, i) {
                    var n = function(t) {
                        var e = t.stop;
                        delete t.stop, e(i)
                    };
                    return "string" != typeof t && (i = e, e = t, t = void 0), e && t !== !1 && this.queue(t || "fx", []), this.each(function() {
                        var e = !0,
                            r = null != t && t + "queueHooks",
                            o = Ct.timers,
                            a = qt.get(this);
                        if (r) a[r] && a[r].stop && n(a[r]);
                        else
                            for (r in a) a[r] && a[r].stop && Le.test(r) && n(a[r]);
                        for (r = o.length; r--;) o[r].elem !== this || null != t && o[r].queue !== t || (o[r].anim.stop(i), e = !1, o.splice(r, 1));
                        !e && i || Ct.dequeue(this, t)
                    })
                },
                finish: function(t) {
                    return t !== !1 && (t = t || "fx"), this.each(function() {
                        var e, i = qt.get(this),
                            n = i[t + "queue"],
                            r = i[t + "queueHooks"],
                            o = Ct.timers,
                            a = n ? n.length : 0;
                        for (i.finish = !0, Ct.queue(this, t, []), r && r.stop && r.stop.call(this, !0), e = o.length; e--;) o[e].elem === this && o[e].queue === t && (o[e].anim.stop(!0), o.splice(e, 1));
                        for (e = 0; e < a; e++) n[e] && n[e].finish && n[e].finish.call(this);
                        delete i.finish
                    })
                }
            }), Ct.each(["toggle", "show", "hide"], function(t, e) {
                var i = Ct.fn[e];
                Ct.fn[e] = function(t, n, r) {
                    return null == t || "boolean" == typeof t ? i.apply(this, arguments) : this.animate(Q(e, !0), t, n, r)
                }
            }), Ct.each({
                slideDown: Q("show"),
                slideUp: Q("hide"),
                slideToggle: Q("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(t, e) {
                Ct.fn[t] = function(t, i, n) {
                    return this.animate(e, t, i, n)
                }
            }), Ct.timers = [], Ct.fx.tick = function() {
                var t, e = 0,
                    i = Ct.timers;
                for (Ce = Date.now(); e < i.length; e++) t = i[e], t() || i[e] !== t || i.splice(e--, 1);
                i.length || Ct.fx.stop(), Ce = void 0
            }, Ct.fx.timer = function(t) {
                Ct.timers.push(t), Ct.fx.start()
            }, Ct.fx.interval = 13, Ct.fx.start = function() {
                Pe || (Pe = !0, Y())
            }, Ct.fx.stop = function() {
                Pe = null
            }, Ct.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            }, Ct.fn.delay = function(t, e) {
                return t = Ct.fx ? Ct.fx.speeds[t] || t : t, e = e || "fx", this.queue(e, function(e, n) {
                    var r = i.setTimeout(e, t);
                    n.stop = function() {
                        i.clearTimeout(r)
                    }
                })
            },
            function() {
                var t = dt.createElement("input"),
                    e = dt.createElement("select"),
                    i = e.appendChild(dt.createElement("option"));
                t.type = "checkbox", Tt.checkOn = "" !== t.value, Tt.optSelected = i.selected, t = dt.createElement("input"), t.value = "t", t.type = "radio", Tt.radioValue = "t" === t.value
            }();
        var ke, Oe = Ct.expr.attrHandle;
        Ct.fn.extend({
            attr: function(t, e) {
                return Gt(this, Ct.attr, t, e, arguments.length > 1)
            },
            removeAttr: function(t) {
                return this.each(function() {
                    Ct.removeAttr(this, t)
                })
            }
        }), Ct.extend({
            attr: function(t, e, i) {
                var n, r, o = t.nodeType;
                if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof t.getAttribute ? Ct.prop(t, e, i) : (1 === o && Ct.isXMLDoc(t) || (r = Ct.attrHooks[e.toLowerCase()] || (Ct.expr.match.bool.test(e) ? ke : void 0)), void 0 !== i ? null === i ? void Ct.removeAttr(t, e) : r && "set" in r && void 0 !== (n = r.set(t, i, e)) ? n : (t.setAttribute(e, i + ""), i) : r && "get" in r && null !== (n = r.get(t, e)) ? n : (n = Ct.find.attr(t, e), null == n ? void 0 : n))
            },
            attrHooks: {
                type: {
                    set: function(t, e) {
                        if (!Tt.radioValue && "radio" === e && c(t, "input")) {
                            var i = t.value;
                            return t.setAttribute("type", e), i && (t.value = i), e
                        }
                    }
                }
            },
            removeAttr: function(t, e) {
                var i, n = 0,
                    r = e && e.match(zt);
                if (r && 1 === t.nodeType)
                    for (; i = r[n++];) t.removeAttribute(i)
            }
        }), ke = {
            set: function(t, e, i) {
                return e === !1 ? Ct.removeAttr(t, i) : t.setAttribute(i, i), i
            }
        }, Ct.each(Ct.expr.match.bool.source.match(/\w+/g), function(t, e) {
            var i = Oe[e] || Ct.find.attr;
            Oe[e] = function(t, e, n) {
                var r, o, a = e.toLowerCase();
                return n || (o = Oe[a], Oe[a] = r, r = null != i(t, e, n) ? a : null, Oe[a] = o), r
            }
        });
        var De = /^(?:input|select|textarea|button)$/i,
            Ie = /^(?:a|area)$/i;
        Ct.fn.extend({
            prop: function(t, e) {
                return Gt(this, Ct.prop, t, e, arguments.length > 1)
            },
            removeProp: function(t) {
                return this.each(function() {
                    delete this[Ct.propFix[t] || t]
                })
            }
        }), Ct.extend({
            prop: function(t, e, i) {
                var n, r, o = t.nodeType;
                if (3 !== o && 8 !== o && 2 !== o) return 1 === o && Ct.isXMLDoc(t) || (e = Ct.propFix[e] || e, r = Ct.propHooks[e]), void 0 !== i ? r && "set" in r && void 0 !== (n = r.set(t, i, e)) ? n : t[e] = i : r && "get" in r && null !== (n = r.get(t, e)) ? n : t[e]
            },
            propHooks: {
                tabIndex: {
                    get: function(t) {
                        var e = Ct.find.attr(t, "tabindex");
                        return e ? parseInt(e, 10) : De.test(t.nodeName) || Ie.test(t.nodeName) && t.href ? 0 : -1
                    }
                }
            },
            propFix: {
                for: "htmlFor",
                class: "className"
            }
        }), Tt.optSelected || (Ct.propHooks.selected = {
            get: function(t) {
                var e = t.parentNode;
                return e && e.parentNode && e.parentNode.selectedIndex, null
            },
            set: function(t) {
                var e = t.parentNode;
                e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
            }
        }), Ct.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
            Ct.propFix[this.toLowerCase()] = this
        }), Ct.fn.extend({
            addClass: function(t) {
                var e, i, n, r, o, a, s, l = 0;
                if (St(t)) return this.each(function(e) {
                    Ct(this).addClass(t.call(this, e, nt(this)))
                });
                if (e = rt(t), e.length)
                    for (; i = this[l++];)
                        if (r = nt(i), n = 1 === i.nodeType && " " + it(r) + " ") {
                            for (a = 0; o = e[a++];) n.indexOf(" " + o + " ") < 0 && (n += o + " ");
                            s = it(n), r !== s && i.setAttribute("class", s)
                        }
                return this
            },
            removeClass: function(t) {
                var e, i, n, r, o, a, s, l = 0;
                if (St(t)) return this.each(function(e) {
                    Ct(this).removeClass(t.call(this, e, nt(this)))
                });
                if (!arguments.length) return this.attr("class", "");
                if (e = rt(t), e.length)
                    for (; i = this[l++];)
                        if (r = nt(i), n = 1 === i.nodeType && " " + it(r) + " ") {
                            for (a = 0; o = e[a++];)
                                for (; n.indexOf(" " + o + " ") > -1;) n = n.replace(" " + o + " ", " ");
                            s = it(n), r !== s && i.setAttribute("class", s)
                        }
                return this
            },
            toggleClass: function(t, e) {
                var i = typeof t,
                    n = "string" === i || Array.isArray(t);
                return "boolean" == typeof e && n ? e ? this.addClass(t) : this.removeClass(t) : St(t) ? this.each(function(i) {
                    Ct(this).toggleClass(t.call(this, i, nt(this), e), e)
                }) : this.each(function() {
                    var e, r, o, a;
                    if (n)
                        for (r = 0, o = Ct(this), a = rt(t); e = a[r++];) o.hasClass(e) ? o.removeClass(e) : o.addClass(e);
                    else void 0 !== t && "boolean" !== i || (e = nt(this), e && qt.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || t === !1 ? "" : qt.get(this, "__className__") || ""))
                })
            },
            hasClass: function(t) {
                var e, i, n = 0;
                for (e = " " + t + " "; i = this[n++];)
                    if (1 === i.nodeType && (" " + it(nt(i)) + " ").indexOf(e) > -1) return !0;
                return !1
            }
        });
        var Ne = /\r/g;
        Ct.fn.extend({
            val: function(t) {
                var e, i, n, r = this[0]; {
                    if (arguments.length) return n = St(t), this.each(function(i) {
                        var r;
                        1 === this.nodeType && (r = n ? t.call(this, i, Ct(this).val()) : t, null == r ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = Ct.map(r, function(t) {
                            return null == t ? "" : t + ""
                        })), e = Ct.valHooks[this.type] || Ct.valHooks[this.nodeName.toLowerCase()], e && "set" in e && void 0 !== e.set(this, r, "value") || (this.value = r))
                    });
                    if (r) return e = Ct.valHooks[r.type] || Ct.valHooks[r.nodeName.toLowerCase()], e && "get" in e && void 0 !== (i = e.get(r, "value")) ? i : (i = r.value, "string" == typeof i ? i.replace(Ne, "") : null == i ? "" : i)
                }
            }
        }), Ct.extend({
            valHooks: {
                option: {
                    get: function(t) {
                        var e = Ct.find.attr(t, "value");
                        return null != e ? e : it(Ct.text(t))
                    }
                },
                select: {
                    get: function(t) {
                        var e, i, n, r = t.options,
                            o = t.selectedIndex,
                            a = "select-one" === t.type,
                            s = a ? null : [],
                            l = a ? o + 1 : r.length;
                        for (n = o < 0 ? l : a ? o : 0; n < l; n++)
                            if (i = r[n], (i.selected || n === o) && !i.disabled && (!i.parentNode.disabled || !c(i.parentNode, "optgroup"))) {
                                if (e = Ct(i).val(), a) return e;
                                s.push(e)
                            }
                        return s
                    },
                    set: function(t, e) {
                        for (var i, n, r = t.options, o = Ct.makeArray(e), a = r.length; a--;) n = r[a], (n.selected = Ct.inArray(Ct.valHooks.option.get(n), o) > -1) && (i = !0);
                        return i || (t.selectedIndex = -1), o
                    }
                }
            }
        }), Ct.each(["radio", "checkbox"], function() {
            Ct.valHooks[this] = {
                set: function(t, e) {
                    if (Array.isArray(e)) return t.checked = Ct.inArray(Ct(t).val(), e) > -1
                }
            }, Tt.checkOn || (Ct.valHooks[this].get = function(t) {
                return null === t.getAttribute("value") ? "on" : t.value
            })
        }), Tt.focusin = "onfocusin" in i;
        var Be = /^(?:focusinfocus|focusoutblur)$/,
            Ue = function(t) {
                t.stopPropagation()
            };
        Ct.extend(Ct.event, {
            trigger: function(t, e, n, r) {
                var o, a, s, l, c, h, u, d, p = [n || dt],
                    f = xt.call(t, "type") ? t.type : t,
                    m = xt.call(t, "namespace") ? t.namespace.split(".") : [];
                if (a = d = s = n = n || dt, 3 !== n.nodeType && 8 !== n.nodeType && !Be.test(f + Ct.event.triggered) && (f.indexOf(".") > -1 && (m = f.split("."), f = m.shift(), m.sort()), c = f.indexOf(":") < 0 && "on" + f, t = t[Ct.expando] ? t : new Ct.Event(f, "object" == typeof t && t), t.isTrigger = r ? 2 : 3, t.namespace = m.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = n), e = null == e ? [t] : Ct.makeArray(e, [t]), u = Ct.event.special[f] || {}, r || !u.trigger || u.trigger.apply(n, e) !== !1)) {
                    if (!r && !u.noBubble && !Mt(n)) {
                        for (l = u.delegateType || f, Be.test(l + f) || (a = a.parentNode); a; a = a.parentNode) p.push(a), s = a;
                        s === (n.ownerDocument || dt) && p.push(s.defaultView || s.parentWindow || i)
                    }
                    for (o = 0;
                        (a = p[o++]) && !t.isPropagationStopped();) d = a, t.type = o > 1 ? l : u.bindType || f, h = (qt.get(a, "events") || {})[t.type] && qt.get(a, "handle"), h && h.apply(a, e), h = c && a[c], h && h.apply && Xt(a) && (t.result = h.apply(a, e), t.result === !1 && t.preventDefault());
                    return t.type = f, r || t.isDefaultPrevented() || u._default && u._default.apply(p.pop(), e) !== !1 || !Xt(n) || c && St(n[f]) && !Mt(n) && (s = n[c], s && (n[c] = null), Ct.event.triggered = f, t.isPropagationStopped() && d.addEventListener(f, Ue), n[f](), t.isPropagationStopped() && d.removeEventListener(f, Ue), Ct.event.triggered = void 0, s && (n[c] = s)), t.result
                }
            },
            simulate: function(t, e, i) {
                var n = Ct.extend(new Ct.Event, i, {
                    type: t,
                    isSimulated: !0
                });
                Ct.event.trigger(n, null, e)
            }
        }), Ct.fn.extend({
            trigger: function(t, e) {
                return this.each(function() {
                    Ct.event.trigger(t, e, this)
                })
            },
            triggerHandler: function(t, e) {
                var i = this[0];
                if (i) return Ct.event.trigger(t, e, i, !0)
            }
        }), Tt.focusin || Ct.each({
            focus: "focusin",
            blur: "focusout"
        }, function(t, e) {
            var i = function(t) {
                Ct.event.simulate(e, t.target, Ct.event.fix(t))
            };
            Ct.event.special[e] = {
                setup: function() {
                    var n = this.ownerDocument || this,
                        r = qt.access(n, e);
                    r || n.addEventListener(t, i, !0), qt.access(n, e, (r || 0) + 1)
                },
                teardown: function() {
                    var n = this.ownerDocument || this,
                        r = qt.access(n, e) - 1;
                    r ? qt.access(n, e, r) : (n.removeEventListener(t, i, !0), qt.remove(n, e))
                }
            }
        });
        var Fe = i.location,
            ze = Date.now(),
            He = /\?/;
        Ct.parseXML = function(t) {
            var e;
            if (!t || "string" != typeof t) return null;
            try {
                e = (new i.DOMParser).parseFromString(t, "text/xml")
            } catch (t) {
                e = void 0
            }
            return e && !e.getElementsByTagName("parsererror").length || Ct.error("Invalid XML: " + t), e
        };
        var je = /\[\]$/,
            Ge = /\r?\n/g,
            Ve = /^(?:submit|button|image|reset|file)$/i,
            We = /^(?:input|select|textarea|keygen)/i;
        Ct.param = function(t, e) {
            var i, n = [],
                r = function(t, e) {
                    var i = St(e) ? e() : e;
                    n[n.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == i ? "" : i)
                };
            if (null == t) return "";
            if (Array.isArray(t) || t.jquery && !Ct.isPlainObject(t)) Ct.each(t, function() {
                r(this.name, this.value)
            });
            else
                for (i in t) ot(i, t[i], e, r);
            return n.join("&")
        }, Ct.fn.extend({
            serialize: function() {
                return Ct.param(this.serializeArray())
            },
            serializeArray: function() {
                return this.map(function() {
                    var t = Ct.prop(this, "elements");
                    return t ? Ct.makeArray(t) : this
                }).filter(function() {
                    var t = this.type;
                    return this.name && !Ct(this).is(":disabled") && We.test(this.nodeName) && !Ve.test(t) && (this.checked || !ae.test(t))
                }).map(function(t, e) {
                    var i = Ct(this).val();
                    return null == i ? null : Array.isArray(i) ? Ct.map(i, function(t) {
                        return {
                            name: e.name,
                            value: t.replace(Ge, "\r\n")
                        }
                    }) : {
                        name: e.name,
                        value: i.replace(Ge, "\r\n")
                    }
                }).get()
            }
        });
        var Xe = /%20/g,
            qe = /#.*$/,
            $e = /([?&])_=[^&]*/,
            Ye = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            Ze = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
            Qe = /^(?:GET|HEAD)$/,
            Je = /^\/\//,
            Ke = {},
            ti = {},
            ei = "*/".concat("*"),
            ii = dt.createElement("a");
        ii.href = Fe.href, Ct.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: Fe.href,
                type: "GET",
                isLocal: Ze.test(Fe.protocol),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": ei,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {
                    xml: /\bxml\b/,
                    html: /\bhtml/,
                    json: /\bjson\b/
                },
                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },
                converters: {
                    "* text": String,
                    "text html": !0,
                    "text json": JSON.parse,
                    "text xml": Ct.parseXML
                },
                flatOptions: {
                    url: !0,
                    context: !0
                }
            },
            ajaxSetup: function(t, e) {
                return e ? lt(lt(t, Ct.ajaxSettings), e) : lt(Ct.ajaxSettings, t)
            },
            ajaxPrefilter: at(Ke),
            ajaxTransport: at(ti),
            ajax: function(t, e) {
                function n(t, e, n, s) {
                    var c, d, p, x, b, w = e;
                    h || (h = !0, l && i.clearTimeout(l), r = void 0, a = s || "", T.readyState = t > 0 ? 4 : 0, c = t >= 200 && t < 300 || 304 === t, n && (x = ct(f, T, n)), x = ht(f, x, T, c), c ? (f.ifModified && (b = T.getResponseHeader("Last-Modified"), b && (Ct.lastModified[o] = b), b = T.getResponseHeader("etag"), b && (Ct.etag[o] = b)), 204 === t || "HEAD" === f.type ? w = "nocontent" : 304 === t ? w = "notmodified" : (w = x.state, d = x.data, p = x.error, c = !p)) : (p = w, !t && w || (w = "error", t < 0 && (t = 0))), T.status = t, T.statusText = (e || w) + "", c ? v.resolveWith(m, [d, w, T]) : v.rejectWith(m, [T, w, p]), T.statusCode(_), _ = void 0, u && g.trigger(c ? "ajaxSuccess" : "ajaxError", [T, f, c ? d : p]), y.fireWith(m, [T, w]), u && (g.trigger("ajaxComplete", [T, f]), --Ct.active || Ct.event.trigger("ajaxStop")))
                }
                "object" == typeof t && (e = t, t = void 0), e = e || {};
                var r, o, a, s, l, c, h, u, d, p, f = Ct.ajaxSetup({}, e),
                    m = f.context || f,
                    g = f.context && (m.nodeType || m.jquery) ? Ct(m) : Ct.event,
                    v = Ct.Deferred(),
                    y = Ct.Callbacks("once memory"),
                    _ = f.statusCode || {},
                    x = {},
                    b = {},
                    w = "canceled",
                    T = {
                        readyState: 0,
                        getResponseHeader: function(t) {
                            var e;
                            if (h) {
                                if (!s)
                                    for (s = {}; e = Ye.exec(a);) s[e[1].toLowerCase() + " "] = (s[e[1].toLowerCase() + " "] || []).concat(e[2]);
                                e = s[t.toLowerCase() + " "]
                            }
                            return null == e ? null : e.join(", ")
                        },
                        getAllResponseHeaders: function() {
                            return h ? a : null
                        },
                        setRequestHeader: function(t, e) {
                            return null == h && (t = b[t.toLowerCase()] = b[t.toLowerCase()] || t, x[t] = e), this
                        },
                        overrideMimeType: function(t) {
                            return null == h && (f.mimeType = t), this
                        },
                        statusCode: function(t) {
                            var e;
                            if (t)
                                if (h) T.always(t[T.status]);
                                else
                                    for (e in t) _[e] = [_[e], t[e]];
                            return this
                        },
                        abort: function(t) {
                            var e = t || w;
                            return r && r.abort(e), n(0, e), this
                        }
                    };
                if (v.promise(T), f.url = ((t || f.url || Fe.href) + "").replace(Je, Fe.protocol + "//"), f.type = e.method || e.type || f.method || f.type, f.dataTypes = (f.dataType || "*").toLowerCase().match(zt) || [""], null == f.crossDomain) {
                    c = dt.createElement("a");
                    try {
                        c.href = f.url, c.href = c.href, f.crossDomain = ii.protocol + "//" + ii.host != c.protocol + "//" + c.host
                    } catch (t) {
                        f.crossDomain = !0
                    }
                }
                if (f.data && f.processData && "string" != typeof f.data && (f.data = Ct.param(f.data, f.traditional)), st(Ke, f, e, T), h) return T;
                u = Ct.event && f.global, u && 0 === Ct.active++ && Ct.event.trigger("ajaxStart"), f.type = f.type.toUpperCase(), f.hasContent = !Qe.test(f.type), o = f.url.replace(qe, ""), f.hasContent ? f.data && f.processData && 0 === (f.contentType || "").indexOf("application/x-www-form-urlencoded") && (f.data = f.data.replace(Xe, "+")) : (p = f.url.slice(o.length), f.data && (f.processData || "string" == typeof f.data) && (o += (He.test(o) ? "&" : "?") + f.data, delete f.data), f.cache === !1 && (o = o.replace($e, "$1"), p = (He.test(o) ? "&" : "?") + "_=" + ze++ + p), f.url = o + p), f.ifModified && (Ct.lastModified[o] && T.setRequestHeader("If-Modified-Since", Ct.lastModified[o]), Ct.etag[o] && T.setRequestHeader("If-None-Match", Ct.etag[o])), (f.data && f.hasContent && f.contentType !== !1 || e.contentType) && T.setRequestHeader("Content-Type", f.contentType), T.setRequestHeader("Accept", f.dataTypes[0] && f.accepts[f.dataTypes[0]] ? f.accepts[f.dataTypes[0]] + ("*" !== f.dataTypes[0] ? ", " + ei + "; q=0.01" : "") : f.accepts["*"]);
                for (d in f.headers) T.setRequestHeader(d, f.headers[d]);
                if (f.beforeSend && (f.beforeSend.call(m, T, f) === !1 || h)) return T.abort();
                if (w = "abort", y.add(f.complete), T.done(f.success), T.fail(f.error), r = st(ti, f, e, T)) {
                    if (T.readyState = 1, u && g.trigger("ajaxSend", [T, f]), h) return T;
                    f.async && f.timeout > 0 && (l = i.setTimeout(function() {
                        T.abort("timeout")
                    }, f.timeout));
                    try {
                        h = !1, r.send(x, n)
                    } catch (t) {
                        if (h) throw t;
                        n(-1, t)
                    }
                } else n(-1, "No Transport");
                return T
            },
            getJSON: function(t, e, i) {
                return Ct.get(t, e, i, "json")
            },
            getScript: function(t, e) {
                return Ct.get(t, void 0, e, "script")
            }
        }), Ct.each(["get", "post"], function(t, e) {
            Ct[e] = function(t, i, n, r) {
                return St(i) && (r = r || n, n = i, i = void 0), Ct.ajax(Ct.extend({
                    url: t,
                    type: e,
                    dataType: r,
                    data: i,
                    success: n
                }, Ct.isPlainObject(t) && t))
            }
        }), Ct._evalUrl = function(t, e) {
            return Ct.ajax({
                url: t,
                type: "GET",
                dataType: "script",
                cache: !0,
                async: !1,
                global: !1,
                converters: {
                    "text script": function() {}
                },
                dataFilter: function(t) {
                    Ct.globalEval(t, e)
                }
            })
        }, Ct.fn.extend({
            wrapAll: function(t) {
                var e;
                return this[0] && (St(t) && (t = t.call(this[0])), e = Ct(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map(function() {
                    for (var t = this; t.firstElementChild;) t = t.firstElementChild;
                    return t
                }).append(this)), this
            },
            wrapInner: function(t) {
                return St(t) ? this.each(function(e) {
                    Ct(this).wrapInner(t.call(this, e))
                }) : this.each(function() {
                    var e = Ct(this),
                        i = e.contents();
                    i.length ? i.wrapAll(t) : e.append(t)
                })
            },
            wrap: function(t) {
                var e = St(t);
                return this.each(function(i) {
                    Ct(this).wrapAll(e ? t.call(this, i) : t)
                })
            },
            unwrap: function(t) {
                return this.parent(t).not("body").each(function() {
                    Ct(this).replaceWith(this.childNodes)
                }), this
            }
        }), Ct.expr.pseudos.hidden = function(t) {
            return !Ct.expr.pseudos.visible(t)
        }, Ct.expr.pseudos.visible = function(t) {
            return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
        }, Ct.ajaxSettings.xhr = function() {
            try {
                return new i.XMLHttpRequest
            } catch (t) {}
        };
        var ni = {
                0: 200,
                1223: 204
            },
            ri = Ct.ajaxSettings.xhr();
        Tt.cors = !!ri && "withCredentials" in ri, Tt.ajax = ri = !!ri, Ct.ajaxTransport(function(t) {
            var e, n;
            if (Tt.cors || ri && !t.crossDomain) return {
                send: function(r, o) {
                    var a, s = t.xhr();
                    if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields)
                        for (a in t.xhrFields) s[a] = t.xhrFields[a];
                    t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest");
                    for (a in r) s.setRequestHeader(a, r[a]);
                    e = function(t) {
                        return function() {
                            e && (e = n = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === t ? s.abort() : "error" === t ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(ni[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {
                                binary: s.response
                            } : {
                                text: s.responseText
                            }, s.getAllResponseHeaders()))
                        }
                    }, s.onload = e(), n = s.onerror = s.ontimeout = e("error"), void 0 !== s.onabort ? s.onabort = n : s.onreadystatechange = function() {
                        4 === s.readyState && i.setTimeout(function() {
                            e && n()
                        })
                    }, e = e("abort");
                    try {
                        s.send(t.hasContent && t.data || null)
                    } catch (t) {
                        if (e) throw t
                    }
                },
                abort: function() {
                    e && e()
                }
            }
        }), Ct.ajaxPrefilter(function(t) {
            t.crossDomain && (t.contents.script = !1)
        }), Ct.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /\b(?:java|ecma)script\b/
            },
            converters: {
                "text script": function(t) {
                    return Ct.globalEval(t), t
                }
            }
        }), Ct.ajaxPrefilter("script", function(t) {
            void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET")
        }), Ct.ajaxTransport("script", function(t) {
            if (t.crossDomain || t.scriptAttrs) {
                var e, i;
                return {
                    send: function(n, r) {
                        e = Ct("<script>").attr(t.scriptAttrs || {}).prop({
                            charset: t.scriptCharset,
                            src: t.url
                        }).on("load error", i = function(t) {
                            e.remove(), i = null, t && r("error" === t.type ? 404 : 200, t.type)
                        }), dt.head.appendChild(e[0])
                    },
                    abort: function() {
                        i && i()
                    }
                }
            }
        });
        var oi = [],
            ai = /(=)\?(?=&|$)|\?\?/;
        Ct.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
                var t = oi.pop() || Ct.expando + "_" + ze++;
                return this[t] = !0, t
            }
        }), Ct.ajaxPrefilter("json jsonp", function(t, e, n) {
            var r, o, a, s = t.jsonp !== !1 && (ai.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && ai.test(t.data) && "data");
            if (s || "jsonp" === t.dataTypes[0]) return r = t.jsonpCallback = St(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(ai, "$1" + r) : t.jsonp !== !1 && (t.url += (He.test(t.url) ? "&" : "?") + t.jsonp + "=" + r), t.converters["script json"] = function() {
                return a || Ct.error(r + " was not called"), a[0]
            }, t.dataTypes[0] = "json", o = i[r], i[r] = function() {
                a = arguments
            }, n.always(function() {
                void 0 === o ? Ct(i).removeProp(r) : i[r] = o, t[r] && (t.jsonpCallback = e.jsonpCallback, oi.push(r)), a && St(o) && o(a[0]), a = o = void 0
            }), "script"
        }), Tt.createHTMLDocument = function() {
            var t = dt.implementation.createHTMLDocument("").body;
            return t.innerHTML = "<form></form><form></form>", 2 === t.childNodes.length
        }(), Ct.parseHTML = function(t, e, i) {
            if ("string" != typeof t) return [];
            "boolean" == typeof e && (i = e, e = !1);
            var n, r, o;
            return e || (Tt.createHTMLDocument ? (e = dt.implementation.createHTMLDocument(""), n = e.createElement("base"), n.href = dt.location.href, e.head.appendChild(n)) : e = dt), r = Dt.exec(t), o = !i && [], r ? [e.createElement(r[1])] : (r = A([t], e, o), o && o.length && Ct(o).remove(), Ct.merge([], r.childNodes))
        }, Ct.fn.load = function(t, e, i) {
            var n, r, o, a = this,
                s = t.indexOf(" ");
            return s > -1 && (n = it(t.slice(s)), t = t.slice(0, s)), St(e) ? (i = e, e = void 0) : e && "object" == typeof e && (r = "POST"), a.length > 0 && Ct.ajax({
                url: t,
                type: r || "GET",
                dataType: "html",
                data: e
            }).done(function(t) {
                o = arguments, a.html(n ? Ct("<div>").append(Ct.parseHTML(t)).find(n) : t)
            }).always(i && function(t, e) {
                a.each(function() {
                    i.apply(this, o || [t.responseText, e, t])
                })
            }), this
        }, Ct.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(t, e) {
            Ct.fn[e] = function(t) {
                return this.on(e, t)
            }
        }), Ct.expr.pseudos.animated = function(t) {
            return Ct.grep(Ct.timers, function(e) {
                return t === e.elem
            }).length
        }, Ct.offset = {
            setOffset: function(t, e, i) {
                var n, r, o, a, s, l, c, h = Ct.css(t, "position"),
                    u = Ct(t),
                    d = {};
                "static" === h && (t.style.position = "relative"), s = u.offset(), o = Ct.css(t, "top"), l = Ct.css(t, "left"), c = ("absolute" === h || "fixed" === h) && (o + l).indexOf("auto") > -1, c ? (n = u.position(), a = n.top, r = n.left) : (a = parseFloat(o) || 0, r = parseFloat(l) || 0), St(e) && (e = e.call(t, i, Ct.extend({}, s))), null != e.top && (d.top = e.top - s.top + a), null != e.left && (d.left = e.left - s.left + r), "using" in e ? e.using.call(t, d) : u.css(d)
            }
        }, Ct.fn.extend({
            offset: function(t) {
                if (arguments.length) return void 0 === t ? this : this.each(function(e) {
                    Ct.offset.setOffset(this, t, e)
                });
                var e, i, n = this[0];
                if (n) return n.getClientRects().length ? (e = n.getBoundingClientRect(), i = n.ownerDocument.defaultView, {
                    top: e.top + i.pageYOffset,
                    left: e.left + i.pageXOffset
                }) : {
                    top: 0,
                    left: 0
                }
            },
            position: function() {
                if (this[0]) {
                    var t, e, i, n = this[0],
                        r = {
                            top: 0,
                            left: 0
                        };
                    if ("fixed" === Ct.css(n, "position")) e = n.getBoundingClientRect();
                    else {
                        for (e = this.offset(), i = n.ownerDocument, t = n.offsetParent || i.documentElement; t && (t === i.body || t === i.documentElement) && "static" === Ct.css(t, "position");) t = t.parentNode;
                        t && t !== n && 1 === t.nodeType && (r = Ct(t).offset(), r.top += Ct.css(t, "borderTopWidth", !0), r.left += Ct.css(t, "borderLeftWidth", !0))
                    }
                    return {
                        top: e.top - r.top - Ct.css(n, "marginTop", !0),
                        left: e.left - r.left - Ct.css(n, "marginLeft", !0)
                    }
                }
            },
            offsetParent: function() {
                return this.map(function() {
                    for (var t = this.offsetParent; t && "static" === Ct.css(t, "position");) t = t.offsetParent;
                    return t || te
                })
            }
        }), Ct.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
        }, function(t, e) {
            var i = "pageYOffset" === e;
            Ct.fn[t] = function(n) {
                return Gt(this, function(t, n, r) {
                    var o;
                    return Mt(t) ? o = t : 9 === t.nodeType && (o = t.defaultView), void 0 === r ? o ? o[e] : t[n] : void(o ? o.scrollTo(i ? o.pageXOffset : r, i ? r : o.pageYOffset) : t[n] = r)
                }, t, n, arguments.length)
            }
        }), Ct.each(["top", "left"], function(t, e) {
            Ct.cssHooks[e] = j(Tt.pixelPosition, function(t, i) {
                if (i) return i = H(t, e), ye.test(i) ? Ct(t).position()[e] + "px" : i
            })
        }), Ct.each({
            Height: "height",
            Width: "width"
        }, function(t, e) {
            Ct.each({
                padding: "inner" + t,
                content: e,
                "": "outer" + t
            }, function(i, n) {
                Ct.fn[n] = function(r, o) {
                    var a = arguments.length && (i || "boolean" != typeof r),
                        s = i || (r === !0 || o === !0 ? "margin" : "border");
                    return Gt(this, function(e, i, r) {
                        var o;
                        return Mt(e) ? 0 === n.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (o = e.documentElement, Math.max(e.body["scroll" + t], o["scroll" + t], e.body["offset" + t], o["offset" + t], o["client" + t])) : void 0 === r ? Ct.css(e, i, s) : Ct.style(e, i, r, s)
                    }, e, a ? r : void 0, a)
                }
            })
        }), Ct.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(t, e) {
            Ct.fn[e] = function(t, i) {
                return arguments.length > 0 ? this.on(e, null, t, i) : this.trigger(e)
            }
        }), Ct.fn.extend({
            hover: function(t, e) {
                return this.mouseenter(t).mouseleave(e || t)
            }
        }), Ct.fn.extend({
            bind: function(t, e, i) {
                return this.on(t, null, e, i)
            },
            unbind: function(t, e) {
                return this.off(t, null, e)
            },
            delegate: function(t, e, i, n) {
                return this.on(e, t, i, n)
            },
            undelegate: function(t, e, i) {
                return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", i)
            }
        }), Ct.proxy = function(t, e) {
            var i, n, r;
            if ("string" == typeof e && (i = t[e], e = t, t = i), St(t)) return n = ft.call(arguments, 2), r = function() {
                return t.apply(e || this, n.concat(ft.call(arguments)))
            }, r.guid = t.guid = t.guid || Ct.guid++, r
        }, Ct.holdReady = function(t) {
            t ? Ct.readyWait++ : Ct.ready(!0)
        }, Ct.isArray = Array.isArray, Ct.parseJSON = JSON.parse, Ct.nodeName = c, Ct.isFunction = St, Ct.isWindow = Mt, Ct.camelCase = y, Ct.type = s, Ct.now = Date.now, Ct.isNumeric = function(t) {
            var e = Ct.type(t);
            return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
        }, n = [], r = function() {
            return Ct
        }.apply(e, n), !(void 0 !== r && (t.exports = r));
        var si = i.jQuery,
            li = i.$;
        return Ct.noConflict = function(t) {
            return i.$ === Ct && (i.$ = li), t && i.jQuery === Ct && (i.jQuery = si), Ct
        }, o || (i.jQuery = i.$ = Ct), Ct
    })
}, function(t, e, i) {
    ! function(e, i) {
        t.exports = i()
    }(this, function() {
        return function(t) {
            function e(n) {
                if (i[n]) return i[n].exports;
                var r = i[n] = {
                    exports: {},
                    id: n,
                    loaded: !1
                };
                return t[n].call(r.exports, r, r.exports, e), r.loaded = !0, r.exports
            }
            var i = {};
            return e.m = t, e.c = i, e.p = "", e(0)
        }([function(t, e, i) {
            "use strict";

            function n(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            var r = i(2),
                o = n(r);
            t.exports = o.default
        }, function(t, e) {
            function i(t) {
                var e = typeof t;
                return null != t && ("object" == e || "function" == e)
            }
            t.exports = i
        }, function(t, e, i) {
            "use strict";

            function n(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var r = i(9),
                o = n(r),
                a = i(3),
                s = n(a),
                l = i(4),
                c = function() {
                    if ("undefined" != typeof window) {
                        var t = 100,
                            e = ["scroll", "resize", "load"],
                            i = {
                                history: []
                            },
                            n = {
                                offset: {},
                                threshold: 0,
                                test: l.inViewport
                            },
                            r = (0, o.default)(function() {
                                i.history.forEach(function(t) {
                                    i[t].check()
                                })
                            }, t);
                        e.forEach(function(t) {
                            return addEventListener(t, r)
                        }), window.MutationObserver && addEventListener("DOMContentLoaded", function() {
                            new MutationObserver(r).observe(document.body, {
                                attributes: !0,
                                childList: !0,
                                subtree: !0
                            })
                        });
                        var a = function(t) {
                            if ("string" == typeof t) {
                                var e = [].slice.call(document.querySelectorAll(t));
                                return i.history.indexOf(t) > -1 ? i[t].elements = e : (i[t] = (0, s.default)(e, n), i.history.push(t)), i[t]
                            }
                        };
                        return a.offset = function(t) {
                            if (void 0 === t) return n.offset;
                            var e = function(t) {
                                return "number" == typeof t
                            };
                            return ["top", "right", "bottom", "left"].forEach(e(t) ? function(e) {
                                return n.offset[e] = t
                            } : function(i) {
                                return e(t[i]) ? n.offset[i] = t[i] : null
                            }), n.offset
                        }, a.threshold = function(t) {
                            return "number" == typeof t && t >= 0 && t <= 1 ? n.threshold = t : n.threshold
                        }, a.test = function(t) {
                            return "function" == typeof t ? n.test = t : n.test
                        }, a.is = function(t) {
                            return n.test(t, n)
                        }, a.offset(0), a
                    }
                };
            e.default = c()
        }, function(t, e) {
            "use strict";

            function i(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var n = function() {
                    function t(t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, i, n) {
                        return i && t(e.prototype, i), n && t(e, n), e
                    }
                }(),
                r = function() {
                    function t(e, n) {
                        i(this, t), this.options = n, this.elements = e, this.current = [], this.handlers = {
                            enter: [],
                            exit: []
                        }, this.singles = {
                            enter: [],
                            exit: []
                        }
                    }
                    return n(t, [{
                        key: "check",
                        value: function() {
                            var t = this;
                            return this.elements.forEach(function(e) {
                                var i = t.options.test(e, t.options),
                                    n = t.current.indexOf(e),
                                    r = n > -1,
                                    o = i && !r,
                                    a = !i && r;
                                o && (t.current.push(e), t.emit("enter", e)), a && (t.current.splice(n, 1), t.emit("exit", e))
                            }), this
                        }
                    }, {
                        key: "on",
                        value: function(t, e) {
                            return this.handlers[t].push(e), this
                        }
                    }, {
                        key: "once",
                        value: function(t, e) {
                            return this.singles[t].unshift(e), this
                        }
                    }, {
                        key: "emit",
                        value: function(t, e) {
                            for (; this.singles[t].length;) this.singles[t].pop()(e);
                            for (var i = this.handlers[t].length; --i > -1;) this.handlers[t][i](e);
                            return this
                        }
                    }]), t
                }();
            e.default = function(t, e) {
                return new r(t, e)
            }
        }, function(t, e) {
            "use strict";

            function i(t, e) {
                var i = t.getBoundingClientRect(),
                    n = i.top,
                    r = i.right,
                    o = i.bottom,
                    a = i.left,
                    s = i.width,
                    l = i.height,
                    c = {
                        t: o,
                        r: window.innerWidth - a,
                        b: window.innerHeight - n,
                        l: r
                    },
                    h = {
                        x: e.threshold * s,
                        y: e.threshold * l
                    };
                return c.t > e.offset.top + h.y && c.r > e.offset.right + h.x && c.b > e.offset.bottom + h.y && c.l > e.offset.left + h.x
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.inViewport = i
        }, function(t, e) {
            (function(e) {
                var i = "object" == typeof e && e && e.Object === Object && e;
                t.exports = i
            }).call(e, function() {
                return this
            }())
        }, function(t, e, i) {
            var n = i(5),
                r = "object" == typeof self && self && self.Object === Object && self,
                o = n || r || Function("return this")();
            t.exports = o
        }, function(t, e, i) {
            function n(t, e, i) {
                function n(e) {
                    var i = y,
                        n = _;
                    return y = _ = void 0, S = e, b = t.apply(n, i)
                }

                function h(t) {
                    return S = t, w = setTimeout(p, e), M ? n(t) : b
                }

                function u(t) {
                    var i = t - T,
                        n = t - S,
                        r = e - i;
                    return E ? c(r, x - n) : r
                }

                function d(t) {
                    var i = t - T,
                        n = t - S;
                    return void 0 === T || i >= e || i < 0 || E && n >= x
                }

                function p() {
                    var t = o();
                    return d(t) ? f(t) : void(w = setTimeout(p, u(t)))
                }

                function f(t) {
                    return w = void 0, A && y ? n(t) : (y = _ = void 0, b)
                }

                function m() {
                    void 0 !== w && clearTimeout(w), S = 0, y = T = _ = w = void 0
                }

                function g() {
                    return void 0 === w ? b : f(o())
                }

                function v() {
                    var t = o(),
                        i = d(t);
                    if (y = arguments, _ = this, T = t, i) {
                        if (void 0 === w) return h(T);
                        if (E) return w = setTimeout(p, e), n(T)
                    }
                    return void 0 === w && (w = setTimeout(p, e)), b
                }
                var y, _, x, b, w, T, S = 0,
                    M = !1,
                    E = !1,
                    A = !0;
                if ("function" != typeof t) throw new TypeError(s);
                return e = a(e) || 0, r(i) && (M = !!i.leading, E = "maxWait" in i, x = E ? l(a(i.maxWait) || 0, e) : x, A = "trailing" in i ? !!i.trailing : A), v.cancel = m, v.flush = g, v
            }
            var r = i(1),
                o = i(8),
                a = i(10),
                s = "Expected a function",
                l = Math.max,
                c = Math.min;
            t.exports = n
        }, function(t, e, i) {
            var n = i(6),
                r = function() {
                    return n.Date.now()
                };
            t.exports = r
        }, function(t, e, i) {
            function n(t, e, i) {
                var n = !0,
                    s = !0;
                if ("function" != typeof t) throw new TypeError(a);
                return o(i) && (n = "leading" in i ? !!i.leading : n, s = "trailing" in i ? !!i.trailing : s), r(t, e, {
                    leading: n,
                    maxWait: e,
                    trailing: s
                })
            }
            var r = i(7),
                o = i(1),
                a = "Expected a function";
            t.exports = n
        }, function(t, e) {
            function i(t) {
                return t
            }
            t.exports = i
        }])
    })
}, function(t, e, i) {
    (function(t) {
        "use strict";

        function n(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var r = i(4),
            o = i(1),
            a = n(o);
        e.default = function() {
            function e(e) {
                i(), document.querySelector(".menu-ico").classList.toggle("open"), document.querySelector(".home-header-holder").classList.toggle("open"), s.classList.toggle("active"), s.classList.contains("active") ? ((0, a.default)(".contacts-popup__holder").removeClass("active"), t.stopScroling = !0) : t.stopScroling = !1, window.innerWidth > 767 || (l.classList.contains("open") ? document.querySelector(".header__logo").classList.remove("open") : setTimeout(function() {
                    document.querySelector(".header__logo").classList.add("open")
                }, 200))
            }
            var i = function t() {
                    t.done || (setTimeout(function() {
                        r.TweenMax.staggerFromTo(".main-menu__item", .3, {
                            opacity: 0,
                            scale: .8,
                            x: -100,
                            ease: r.Power3.easeOut
                        }, {
                            opacity: 1,
                            scale: 1,
                            x: 0,
                            ease: r.Power3.easeOut
                        }, .1)
                    }, 400), t.done = !0)
                },
                n = document.querySelector(".menu-btn"),
                o = document.querySelector(".main-menu__overlay"),
                s = document.querySelector(".main-menu__holder"),
                l = document.querySelector(".header__logo");
            if (n.addEventListener("click", e), o.addEventListener("click", e), (0, a.default)(".header__callback, .intro-holder .callback, .button-order--callback, .mobile-callback").click(function() {
                    (0, a.default)(".callback-form--popup").addClass("active"), t.stopScroling = !t.stopScroling
                }), (0, a.default)(".header-phone__ico--callback").click(function() {
                    (0, a.default)(".contacts-popup__holder").toggleClass("active"), (0, a.default)(".contacts-popup__holder").hasClass("active") ? (t.stopScroling = !0, (0, a.default)(".main-menu__holder").removeClass("active"), (0, a.default)(".menu-ico").removeClass("open")) : t.stopScroling = !1
                }), (0, a.default)(".contacts-popup__close").click(function() {
                    (0, a.default)(".contacts-popup__holder").removeClass("active"), t.stopScroling = !1
                }), (0, a.default)(".close-button-cb").click(function() {
                    (0, a.default)(".callback-form--popup").removeClass("active"), t.stopScroling = !t.stopScroling
                }), (0, a.default)(".without-seo__item .btn").on("click", function() {
                    (0, a.default)(".callback-form--popup").addClass("active"), t.stopScroling = !t.stopScroling
                }), !(0, a.default)('html[lang="en"]').length) {
                var c = "+38 (099) 999-9999";
                (0, a.default)('input[type="tel"],input[name="phone"]').mask(c)
            }(0, a.default)(".main-form__area-opener").on("click", function() {
                (0, a.default)(this).css("display", "none"), (0, a.default)(this).siblings(".main-form__col--textarea").addClass("active")
            }), (0, a.default)("body").on("mousewheel touchmove", function(e) {
                t.stopScroling && (e.preventDefault(), e.stopPropagation())
            })
        }
    }).call(e, function() {
        return this
    }())
}, function(t, e, i) {
    var n, r;
    (function(i) {
        var o = "undefined" != typeof t && t.exports && "undefined" != typeof i ? i : this || window;
        (o._gsQueue || (o._gsQueue = [])).push(function() {
                "use strict";
                o._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                        var n = function(t) {
                                var e, i = [],
                                    n = t.length;
                                for (e = 0; e !== n; i.push(t[e++]));
                                return i
                            },
                            r = function(t, e, i) {
                                var n, r, o = t.cycle;
                                for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                                delete t.cycle
                            },
                            o = function(t, e, n) {
                                i.call(this, t, e, n), this._cycle = 0, this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = o.prototype.render
                            },
                            a = 1e-10,
                            s = i._internals,
                            l = s.isSelector,
                            c = s.isArray,
                            h = o.prototype = i.to({}, .1, {}),
                            u = [];
                        o.version = "1.20.5", h.constructor = o, h.kill()._gc = !1, o.killTweensOf = o.killDelayedCallsTo = i.killTweensOf, o.getTweensOf = i.getTweensOf, o.lagSmoothing = i.lagSmoothing, o.ticker = i.ticker, o.render = i.render, h.invalidate = function() {
                            return this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), i.prototype.invalidate.call(this)
                        }, h.updateTo = function(t, e) {
                            var n, r = this.ratio,
                                o = this.vars.immediateRender || t.immediateRender;
                            e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                            for (n in t) this.vars[n] = t[n];
                            if (this._initted || o)
                                if (e) this._initted = !1, o && this.render(0, !0, !0);
                                else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                                var a = this._totalTime;
                                this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
                            } else if (this._initted = !1, this._init(), this._time > 0 || o)
                                for (var s, l = 1 / (1 - r), c = this._firstPT; c;) s = c.s + c.c, c.c *= l, c.s = s - c.c, c = c._next;
                            return this
                        }, h.render = function(t, e, n) {
                            this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                            var r, o, l, c, h, u, d, p, f, m = this._dirty ? this.totalDuration() : this._totalDuration,
                                g = this._time,
                                v = this._totalTime,
                                y = this._cycle,
                                _ = this._duration,
                                x = this._rawPrevTime;
                            if (t >= m - 1e-7 && t >= 0 ? (this._totalTime = m, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = _, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, o = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === _ && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0), (x < 0 || t <= 0 && t >= -1e-7 || x === a && "isPause" !== this.data) && x !== t && (n = !0, x > a && (o = "onReverseComplete")), this._rawPrevTime = p = !e || t || x === t ? t : a)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== v || 0 === _ && x > 0) && (o = "onReverseComplete", r = this._reversed), t < 0 && (this._active = !1, 0 === _ && (this._initted || !this.vars.lazy || n) && (x >= 0 && (n = !0), this._rawPrevTime = p = !e || t || x === t ? t : a)), this._initted || (n = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (c = _ + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && v <= t && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 !== (1 & this._cycle) && (this._time = _ - this._time, f = this._yoyoEase || this.vars.yoyoEase, f && (this._yoyoEase || (f !== !0 || this._initted ? this._yoyoEase = f = f === !0 ? this._ease : f instanceof Ease ? f : Ease.map[f] : (f = this.vars.ease, this._yoyoEase = f = f ? f instanceof Ease ? f : "function" == typeof f ? new Ease(f, this.vars.easeParams) : Ease.map[f] || i.defaultEase : i.defaultEase)), this.ratio = f ? 1 - f.getRatio((_ - this._time) / _) : 0)), this._time > _ ? this._time = _ : this._time < 0 && (this._time = 0)), this._easeType && !f ? (h = this._time / _, u = this._easeType, d = this._easePower, (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === d ? h *= h : 2 === d ? h *= h * h : 3 === d ? h *= h * h * h : 4 === d && (h *= h * h * h * h), 1 === u ? this.ratio = 1 - h : 2 === u ? this.ratio = h : this._time / _ < .5 ? this.ratio = h / 2 : this.ratio = 1 - h / 2) : f || (this.ratio = this._ease.getRatio(this._time / _))), g === this._time && !n && y === this._cycle) return void(v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")));
                            if (!this._initted) {
                                if (this._init(), !this._initted || this._gc) return;
                                if (!n && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = g, this._totalTime = v, this._rawPrevTime = x, this._cycle = y, s.lazyTweens.push(this), void(this._lazy = [t, e]);
                                !this._time || r || f ? r && this._ease._calcEnd && !f && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / _)
                            }
                            for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== g && t >= 0 && (this._active = !0), 0 === v && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, n) : o || (o = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== _ || e || this._callback("onStart"))), l = this._firstPT; l;) l.f ? l.t[l.p](l.c * this.ratio + l.s) : l.t[l.p] = l.c * this.ratio + l.s, l = l._next;
                            this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, !0, n), e || (this._totalTime !== v || o) && this._callback("onUpdate")), this._cycle !== y && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), o && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this._callback(o), 0 === _ && this._rawPrevTime === a && p !== a && (this._rawPrevTime = 0)))
                        }, o.to = function(t, e, i) {
                            return new o(t, e, i)
                        }, o.from = function(t, e, i) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new o(t, e, i)
                        }, o.fromTo = function(t, e, i, n) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new o(t, e, n)
                        }, o.staggerTo = o.allTo = function(t, e, a, s, h, d, p) {
                            s = s || 0;
                            var f, m, g, v, y = 0,
                                _ = [],
                                x = function() {
                                    a.onComplete && a.onComplete.apply(a.onCompleteScope || this, arguments), h.apply(p || a.callbackScope || this, d || u)
                                },
                                b = a.cycle,
                                w = a.startAt && a.startAt.cycle;
                            for (c(t) || ("string" == typeof t && (t = i.selector(t) || t), l(t) && (t = n(t))), t = t || [], s < 0 && (t = n(t), t.reverse(), s *= -1), f = t.length - 1, g = 0; g <= f; g++) {
                                m = {};
                                for (v in a) m[v] = a[v];
                                if (b && (r(m, t, g), null != m.duration && (e = m.duration, delete m.duration)), w) {
                                    w = m.startAt = {};
                                    for (v in a.startAt) w[v] = a.startAt[v];
                                    r(m.startAt, t, g)
                                }
                                m.delay = y + (m.delay || 0), g === f && h && (m.onComplete = x), _[g] = new o(t[g], e, m), y += s
                            }
                            return _
                        }, o.staggerFrom = o.allFrom = function(t, e, i, n, r, a, s) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, o.staggerTo(t, e, i, n, r, a, s)
                        }, o.staggerFromTo = o.allFromTo = function(t, e, i, n, r, a, s, l) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, o.staggerTo(t, e, n, r, a, s, l)
                        }, o.delayedCall = function(t, e, i, n, r) {
                            return new o(e, 0, {
                                delay: t,
                                onComplete: e,
                                onCompleteParams: i,
                                callbackScope: n,
                                onReverseComplete: e,
                                onReverseCompleteParams: i,
                                immediateRender: !1,
                                useFrames: r,
                                overwrite: 0
                            })
                        }, o.set = function(t, e) {
                            return new o(t, 0, e)
                        }, o.isTweening = function(t) {
                            return i.getTweensOf(t, !0).length > 0
                        };
                        var d = function(t, e) {
                                for (var n = [], r = 0, o = t._first; o;) o instanceof i ? n[r++] = o : (e && (n[r++] = o), n = n.concat(d(o, e)), r = n.length), o = o._next;
                                return n
                            },
                            p = o.getAllTweens = function(e) {
                                return d(t._rootTimeline, e).concat(d(t._rootFramesTimeline, e))
                            };
                        o.killAll = function(t, i, n, r) {
                            null == i && (i = !0), null == n && (n = !0);
                            var o, a, s, l = p(0 != r),
                                c = l.length,
                                h = i && n && r;
                            for (s = 0; s < c; s++) a = l[s], (h || a instanceof e || (o = a.target === a.vars.onComplete) && n || i && !o) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
                        }, o.killChildTweensOf = function(t, e) {
                            if (null != t) {
                                var r, a, h, u, d, p = s.tweenLookup;
                                if ("string" == typeof t && (t = i.selector(t) || t), l(t) && (t = n(t)), c(t))
                                    for (u = t.length; --u > -1;) o.killChildTweensOf(t[u], e);
                                else {
                                    r = [];
                                    for (h in p)
                                        for (a = p[h].target.parentNode; a;) a === t && (r = r.concat(p[h].tweens)), a = a.parentNode;
                                    for (d = r.length, u = 0; u < d; u++) e && r[u].totalTime(r[u].totalDuration()), r[u]._enabled(!1, !1)
                                }
                            }
                        };
                        var f = function(t, i, n, r) {
                            i = i !== !1, n = n !== !1, r = r !== !1;
                            for (var o, a, s = p(r), l = i && n && r, c = s.length; --c > -1;) a = s[c], (l || a instanceof e || (o = a.target === a.vars.onComplete) && n || i && !o) && a.paused(t)
                        };
                        return o.pauseAll = function(t, e, i) {
                            f(!0, t, e, i)
                        }, o.resumeAll = function(t, e, i) {
                            f(!1, t, e, i)
                        }, o.globalTimeScale = function(e) {
                            var n = t._rootTimeline,
                                r = i.ticker.time;
                            return arguments.length ? (e = e || a, n._startTime = r - (r - n._startTime) * n._timeScale / e, n = t._rootFramesTimeline, r = i.ticker.frame, n._startTime = r - (r - n._startTime) * n._timeScale / e, n._timeScale = t._rootTimeline._timeScale = e, e) : n._timeScale
                        }, h.progress = function(t, e) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
                        }, h.totalProgress = function(t, e) {
                            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
                        }, h.time = function(t, e) {
                            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                        }, h.duration = function(e) {
                            return arguments.length ? t.prototype.duration.call(this, e) : this._duration
                        }, h.totalDuration = function(t) {
                            return arguments.length ? this._repeat === -1 ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                        }, h.repeat = function(t) {
                            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                        }, h.repeatDelay = function(t) {
                            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                        }, h.yoyo = function(t) {
                            return arguments.length ? (this._yoyo = t, this) : this._yoyo
                        }, o
                    }, !0), o._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                        var n = function(t) {
                                e.call(this, t), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                                var i, n, r = this.vars;
                                for (n in r) i = r[n], c(i) && i.join("").indexOf("{self}") !== -1 && (r[n] = this._swapSelfInParams(i));
                                c(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                            },
                            r = 1e-10,
                            a = i._internals,
                            s = n._internals = {},
                            l = a.isSelector,
                            c = a.isArray,
                            h = a.lazyTweens,
                            u = a.lazyRender,
                            d = o._gsDefine.globals,
                            p = function(t) {
                                var e, i = {};
                                for (e in t) i[e] = t[e];
                                return i
                            },
                            f = function(t, e, i) {
                                var n, r, o = t.cycle;
                                for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                                delete t.cycle
                            },
                            m = s.pauseCallback = function() {},
                            g = function(t) {
                                var e, i = [],
                                    n = t.length;
                                for (e = 0; e !== n; i.push(t[e++]));
                                return i
                            },
                            v = n.prototype = new e;
                        return n.version = "1.20.4", v.constructor = n, v.kill()._gc = v._forcingPlayhead = v._hasPause = !1, v.to = function(t, e, n, r) {
                            var o = n.repeat && d.TweenMax || i;
                            return e ? this.add(new o(t, e, n), r) : this.set(t, n, r)
                        }, v.from = function(t, e, n, r) {
                            return this.add((n.repeat && d.TweenMax || i).from(t, e, n), r)
                        }, v.fromTo = function(t, e, n, r, o) {
                            var a = r.repeat && d.TweenMax || i;
                            return e ? this.add(a.fromTo(t, e, n, r), o) : this.set(t, r, o)
                        }, v.staggerTo = function(t, e, r, o, a, s, c, h) {
                            var u, d, m = new n({
                                    onComplete: s,
                                    onCompleteParams: c,
                                    callbackScope: h,
                                    smoothChildTiming: this.smoothChildTiming
                                }),
                                v = r.cycle;
                            for ("string" == typeof t && (t = i.selector(t) || t), t = t || [], l(t) && (t = g(t)), o = o || 0, o < 0 && (t = g(t), t.reverse(), o *= -1), d = 0; d < t.length; d++) u = p(r), u.startAt && (u.startAt = p(u.startAt), u.startAt.cycle && f(u.startAt, t, d)), v && (f(u, t, d), null != u.duration && (e = u.duration, delete u.duration)), m.to(t[d], e, u, d * o);
                            return this.add(m, a)
                        }, v.staggerFrom = function(t, e, i, n, r, o, a, s) {
                            return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, n, r, o, a, s)
                        }, v.staggerFromTo = function(t, e, i, n, r, o, a, s, l) {
                            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, n, r, o, a, s, l)
                        }, v.call = function(t, e, n, r) {
                            return this.add(i.delayedCall(0, t, e, n), r)
                        }, v.set = function(t, e, n) {
                            return n = this._parseTimeOrLabel(n, 0, !0), null == e.immediateRender && (e.immediateRender = n === this._time && !this._paused), this.add(new i(t, 0, e), n)
                        }, n.exportRoot = function(t, e) {
                            t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming = !0);
                            var r, o, a, s, l = new n(t),
                                c = l._timeline;
                            for (null == e && (e = !0), c._remove(l, !0), l._startTime = 0, l._rawPrevTime = l._time = l._totalTime = c._time, a = c._first; a;) s = a._next, e && a instanceof i && a.target === a.vars.onComplete || (o = a._startTime - a._delay, o < 0 && (r = 1), l.add(a, o)), a = s;
                            return c.add(l, 0), r && l.totalDuration(), l
                        }, v.add = function(r, o, a, s) {
                            var l, h, u, d, p, f;
                            if ("number" != typeof o && (o = this._parseTimeOrLabel(o, 0, !0, r)), !(r instanceof t)) {
                                if (r instanceof Array || r && r.push && c(r)) {
                                    for (a = a || "normal", s = s || 0, l = o, h = r.length, u = 0; u < h; u++) c(d = r[u]) && (d = new n({
                                        tweens: d
                                    })), this.add(d, l), "string" != typeof d && "function" != typeof d && ("sequence" === a ? l = d._startTime + d.totalDuration() / d._timeScale : "start" === a && (d._startTime -= d.delay())), l += s;
                                    return this._uncache(!0)
                                }
                                if ("string" == typeof r) return this.addLabel(r, o);
                                if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
                                r = i.delayedCall(0, r)
                            }
                            if (e.prototype.add.call(this, r, o), r._time && r.render((this.rawTime() - r._startTime) * r._timeScale, !1, !1), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                                for (p = this, f = p.rawTime() > r._startTime; p._timeline;) f && p._timeline.smoothChildTiming ? p.totalTime(p._totalTime, !0) : p._gc && p._enabled(!0, !1), p = p._timeline;
                            return this
                        }, v.remove = function(e) {
                            if (e instanceof t) {
                                this._remove(e, !1);
                                var i = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline;
                                return e._startTime = (e._paused ? e._pauseTime : i._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this
                            }
                            if (e instanceof Array || e && e.push && c(e)) {
                                for (var n = e.length; --n > -1;) this.remove(e[n]);
                                return this
                            }
                            return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
                        }, v._remove = function(t, i) {
                            e.prototype._remove.call(this, t, i);
                            var n = this._last;
                            return n ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                        }, v.append = function(t, e) {
                            return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
                        }, v.insert = v.insertMultiple = function(t, e, i, n) {
                            return this.add(t, e || 0, i, n)
                        }, v.appendMultiple = function(t, e, i, n) {
                            return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
                        }, v.addLabel = function(t, e) {
                            return this._labels[t] = this._parseTimeOrLabel(e), this
                        }, v.addPause = function(t, e, n, r) {
                            var o = i.delayedCall(0, m, n, r || this);
                            return o.vars.onComplete = o.vars.onReverseComplete = e, o.data = "isPause", this._hasPause = !0, this.add(o, t)
                        }, v.removeLabel = function(t) {
                            return delete this._labels[t], this
                        }, v.getLabelTime = function(t) {
                            return null != this._labels[t] ? this._labels[t] : -1
                        }, v._parseTimeOrLabel = function(e, i, n, r) {
                            var o, a;
                            if (r instanceof t && r.timeline === this) this.remove(r);
                            else if (r && (r instanceof Array || r.push && c(r)))
                                for (a = r.length; --a > -1;) r[a] instanceof t && r[a].timeline === this && this.remove(r[a]);
                            if (o = "number" != typeof e || i ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof i) return this._parseTimeOrLabel(i, n && "number" == typeof e && null == this._labels[i] ? e - o : 0, n);
                            if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = o);
                            else {
                                if (a = e.indexOf("="), a === -1) return null == this._labels[e] ? n ? this._labels[e] = o + i : i : this._labels[e] + i;
                                i = parseInt(e.charAt(a - 1) + "1", 10) * Number(e.substr(a + 1)), e = a > 1 ? this._parseTimeOrLabel(e.substr(0, a - 1), 0, n) : o
                            }
                            return Number(e) + i
                        }, v.seek = function(t, e) {
                            return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), e !== !1)
                        }, v.stop = function() {
                            return this.paused(!0)
                        }, v.gotoAndPlay = function(t, e) {
                            return this.play(t, e)
                        }, v.gotoAndStop = function(t, e) {
                            return this.pause(t, e)
                        }, v.render = function(t, e, i) {
                            this._gc && this._enabled(!0, !1);
                            var n, o, a, s, l, c, d, p = this._time,
                                f = this._dirty ? this.totalDuration() : this._totalDuration,
                                m = this._startTime,
                                g = this._timeScale,
                                v = this._paused;
                            if (p !== this._time && (t += this._time - p), t >= f - 1e-7 && t >= 0) this._totalTime = this._time = f, this._reversed || this._hasPausedChild() || (o = !0, s = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === r) && this._rawPrevTime !== t && this._first && (l = !0, this._rawPrevTime > r && (s = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, t = f + 1e-4;
                            else if (t < 1e-7)
                                if (this._totalTime = this._time = 0, (0 !== p || 0 === this._duration && this._rawPrevTime !== r && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (s = "onReverseComplete", o = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = o = !0, s = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = t;
                                else {
                                    if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, 0 === t && o)
                                        for (n = this._first; n && 0 === n._startTime;) n._duration || (o = !1), n = n._next;
                                    t = 0, this._initted || (l = !0)
                                }
                            else {
                                if (this._hasPause && !this._forcingPlayhead && !e) {
                                    if (t >= p)
                                        for (n = this._first; n && n._startTime <= t && !c;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (c = n), n = n._next;
                                    else
                                        for (n = this._last; n && n._startTime >= t && !c;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (c = n), n = n._prev;
                                    c && (this._time = t = c._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                                }
                                this._totalTime = this._time = this._rawPrevTime = t
                            }
                            if (this._time !== p && this._first || i || l || c) {
                                if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== p && t > 0 && (this._active = !0), 0 === p && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), d = this._time, d >= p)
                                    for (n = this._first; n && (a = n._next, d === this._time && (!this._paused || v));)(n._active || n._startTime <= d && !n._paused && !n._gc) && (c === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = a;
                                else
                                    for (n = this._last; n && (a = n._prev, d === this._time && (!this._paused || v));) {
                                        if (n._active || n._startTime <= p && !n._paused && !n._gc) {
                                            if (c === n) {
                                                for (c = n._prev; c && c.endTime() > this._time;) c.render(c._reversed ? c.totalDuration() - (t - c._startTime) * c._timeScale : (t - c._startTime) * c._timeScale, e, i), c = c._prev;
                                                c = null, this.pause()
                                            }
                                            n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                        }
                                        n = a
                                    }
                                this._onUpdate && (e || (h.length && u(), this._callback("onUpdate"))), s && (this._gc || m !== this._startTime && g === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (o && (h.length && u(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[s] && this._callback(s)))
                            }
                        }, v._hasPausedChild = function() {
                            for (var t = this._first; t;) {
                                if (t._paused || t instanceof n && t._hasPausedChild()) return !0;
                                t = t._next
                            }
                            return !1
                        }, v.getChildren = function(t, e, n, r) {
                            r = r || -9999999999;
                            for (var o = [], a = this._first, s = 0; a;) a._startTime < r || (a instanceof i ? e !== !1 && (o[s++] = a) : (n !== !1 && (o[s++] = a), t !== !1 && (o = o.concat(a.getChildren(!0, e, n)), s = o.length))), a = a._next;
                            return o
                        }, v.getTweensOf = function(t, e) {
                            var n, r, o = this._gc,
                                a = [],
                                s = 0;
                            for (o && this._enabled(!0, !0), n = i.getTweensOf(t), r = n.length; --r > -1;)(n[r].timeline === this || e && this._contains(n[r])) && (a[s++] = n[r]);
                            return o && this._enabled(!1, !0), a
                        }, v.recent = function() {
                            return this._recent
                        }, v._contains = function(t) {
                            for (var e = t.timeline; e;) {
                                if (e === this) return !0;
                                e = e.timeline
                            }
                            return !1
                        }, v.shiftChildren = function(t, e, i) {
                            i = i || 0;
                            for (var n, r = this._first, o = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
                            if (e)
                                for (n in o) o[n] >= i && (o[n] += t);
                            return this._uncache(!0)
                        }, v._kill = function(t, e) {
                            if (!t && !e) return this._enabled(!1, !1);
                            for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; --n > -1;) i[n]._kill(t, e) && (r = !0);
                            return r
                        }, v.clear = function(t) {
                            var e = this.getChildren(!1, !0, !0),
                                i = e.length;
                            for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
                            return t !== !1 && (this._labels = {}), this._uncache(!0)
                        }, v.invalidate = function() {
                            for (var e = this._first; e;) e.invalidate(), e = e._next;
                            return t.prototype.invalidate.call(this)
                        }, v._enabled = function(t, i) {
                            if (t === this._gc)
                                for (var n = this._first; n;) n._enabled(t, !0), n = n._next;
                            return e.prototype._enabled.call(this, t, i)
                        }, v.totalTime = function(e, i, n) {
                            this._forcingPlayhead = !0;
                            var r = t.prototype.totalTime.apply(this, arguments);
                            return this._forcingPlayhead = !1, r
                        }, v.duration = function(t) {
                            return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
                        }, v.totalDuration = function(t) {
                            if (!arguments.length) {
                                if (this._dirty) {
                                    for (var e, i, n = 0, r = this._last, o = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > o && this._sortChildren && !r._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(r, r._startTime - r._delay), this._calculatingDuration = 0) : o = r._startTime, r._startTime < 0 && !r._paused && (n -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale, this._time -= r._startTime, this._totalTime -= r._startTime, this._rawPrevTime -= r._startTime), this.shiftChildren(-r._startTime, !1, -9999999999), o = 0), i = r._startTime + r._totalDuration / r._timeScale, i > n && (n = i), r = e;
                                    this._duration = this._totalDuration = n, this._dirty = !1
                                }
                                return this._totalDuration
                            }
                            return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
                        }, v.paused = function(e) {
                            if (!e)
                                for (var i = this._first, n = this._time; i;) i._startTime === n && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next;
                            return t.prototype.paused.apply(this, arguments)
                        }, v.usesFrames = function() {
                            for (var e = this._timeline; e._timeline;) e = e._timeline;
                            return e === t._rootFramesTimeline
                        }, v.rawTime = function(t) {
                            return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
                        }, n
                    }, !0), o._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, e, i) {
                        var n = function(e) {
                                t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0
                            },
                            r = 1e-10,
                            a = e._internals,
                            s = a.lazyTweens,
                            l = a.lazyRender,
                            c = o._gsDefine.globals,
                            h = new i(null, null, 1, 0),
                            u = n.prototype = new t;
                        return u.constructor = n, u.kill()._gc = !1, n.version = "1.20.4", u.invalidate = function() {
                            return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this)
                        }, u.addCallback = function(t, i, n, r) {
                            return this.add(e.delayedCall(0, t, n, r), i)
                        }, u.removeCallback = function(t, e) {
                            if (t)
                                if (null == e) this._kill(null, t);
                                else
                                    for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); --n > -1;) i[n]._startTime === r && i[n]._enabled(!1, !1);
                            return this
                        }, u.removePause = function(e) {
                            return this.removeCallback(t._internals.pauseCallback, e)
                        }, u.tweenTo = function(t, i) {
                            i = i || {};
                            var n, r, o, a = {
                                    ease: h,
                                    useFrames: this.usesFrames(),
                                    immediateRender: !1,
                                    lazy: !1
                                },
                                s = i.repeat && c.TweenMax || e;
                            for (r in i) a[r] = i[r];
                            return a.time = this._parseTimeOrLabel(t), n = Math.abs(Number(a.time) - this._time) / this._timeScale || .001, o = new s(this, n, a), a.onStart = function() {
                                o.target.paused(!0), o.vars.time === o.target.time() || n !== o.duration() || o.isFromTo || o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale).render(o.time(), !0, !0), i.onStart && i.onStart.apply(i.onStartScope || i.callbackScope || o, i.onStartParams || [])
                            }, o
                        }, u.tweenFromTo = function(t, e, i) {
                            i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                                onComplete: this.seek,
                                onCompleteParams: [t],
                                callbackScope: this
                            }, i.immediateRender = i.immediateRender !== !1;
                            var n = this.tweenTo(e, i);
                            return n.isFromTo = 1, n.duration(Math.abs(n.vars.time - t) / this._timeScale || .001)
                        }, u.render = function(t, e, i) {
                            this._gc && this._enabled(!0, !1);
                            var n, o, a, c, h, u, d, p, f = this._time,
                                m = this._dirty ? this.totalDuration() : this._totalDuration,
                                g = this._duration,
                                v = this._totalTime,
                                y = this._startTime,
                                _ = this._timeScale,
                                x = this._rawPrevTime,
                                b = this._paused,
                                w = this._cycle;
                            if (f !== this._time && (t += this._time - f), t >= m - 1e-7 && t >= 0) this._locked || (this._totalTime = m, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (o = !0, c = "onComplete", h = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || x < 0 || x === r) && x !== t && this._first && (h = !0, x > r && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, this._yoyo && 0 !== (1 & this._cycle) ? this._time = t = 0 : (this._time = g, t = g + 1e-4);
                            else if (t < 1e-7)
                                if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== f || 0 === g && x !== r && (x > 0 || t < 0 && x >= 0) && !this._locked) && (c = "onReverseComplete", o = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (h = o = !0, c = "onReverseComplete") : x >= 0 && this._first && (h = !0), this._rawPrevTime = t;
                                else {
                                    if (this._rawPrevTime = g || !e || t || this._rawPrevTime === t ? t : r, 0 === t && o)
                                        for (n = this._first; n && 0 === n._startTime;) n._duration || (o = !1), n = n._next;
                                    t = 0, this._initted || (h = !0)
                                }
                            else if (0 === g && x < 0 && (h = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (u = g + this._repeatDelay, this._cycle = this._totalTime / u >> 0, 0 !== this._cycle && this._cycle === this._totalTime / u && v <= t && this._cycle--, this._time = this._totalTime - this._cycle * u, this._yoyo && 0 !== (1 & this._cycle) && (this._time = g - this._time), this._time > g ? (this._time = g, t = g + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e) {
                                if (t = this._time, t >= f || this._repeat && w !== this._cycle)
                                    for (n = this._first; n && n._startTime <= t && !d;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (d = n), n = n._next;
                                else
                                    for (n = this._last; n && n._startTime >= t && !d;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (d = n), n = n._prev;
                                d && d._startTime < g && (this._time = t = d._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                            }
                            if (this._cycle !== w && !this._locked) {
                                var T = this._yoyo && 0 !== (1 & w),
                                    S = T === (this._yoyo && 0 !== (1 & this._cycle)),
                                    M = this._totalTime,
                                    E = this._cycle,
                                    A = this._rawPrevTime,
                                    C = this._time;
                                if (this._totalTime = w * g, this._cycle < w ? T = !T : this._totalTime += g, this._time = f, this._rawPrevTime = 0 === g ? x - 1e-4 : x, this._cycle = w, this._locked = !0, f = T ? 0 : g, this.render(f, e, 0 === g), e || this._gc || this.vars.onRepeat && (this._cycle = E, this._locked = !1, this._callback("onRepeat")), f !== this._time) return;
                                if (S && (this._cycle = w, this._locked = !0, f = T ? g + 1e-4 : -1e-4, this.render(f, !0, !1)), this._locked = !1, this._paused && !b) return;
                                this._time = C, this._totalTime = M, this._cycle = E, this._rawPrevTime = A
                            }
                            if (!(this._time !== f && this._first || i || h || d)) return void(v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")));
                            if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== v && t > 0 && (this._active = !0), 0 === v && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), p = this._time, p >= f)
                                for (n = this._first; n && (a = n._next, p === this._time && (!this._paused || b));)(n._active || n._startTime <= this._time && !n._paused && !n._gc) && (d === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = a;
                            else
                                for (n = this._last; n && (a = n._prev, p === this._time && (!this._paused || b));) {
                                    if (n._active || n._startTime <= f && !n._paused && !n._gc) {
                                        if (d === n) {
                                            for (d = n._prev; d && d.endTime() > this._time;) d.render(d._reversed ? d.totalDuration() - (t - d._startTime) * d._timeScale : (t - d._startTime) * d._timeScale, e, i), d = d._prev;
                                            d = null, this.pause()
                                        }
                                        n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                    }
                                    n = a
                                }
                            this._onUpdate && (e || (s.length && l(), this._callback("onUpdate"))), c && (this._locked || this._gc || y !== this._startTime && _ === this._timeScale || (0 === this._time || m >= this.totalDuration()) && (o && (s.length && l(),
                                this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[c] && this._callback(c)))
                        }, u.getActive = function(t, e, i) {
                            null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
                            var n, r, o = [],
                                a = this.getChildren(t, e, i),
                                s = 0,
                                l = a.length;
                            for (n = 0; n < l; n++) r = a[n], r.isActive() && (o[s++] = r);
                            return o
                        }, u.getLabelAfter = function(t) {
                            t || 0 !== t && (t = this._time);
                            var e, i = this.getLabelsArray(),
                                n = i.length;
                            for (e = 0; e < n; e++)
                                if (i[e].time > t) return i[e].name;
                            return null
                        }, u.getLabelBefore = function(t) {
                            null == t && (t = this._time);
                            for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
                                if (e[i].time < t) return e[i].name;
                            return null
                        }, u.getLabelsArray = function() {
                            var t, e = [],
                                i = 0;
                            for (t in this._labels) e[i++] = {
                                time: this._labels[t],
                                name: t
                            };
                            return e.sort(function(t, e) {
                                return t.time - e.time
                            }), e
                        }, u.invalidate = function() {
                            return this._locked = !1, t.prototype.invalidate.call(this)
                        }, u.progress = function(t, e) {
                            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0
                        }, u.totalProgress = function(t, e) {
                            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0
                        }, u.totalDuration = function(e) {
                            return arguments.length ? this._repeat !== -1 && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                        }, u.time = function(t, e) {
                            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                        }, u.repeat = function(t) {
                            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                        }, u.repeatDelay = function(t) {
                            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                        }, u.yoyo = function(t) {
                            return arguments.length ? (this._yoyo = t, this) : this._yoyo
                        }, u.currentLabel = function(t) {
                            return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
                        }, n
                    }, !0),
                    function() {
                        var t = 180 / Math.PI,
                            e = [],
                            i = [],
                            n = [],
                            r = {},
                            a = o._gsDefine.globals,
                            s = function(t, e, i, n) {
                                i === n && (i = n - (n - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
                            },
                            l = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
                            c = function(t, e, i, n) {
                                var r = {
                                        a: t
                                    },
                                    o = {},
                                    a = {},
                                    s = {
                                        c: n
                                    },
                                    l = (t + e) / 2,
                                    c = (e + i) / 2,
                                    h = (i + n) / 2,
                                    u = (l + c) / 2,
                                    d = (c + h) / 2,
                                    p = (d - u) / 8;
                                return r.b = l + (t - l) / 4, o.b = u + p, r.c = o.a = (r.b + o.b) / 2, o.c = a.a = (u + d) / 2, a.b = d - p, s.b = h + (n - h) / 4, a.c = s.a = (a.b + s.b) / 2, [r, o, a, s]
                            },
                            h = function(t, r, o, a, s) {
                                var l, h, u, d, p, f, m, g, v, y, _, x, b, w = t.length - 1,
                                    T = 0,
                                    S = t[0].a;
                                for (l = 0; l < w; l++) p = t[T], h = p.a, u = p.d, d = t[T + 1].d, s ? (_ = e[l], x = i[l], b = (x + _) * r * .25 / (a ? .5 : n[l] || .5), f = u - (u - h) * (a ? .5 * r : 0 !== _ ? b / _ : 0), m = u + (d - u) * (a ? .5 * r : 0 !== x ? b / x : 0), g = u - (f + ((m - f) * (3 * _ / (_ + x) + .5) / 4 || 0))) : (f = u - (u - h) * r * .5, m = u + (d - u) * r * .5, g = u - (f + m) / 2), f += g, m += g, p.c = v = f, 0 !== l ? p.b = S : p.b = S = p.a + .6 * (p.c - p.a), p.da = u - h, p.ca = v - h, p.ba = S - h, o ? (y = c(h, S, v, u), t.splice(T, 1, y[0], y[1], y[2], y[3]), T += 4) : T++, S = m;
                                p = t[T], p.b = S, p.c = S + .4 * (p.d - S), p.da = p.d - p.a, p.ca = p.c - p.a, p.ba = S - p.a, o && (y = c(p.a, S, p.c, p.d), t.splice(T, 1, y[0], y[1], y[2], y[3]))
                            },
                            u = function(t, n, r, o) {
                                var a, l, c, h, u, d, p = [];
                                if (o)
                                    for (t = [o].concat(t), l = t.length; --l > -1;) "string" == typeof(d = t[l][n]) && "=" === d.charAt(1) && (t[l][n] = o[n] + Number(d.charAt(0) + d.substr(2)));
                                if (a = t.length - 2, a < 0) return p[0] = new s(t[0][n], 0, 0, t[0][n]), p;
                                for (l = 0; l < a; l++) c = t[l][n], h = t[l + 1][n], p[l] = new s(c, 0, 0, h), r && (u = t[l + 2][n], e[l] = (e[l] || 0) + (h - c) * (h - c), i[l] = (i[l] || 0) + (u - h) * (u - h));
                                return p[l] = new s(t[l][n], 0, 0, t[l + 1][n]), p
                            },
                            d = function(t, o, a, s, c, d) {
                                var p, f, m, g, v, y, _, x, b = {},
                                    w = [],
                                    T = d || t[0];
                                c = "string" == typeof c ? "," + c + "," : l, null == o && (o = 1);
                                for (f in t[0]) w.push(f);
                                if (t.length > 1) {
                                    for (x = t[t.length - 1], _ = !0, p = w.length; --p > -1;)
                                        if (f = w[p], Math.abs(T[f] - x[f]) > .05) {
                                            _ = !1;
                                            break
                                        }
                                    _ && (t = t.concat(), d && t.unshift(d), t.push(t[1]), d = t[t.length - 3])
                                }
                                for (e.length = i.length = n.length = 0, p = w.length; --p > -1;) f = w[p], r[f] = c.indexOf("," + f + ",") !== -1, b[f] = u(t, f, r[f], d);
                                for (p = e.length; --p > -1;) e[p] = Math.sqrt(e[p]), i[p] = Math.sqrt(i[p]);
                                if (!s) {
                                    for (p = w.length; --p > -1;)
                                        if (r[f])
                                            for (m = b[w[p]], y = m.length - 1, g = 0; g < y; g++) v = m[g + 1].da / i[g] + m[g].da / e[g] || 0, n[g] = (n[g] || 0) + v * v;
                                    for (p = n.length; --p > -1;) n[p] = Math.sqrt(n[p])
                                }
                                for (p = w.length, g = a ? 4 : 1; --p > -1;) f = w[p], m = b[f], h(m, o, a, s, r[f]), _ && (m.splice(0, g), m.splice(m.length - g, g));
                                return b
                            },
                            p = function(t, e, i) {
                                e = e || "soft";
                                var n, r, o, a, l, c, h, u, d, p, f, m = {},
                                    g = "cubic" === e ? 3 : 2,
                                    v = "soft" === e,
                                    y = [];
                                if (v && i && (t = [i].concat(t)), null == t || t.length < g + 1) throw "invalid Bezier data";
                                for (d in t[0]) y.push(d);
                                for (c = y.length; --c > -1;) {
                                    for (d = y[c], m[d] = l = [], p = 0, u = t.length, h = 0; h < u; h++) n = null == i ? t[h][d] : "string" == typeof(f = t[h][d]) && "=" === f.charAt(1) ? i[d] + Number(f.charAt(0) + f.substr(2)) : Number(f), v && h > 1 && h < u - 1 && (l[p++] = (n + l[p - 2]) / 2), l[p++] = n;
                                    for (u = p - g + 1, p = 0, h = 0; h < u; h += g) n = l[h], r = l[h + 1], o = l[h + 2], a = 2 === g ? 0 : l[h + 3], l[p++] = f = 3 === g ? new s(n, r, o, a) : new s(n, (2 * r + n) / 3, (2 * r + o) / 3, o);
                                    l.length = p
                                }
                                return m
                            },
                            f = function(t, e, i) {
                                for (var n, r, o, a, s, l, c, h, u, d, p, f = 1 / i, m = t.length; --m > -1;)
                                    for (d = t[m], o = d.a, a = d.d - o, s = d.c - o, l = d.b - o, n = r = 0, h = 1; h <= i; h++) c = f * h, u = 1 - c, n = r - (r = (c * c * a + 3 * u * (c * s + u * l)) * c), p = m * i + h - 1, e[p] = (e[p] || 0) + n * n
                            },
                            m = function(t, e) {
                                e = e >> 0 || 6;
                                var i, n, r, o, a = [],
                                    s = [],
                                    l = 0,
                                    c = 0,
                                    h = e - 1,
                                    u = [],
                                    d = [];
                                for (i in t) f(t[i], a, e);
                                for (r = a.length, n = 0; n < r; n++) l += Math.sqrt(a[n]), o = n % e, d[o] = l, o === h && (c += l, o = n / e >> 0, u[o] = d, s[o] = c, l = 0, d = []);
                                return {
                                    length: c,
                                    lengths: s,
                                    segments: u
                                }
                            },
                            g = o._gsDefine.plugin({
                                propName: "bezier",
                                priority: -1,
                                version: "1.3.8",
                                API: 2,
                                global: !0,
                                init: function(t, e, i) {
                                    this._target = t, e instanceof Array && (e = {
                                        values: e
                                    }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                                    var n, r, o, a, s, l = e.values || [],
                                        c = {},
                                        h = l[0],
                                        u = e.autoRotate || i.vars.orientToBezier;
                                    this._autoRotate = u ? u instanceof Array ? u : [
                                        ["x", "y", "rotation", u === !0 ? 0 : Number(u) || 0]
                                    ] : null;
                                    for (n in h) this._props.push(n);
                                    for (o = this._props.length; --o > -1;) n = this._props[o], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof t[n], c[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), s || c[n] !== l[0][n] && (s = c);
                                    if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? d(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, s) : p(l, e.type, c), this._segCount = this._beziers[n].length, this._timeRes) {
                                        var f = m(this._beziers, this._timeRes);
                                        this._length = f.length, this._lengths = f.lengths, this._segments = f.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                                    }
                                    if (u = this._autoRotate)
                                        for (this._initialRotations = [], u[0] instanceof Array || (this._autoRotate = u = [u]), o = u.length; --o > -1;) {
                                            for (a = 0; a < 3; a++) n = u[o][a], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                                            n = u[o][2], this._initialRotations[o] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n)
                                        }
                                    return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
                                },
                                set: function(e) {
                                    var i, n, r, o, a, s, l, c, h, u, d = this._segCount,
                                        p = this._func,
                                        f = this._target,
                                        m = e !== this._startRatio;
                                    if (this._timeRes) {
                                        if (h = this._lengths, u = this._curSeg, e *= this._length, r = this._li, e > this._l2 && r < d - 1) {
                                            for (c = d - 1; r < c && (this._l2 = h[++r]) <= e;);
                                            this._l1 = h[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0]
                                        } else if (e < this._l1 && r > 0) {
                                            for (; r > 0 && (this._l1 = h[--r]) >= e;);
                                            0 === r && e < this._l1 ? this._l1 = 0 : r++, this._l2 = h[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
                                        }
                                        if (i = r, e -= this._l1, r = this._si, e > this._s2 && r < u.length - 1) {
                                            for (c = u.length - 1; r < c && (this._s2 = u[++r]) <= e;);
                                            this._s1 = u[r - 1], this._si = r
                                        } else if (e < this._s1 && r > 0) {
                                            for (; r > 0 && (this._s1 = u[--r]) >= e;);
                                            0 === r && e < this._s1 ? this._s1 = 0 : r++, this._s2 = u[r], this._si = r
                                        }
                                        s = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                                    } else i = e < 0 ? 0 : e >= 1 ? d - 1 : d * e >> 0, s = (e - i * (1 / d)) * d;
                                    for (n = 1 - s, r = this._props.length; --r > -1;) o = this._props[r], a = this._beziers[o][i], l = (s * s * a.da + 3 * n * (s * a.ca + n * a.ba)) * s + a.a, this._mod[o] && (l = this._mod[o](l, f)), p[o] ? f[o](l) : f[o] = l;
                                    if (this._autoRotate) {
                                        var g, v, y, _, x, b, w, T = this._autoRotate;
                                        for (r = T.length; --r > -1;) o = T[r][2], b = T[r][3] || 0, w = T[r][4] === !0 ? 1 : t, a = this._beziers[T[r][0]], g = this._beziers[T[r][1]], a && g && (a = a[i], g = g[i], v = a.a + (a.b - a.a) * s, _ = a.b + (a.c - a.b) * s, v += (_ - v) * s, _ += (a.c + (a.d - a.c) * s - _) * s, y = g.a + (g.b - g.a) * s, x = g.b + (g.c - g.b) * s, y += (x - y) * s, x += (g.c + (g.d - g.c) * s - x) * s, l = m ? Math.atan2(x - y, _ - v) * w + b : this._initialRotations[r], this._mod[o] && (l = this._mod[o](l, f)), p[o] ? f[o](l) : f[o] = l)
                                    }
                                }
                            }),
                            v = g.prototype;
                        g.bezierThrough = d, g.cubicToQuadratic = c, g._autoCSS = !0, g.quadraticToCubic = function(t, e, i) {
                            return new s(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
                        }, g._cssRegister = function() {
                            var t = a.CSSPlugin;
                            if (t) {
                                var e = t._internals,
                                    i = e._parseToProxy,
                                    n = e._setPluginRatio,
                                    r = e.CSSPropTween;
                                e._registerComplexSpecialProp("bezier", {
                                    parser: function(t, e, o, a, s, l) {
                                        e instanceof Array && (e = {
                                            values: e
                                        }), l = new g;
                                        var c, h, u, d = e.values,
                                            p = d.length - 1,
                                            f = [],
                                            m = {};
                                        if (p < 0) return s;
                                        for (c = 0; c <= p; c++) u = i(t, d[c], a, s, l, p !== c), f[c] = u.end;
                                        for (h in e) m[h] = e[h];
                                        return m.values = f, s = new r(t, "bezier", 0, 0, u.pt, 2), s.data = u, s.plugin = l, s.setRatio = n, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (c = m.autoRotate === !0 ? 0 : Number(m.autoRotate), m.autoRotate = null != u.end.left ? [
                                            ["left", "top", "rotation", c, !1]
                                        ] : null != u.end.x && [
                                            ["x", "y", "rotation", c, !1]
                                        ]), m.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform, u.proxy.rotation = u.autoRotate.rotation || 0, a._overwriteProps.push("rotation")), l._onInitTween(u.proxy, m, a._tween), s
                                    }
                                })
                            }
                        }, v._mod = function(t) {
                            for (var e, i = this._overwriteProps, n = i.length; --n > -1;) e = t[i[n]], e && "function" == typeof e && (this._mod[i[n]] = e)
                        }, v._kill = function(t) {
                            var e, i, n = this._props;
                            for (e in this._beziers)
                                if (e in t)
                                    for (delete this._beziers[e], delete this._func[e], i = n.length; --i > -1;) n[i] === e && n.splice(i, 1);
                            if (n = this._autoRotate)
                                for (i = n.length; --i > -1;) t[n[i][2]] && n.splice(i, 1);
                            return this._super._kill.call(this, t)
                        }
                    }(), o._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(t, e) {
                        var i, n, r, a, s = function() {
                                t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = s.prototype.setRatio
                            },
                            l = o._gsDefine.globals,
                            c = {},
                            h = s.prototype = new t("css");
                        h.constructor = s, s.version = "1.20.5", s.API = 2, s.defaultTransformPerspective = 0, s.defaultSkewType = "compensated", s.defaultSmoothOrigin = !0, h = "px", s.suffixMap = {
                            top: h,
                            right: h,
                            bottom: h,
                            left: h,
                            width: h,
                            height: h,
                            fontSize: h,
                            padding: h,
                            margin: h,
                            perspective: h,
                            lineHeight: ""
                        };
                        var u, d, p, f, m, g, v, y, _ = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                            x = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                            b = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                            w = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                            T = /(?:\d|\-|\+|=|#|\.)*/g,
                            S = /opacity *= *([^)]*)/i,
                            M = /opacity:([^;]*)/i,
                            E = /alpha\(opacity *=.+?\)/i,
                            A = /^(rgb|hsl)/,
                            C = /([A-Z])/g,
                            P = /-([a-z])/gi,
                            R = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                            L = function(t, e) {
                                return e.toUpperCase()
                            },
                            k = /(?:Left|Right|Width)/i,
                            O = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                            D = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                            I = /,(?=[^\)]*(?:\(|$))/gi,
                            N = /[\s,\(]/i,
                            B = Math.PI / 180,
                            U = 180 / Math.PI,
                            F = {},
                            z = {
                                style: {}
                            },
                            H = o.document || {
                                createElement: function() {
                                    return z
                                }
                            },
                            j = function(t, e) {
                                return H.createElementNS ? H.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : H.createElement(t)
                            },
                            G = j("div"),
                            V = j("img"),
                            W = s._internals = {
                                _specialProps: c
                            },
                            X = (o.navigator || {}).userAgent || "",
                            q = function() {
                                var t = X.indexOf("Android"),
                                    e = j("a");
                                return p = X.indexOf("Safari") !== -1 && X.indexOf("Chrome") === -1 && (t === -1 || parseFloat(X.substr(t + 8, 2)) > 3), m = p && parseFloat(X.substr(X.indexOf("Version/") + 8, 2)) < 6, f = X.indexOf("Firefox") !== -1, (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(X) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(X)) && (g = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
                            }(),
                            $ = function(t) {
                                return S.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                            },
                            Y = function(t) {
                                o.console && console.log(t)
                            },
                            Z = "",
                            Q = "",
                            J = function(t, e) {
                                e = e || G;
                                var i, n, r = e.style;
                                if (void 0 !== r[t]) return t;
                                for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; --n > -1 && void 0 === r[i[n] + t];);
                                return n >= 0 ? (Q = 3 === n ? "ms" : i[n], Z = "-" + Q.toLowerCase() + "-", Q + t) : null
                            },
                            K = ("undefined" != typeof window ? window : H.defaultView || {
                                getComputedStyle: function() {}
                            }).getComputedStyle,
                            tt = s.getStyle = function(t, e, i, n, r) {
                                var o;
                                return q || "opacity" !== e ? (!n && t.style[e] ? o = t.style[e] : (i = i || K(t)) ? o = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(C, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]), null == r || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : r) : $(t)
                            },
                            et = W.convertToPixels = function(t, i, n, r, o) {
                                if ("px" === r || !r && "lineHeight" !== i) return n;
                                if ("auto" === r || !n) return 0;
                                var a, l, c, h = k.test(i),
                                    u = t,
                                    d = G.style,
                                    p = n < 0,
                                    f = 1 === n;
                                if (p && (n = -n), f && (n *= 100), "lineHeight" !== i || r)
                                    if ("%" === r && i.indexOf("border") !== -1) a = n / 100 * (h ? t.clientWidth : t.clientHeight);
                                    else {
                                        if (d.cssText = "border:0 solid red;position:" + tt(t, "position") + ";line-height:0;", "%" !== r && u.appendChild && "v" !== r.charAt(0) && "rem" !== r) d[h ? "borderLeftWidth" : "borderTopWidth"] = n + r;
                                        else {
                                            if (u = t.parentNode || H.body, tt(u, "display").indexOf("flex") !== -1 && (d.position = "absolute"), l = u._gsCache, c = e.ticker.frame, l && h && l.time === c) return l.width * n / 100;
                                            d[h ? "width" : "height"] = n + r
                                        }
                                        u.appendChild(G), a = parseFloat(G[h ? "offsetWidth" : "offsetHeight"]), u.removeChild(G), h && "%" === r && s.cacheWidths !== !1 && (l = u._gsCache = u._gsCache || {}, l.time = c, l.width = a / n * 100), 0 !== a || o || (a = et(t, i, n, r, !0))
                                    }
                                else l = K(t).lineHeight, t.style.lineHeight = n, a = parseFloat(K(t).lineHeight), t.style.lineHeight = l;
                                return f && (a /= 100), p ? -a : a
                            },
                            it = W.calculateOffset = function(t, e, i) {
                                if ("absolute" !== tt(t, "position", i)) return 0;
                                var n = "left" === e ? "Left" : "Top",
                                    r = tt(t, "margin" + n, i);
                                return t["offset" + n] - (et(t, e, parseFloat(r), r.replace(T, "")) || 0)
                            },
                            nt = function(t, e) {
                                var i, n, r, o = {};
                                if (e = e || K(t, null))
                                    if (i = e.length)
                                        for (; --i > -1;) r = e[i], r.indexOf("-transform") !== -1 && Rt !== r || (o[r.replace(P, L)] = e.getPropertyValue(r));
                                    else
                                        for (i in e) i.indexOf("Transform") !== -1 && Pt !== i || (o[i] = e[i]);
                                else if (e = t.currentStyle || t.style)
                                    for (i in e) "string" == typeof i && void 0 === o[i] && (o[i.replace(P, L)] = e[i]);
                                return q || (o.opacity = $(t)), n = Vt(t, e, !1), o.rotation = n.rotation, o.skewX = n.skewX, o.scaleX = n.scaleX, o.scaleY = n.scaleY, o.x = n.x, o.y = n.y, kt && (o.z = n.z, o.rotationX = n.rotationX, o.rotationY = n.rotationY, o.scaleZ = n.scaleZ), o.filters && delete o.filters, o
                            },
                            rt = function(t, e, i, n, r) {
                                var o, a, s, l = {},
                                    c = t.style;
                                for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (o = i[a]) || r && r[a]) && a.indexOf("Origin") === -1 && ("number" != typeof o && "string" != typeof o || (l[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[a] || "" === e[a].replace(w, "") ? o : 0 : it(t, a), void 0 !== c[a] && (s = new _t(c, a, c[a], s))));
                                if (n)
                                    for (a in n) "className" !== a && (l[a] = n[a]);
                                return {
                                    difs: l,
                                    firstMPT: s
                                }
                            },
                            ot = {
                                width: ["Left", "Right"],
                                height: ["Top", "Bottom"]
                            },
                            at = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                            st = function(t, e, i) {
                                if ("svg" === (t.nodeName + "").toLowerCase()) return (i || K(t))[e] || 0;
                                if (t.getCTM && Ht(t)) return t.getBBox()[e] || 0;
                                var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                                    r = ot[e],
                                    o = r.length;
                                for (i = i || K(t, null); --o > -1;) n -= parseFloat(tt(t, "padding" + r[o], i, !0)) || 0, n -= parseFloat(tt(t, "border" + r[o] + "Width", i, !0)) || 0;
                                return n
                            },
                            lt = function(t, e) {
                                if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                                null != t && "" !== t || (t = "0 0");
                                var i, n = t.split(" "),
                                    r = t.indexOf("left") !== -1 ? "0%" : t.indexOf("right") !== -1 ? "100%" : n[0],
                                    o = t.indexOf("top") !== -1 ? "0%" : t.indexOf("bottom") !== -1 ? "100%" : n[1];
                                if (n.length > 3 && !e) {
                                    for (n = t.split(", ").join(",").split(","), t = [], i = 0; i < n.length; i++) t.push(lt(n[i]));
                                    return t.join(",")
                                }
                                return null == o ? o = "center" === r ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === r || isNaN(parseFloat(r)) && (r + "").indexOf("=") === -1) && (r = "50%"), t = r + " " + o + (n.length > 2 ? " " + n[2] : ""), e && (e.oxp = r.indexOf("%") !== -1, e.oyp = o.indexOf("%") !== -1, e.oxr = "=" === r.charAt(1), e.oyr = "=" === o.charAt(1), e.ox = parseFloat(r.replace(w, "")), e.oy = parseFloat(o.replace(w, "")), e.v = t), e || t
                            },
                            ct = function(t, e) {
                                return "function" == typeof t && (t = t(y, v)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
                            },
                            ht = function(t, e) {
                                return "function" == typeof t && (t = t(y, v)), null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
                            },
                            ut = function(t, e, i, n) {
                                var r, o, a, s, l, c = 1e-6;
                                return "function" == typeof t && (t = t(y, v)), null == t ? s = e : "number" == typeof t ? s = t : (r = 360, o = t.split("_"), l = "=" === t.charAt(1), a = (l ? parseInt(t.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (t.indexOf("rad") === -1 ? 1 : U) - (l ? 0 : e), o.length && (n && (n[i] = e + a), t.indexOf("short") !== -1 && (a %= r, a !== a % (r / 2) && (a = a < 0 ? a + r : a - r)), t.indexOf("_cw") !== -1 && a < 0 ? a = (a + 9999999999 * r) % r - (a / r | 0) * r : t.indexOf("ccw") !== -1 && a > 0 && (a = (a - 9999999999 * r) % r - (a / r | 0) * r)), s = e + a), s < c && s > -c && (s = 0), s
                            },
                            dt = {
                                aqua: [0, 255, 255],
                                lime: [0, 255, 0],
                                silver: [192, 192, 192],
                                black: [0, 0, 0],
                                maroon: [128, 0, 0],
                                teal: [0, 128, 128],
                                blue: [0, 0, 255],
                                navy: [0, 0, 128],
                                white: [255, 255, 255],
                                fuchsia: [255, 0, 255],
                                olive: [128, 128, 0],
                                yellow: [255, 255, 0],
                                orange: [255, 165, 0],
                                gray: [128, 128, 128],
                                purple: [128, 0, 128],
                                green: [0, 128, 0],
                                red: [255, 0, 0],
                                pink: [255, 192, 203],
                                cyan: [0, 255, 255],
                                transparent: [255, 255, 255, 0]
                            },
                            pt = function(t, e, i) {
                                return t = t < 0 ? t + 1 : t > 1 ? t - 1 : t, 255 * (6 * t < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
                            },
                            ft = s.parseColor = function(t, e) {
                                var i, n, r, o, a, s, l, c, h, u, d;
                                if (t)
                                    if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                                    else {
                                        if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), dt[t]) i = dt[t];
                                        else if ("#" === t.charAt(0)) 4 === t.length && (n = t.charAt(1), r = t.charAt(2), o = t.charAt(3), t = "#" + n + n + r + r + o + o), t = parseInt(t.substr(1), 16), i = [t >> 16, t >> 8 & 255, 255 & t];
                                        else if ("hsl" === t.substr(0, 3))
                                            if (i = d = t.match(_), e) {
                                                if (t.indexOf("=") !== -1) return t.match(x)
                                            } else a = Number(i[0]) % 360 / 360, s = Number(i[1]) / 100, l = Number(i[2]) / 100, r = l <= .5 ? l * (s + 1) : l + s - l * s, n = 2 * l - r, i.length > 3 && (i[3] = Number(i[3])), i[0] = pt(a + 1 / 3, n, r), i[1] = pt(a, n, r), i[2] = pt(a - 1 / 3, n, r);
                                        else i = t.match(_) || dt.transparent;
                                        i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
                                    }
                                else i = dt.black;
                                return e && !d && (n = i[0] / 255, r = i[1] / 255, o = i[2] / 255, c = Math.max(n, r, o), h = Math.min(n, r, o), l = (c + h) / 2, c === h ? a = s = 0 : (u = c - h, s = l > .5 ? u / (2 - c - h) : u / (c + h), a = c === n ? (r - o) / u + (r < o ? 6 : 0) : c === r ? (o - n) / u + 2 : (n - r) / u + 4, a *= 60), i[0] = a + .5 | 0, i[1] = 100 * s + .5 | 0, i[2] = 100 * l + .5 | 0), i
                            },
                            mt = function(t, e) {
                                var i, n, r, o = t.match(gt) || [],
                                    a = 0,
                                    s = "";
                                if (!o.length) return t;
                                for (i = 0; i < o.length; i++) n = o[i], r = t.substr(a, t.indexOf(n, a) - a), a += r.length + n.length, n = ft(n, e), 3 === n.length && n.push(1), s += r + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
                                return s + t.substr(a)
                            },
                            gt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                        for (h in dt) gt += "|" + h + "\\b";
                        gt = new RegExp(gt + ")", "gi"), s.colorStringFilter = function(t) {
                            var e, i = t[0] + " " + t[1];
                            gt.test(i) && (e = i.indexOf("hsl(") !== -1 || i.indexOf("hsla(") !== -1, t[0] = mt(t[0], e), t[1] = mt(t[1], e)), gt.lastIndex = 0
                        }, e.defaultStringFilter || (e.defaultStringFilter = s.colorStringFilter);
                        var vt = function(t, e, i, n) {
                                if (null == t) return function(t) {
                                    return t
                                };
                                var r, o = e ? (t.match(gt) || [""])[0] : "",
                                    a = t.split(o).join("").match(b) || [],
                                    s = t.substr(0, t.indexOf(a[0])),
                                    l = ")" === t.charAt(t.length - 1) ? ")" : "",
                                    c = t.indexOf(" ") !== -1 ? " " : ",",
                                    h = a.length,
                                    u = h > 0 ? a[0].replace(_, "") : "";
                                return h ? r = e ? function(t) {
                                    var e, d, p, f;
                                    if ("number" == typeof t) t += u;
                                    else if (n && I.test(t)) {
                                        for (f = t.replace(I, "|").split("|"), p = 0; p < f.length; p++) f[p] = r(f[p]);
                                        return f.join(",")
                                    }
                                    if (e = (t.match(gt) || [o])[0], d = t.split(e).join("").match(b) || [], p = d.length, h > p--)
                                        for (; ++p < h;) d[p] = i ? d[(p - 1) / 2 | 0] : a[p];
                                    return s + d.join(c) + c + e + l + (t.indexOf("inset") !== -1 ? " inset" : "")
                                } : function(t) {
                                    var e, o, d;
                                    if ("number" == typeof t) t += u;
                                    else if (n && I.test(t)) {
                                        for (o = t.replace(I, "|").split("|"), d = 0; d < o.length; d++) o[d] = r(o[d]);
                                        return o.join(",")
                                    }
                                    if (e = t.match(b) || [], d = e.length, h > d--)
                                        for (; ++d < h;) e[d] = i ? e[(d - 1) / 2 | 0] : a[d];
                                    return s + e.join(c) + l
                                } : function(t) {
                                    return t
                                }
                            },
                            yt = function(t) {
                                return t = t.split(","),
                                    function(e, i, n, r, o, a, s) {
                                        var l, c = (i + "").split(" ");
                                        for (s = {}, l = 0; l < 4; l++) s[t[l]] = c[l] = c[l] || c[(l - 1) / 2 >> 0];
                                        return r.parse(e, s, o, a)
                                    }
                            },
                            _t = (W._setPluginRatio = function(t) {
                                this.plugin.setRatio(t);
                                for (var e, i, n, r, o, a = this.data, s = a.proxy, l = a.firstMPT, c = 1e-6; l;) e = s[l.v], l.r ? e = l.r(e) : e < c && e > -c && (e = 0), l.t[l.p] = e, l = l._next;
                                if (a.autoRotate && (a.autoRotate.rotation = a.mod ? a.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === t || 0 === t)
                                    for (l = a.firstMPT, o = 1 === t ? "e" : "b"; l;) {
                                        if (i = l.t, i.type) {
                                            if (1 === i.type) {
                                                for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                                                i[o] = r
                                            }
                                        } else i[o] = i.s + i.xs0;
                                        l = l._next
                                    }
                            }, function(t, e, i, n, r) {
                                this.t = t, this.p = e, this.v = i, this.r = r, n && (n._prev = this, this._next = n)
                            }),
                            xt = (W._parseToProxy = function(t, e, i, n, r, o) {
                                var a, s, l, c, h, u = n,
                                    d = {},
                                    p = {},
                                    f = i._transform,
                                    m = F;
                                for (i._transform = null, F = e, n = h = i.parse(t, e, n, r), F = m, o && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); n && n !== u;) {
                                    if (n.type <= 1 && (s = n.p, p[s] = n.s + n.c, d[s] = n.s, o || (c = new _t(n, "s", s, c, n.r), n.c = 0), 1 === n.type))
                                        for (a = n.l; --a > 0;) l = "xn" + a, s = n.p + "_" + l, p[s] = n.data[l], d[s] = n[l], o || (c = new _t(n, l, s, c, n.rxp[l]));
                                    n = n._next
                                }
                                return {
                                    proxy: d,
                                    end: p,
                                    firstMPT: c,
                                    pt: h
                                }
                            }, W.CSSPropTween = function(t, e, n, r, o, s, l, c, h, u, d) {
                                this.t = t, this.p = e, this.s = n, this.c = r, this.n = l || e, t instanceof xt || a.push(this.n), this.r = c ? "function" == typeof c ? c : Math.round : c, this.type = s || 0, h && (this.pr = h, i = !0), this.b = void 0 === u ? n : u, this.e = void 0 === d ? n + r : d, o && (this._next = o, o._prev = this)
                            }),
                            bt = function(t, e, i, n, r, o) {
                                var a = new xt(t, e, i, n - i, r, -1, o);
                                return a.b = i, a.e = a.xs0 = n, a
                            },
                            wt = s.parseComplex = function(t, e, i, n, r, o, a, l, c, h) {
                                i = i || o || "", "function" == typeof n && (n = n(y, v)), a = new xt(t, e, 0, 0, a, h ? 2 : 1, null, !1, l, i, n), n += "", r && gt.test(n + i) && (n = [i, n], s.colorStringFilter(n), i = n[0], n = n[1]);
                                var d, p, f, m, g, b, w, T, S, M, E, A, C, P = i.split(", ").join(",").split(" "),
                                    R = n.split(", ").join(",").split(" "),
                                    L = P.length,
                                    k = u !== !1;
                                for (n.indexOf(",") === -1 && i.indexOf(",") === -1 || ((n + i).indexOf("rgb") !== -1 || (n + i).indexOf("hsl") !== -1 ? (P = P.join(" ").replace(I, ", ").split(" "), R = R.join(" ").replace(I, ", ").split(" ")) : (P = P.join(" ").split(",").join(", ").split(" "), R = R.join(" ").split(",").join(", ").split(" ")), L = P.length), L !== R.length && (P = (o || "").split(" "), L = P.length), a.plugin = c, a.setRatio = h, gt.lastIndex = 0, d = 0; d < L; d++)
                                    if (m = P[d], g = R[d] + "", T = parseFloat(m), T || 0 === T) a.appendXtra("", T, ct(g, T), g.replace(x, ""), !(!k || g.indexOf("px") === -1) && Math.round, !0);
                                    else if (r && gt.test(m)) A = g.indexOf(")") + 1, A = ")" + (A ? g.substr(A) : ""), C = g.indexOf("hsl") !== -1 && q, M = g, m = ft(m, C), g = ft(g, C), S = m.length + g.length > 6, S && !q && 0 === g[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(R[d]).join("transparent")) : (q || (S = !1), C ? a.appendXtra(M.substr(0, M.indexOf("hsl")) + (S ? "hsla(" : "hsl("), m[0], ct(g[0], m[0]), ",", !1, !0).appendXtra("", m[1], ct(g[1], m[1]), "%,", !1).appendXtra("", m[2], ct(g[2], m[2]), S ? "%," : "%" + A, !1) : a.appendXtra(M.substr(0, M.indexOf("rgb")) + (S ? "rgba(" : "rgb("), m[0], g[0] - m[0], ",", Math.round, !0).appendXtra("", m[1], g[1] - m[1], ",", Math.round).appendXtra("", m[2], g[2] - m[2], S ? "," : A, Math.round), S && (m = m.length < 4 ? 1 : m[3], a.appendXtra("", m, (g.length < 4 ? 1 : g[3]) - m, A, !1))), gt.lastIndex = 0;
                                else if (b = m.match(_)) {
                                    if (w = g.match(x), !w || w.length !== b.length) return a;
                                    for (f = 0, p = 0; p < b.length; p++) E = b[p], M = m.indexOf(E, f), a.appendXtra(m.substr(f, M - f), Number(E), ct(w[p], E), "", !(!k || "px" !== m.substr(M + E.length, 2)) && Math.round, 0 === p), f = M + E.length;
                                    a["xs" + a.l] += m.substr(f)
                                } else a["xs" + a.l] += a.l || a["xs" + a.l] ? " " + g : g;
                                if (n.indexOf("=") !== -1 && a.data) {
                                    for (A = a.xs0 + a.data.s, d = 1; d < a.l; d++) A += a["xs" + d] + a.data["xn" + d];
                                    a.e = A + a["xs" + d]
                                }
                                return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                            },
                            Tt = 9;
                        for (h = xt.prototype, h.l = h.pr = 0; --Tt > 0;) h["xn" + Tt] = 0, h["xs" + Tt] = "";
                        h.xs0 = "", h._next = h._prev = h.xfirst = h.data = h.plugin = h.setRatio = h.rxp = null, h.appendXtra = function(t, e, i, n, r, o) {
                            var a = this,
                                s = a.l;
                            return a["xs" + s] += o && (s || a["xs" + s]) ? " " + t : t || "", i || 0 === s || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = n || "", s > 0 ? (a.data["xn" + s] = e + i, a.rxp["xn" + s] = r, a["xn" + s] = e, a.plugin || (a.xfirst = new xt(a, "xn" + s, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                                s: e + i
                            }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + s] += e + (n || ""), a)
                        };
                        var St = function(t, e) {
                                e = e || {}, this.p = e.prefix ? J(t) || t : t, c[t] = c[this.p] = this, this.format = e.formatter || vt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
                            },
                            Mt = W._registerComplexSpecialProp = function(t, e, i) {
                                "object" != typeof e && (e = {
                                    parser: i
                                });
                                var n, r, o = t.split(","),
                                    a = e.defaultValue;
                                for (i = i || [a], n = 0; n < o.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || a, r = new St(o[n], e)
                            },
                            Et = W._registerPluginProp = function(t) {
                                if (!c[t]) {
                                    var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                                    Mt(t, {
                                        parser: function(t, i, n, r, o, a, s) {
                                            var h = l.com.greensock.plugins[e];
                                            return h ? (h._cssRegister(), c[n].parse(t, i, n, r, o, a, s)) : (Y("Error: " + e + " js file not loaded."), o)
                                        }
                                    })
                                }
                            };
                        h = St.prototype, h.parseComplex = function(t, e, i, n, r, o) {
                            var a, s, l, c, h, u, d = this.keyword;
                            if (this.multi && (I.test(i) || I.test(e) ? (s = e.replace(I, "|").split("|"), l = i.replace(I, "|").split("|")) : d && (s = [e], l = [i])), l) {
                                for (c = l.length > s.length ? l.length : s.length, a = 0; a < c; a++) e = s[a] = s[a] || this.dflt, i = l[a] = l[a] || this.dflt, d && (h = e.indexOf(d), u = i.indexOf(d), h !== u && (u === -1 ? s[a] = s[a].split(d).join("") : h === -1 && (s[a] += " " + d)));
                                e = s.join(", "), i = l.join(", ")
                            }
                            return wt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, o)
                        }, h.parse = function(t, e, i, n, o, a, s) {
                            return this.parseComplex(t.style, this.format(tt(t, this.p, r, !1, this.dflt)), this.format(e), o, a)
                        }, s.registerSpecialProp = function(t, e, i) {
                            Mt(t, {
                                parser: function(t, n, r, o, a, s, l) {
                                    var c = new xt(t, r, 0, 0, a, 2, r, !1, i);
                                    return c.plugin = s, c.setRatio = e(t, n, o._tween, r), c
                                },
                                priority: i
                            })
                        }, s.useSVGTransformAttr = !0;
                        var At, Ct = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                            Pt = J("transform"),
                            Rt = Z + "transform",
                            Lt = J("transformOrigin"),
                            kt = null !== J("perspective"),
                            Ot = W.Transform = function() {
                                this.perspective = parseFloat(s.defaultTransformPerspective) || 0, this.force3D = !(s.defaultForce3D === !1 || !kt) && (s.defaultForce3D || "auto")
                            },
                            Dt = o.SVGElement,
                            It = function(t, e, i) {
                                var n, r = H.createElementNS("http://www.w3.org/2000/svg", t),
                                    o = /([a-z])([A-Z])/g;
                                for (n in i) r.setAttributeNS(null, n.replace(o, "$1-$2").toLowerCase(), i[n]);
                                return e.appendChild(r), r
                            },
                            Nt = H.documentElement || {},
                            Bt = function() {
                                var t, e, i, n = g || /Android/i.test(X) && !o.chrome;
                                return H.createElementNS && !n && (t = It("svg", Nt), e = It("rect", t, {
                                    width: 100,
                                    height: 50,
                                    x: 100
                                }), i = e.getBoundingClientRect().width, e.style[Lt] = "50% 50%", e.style[Pt] = "scaleX(0.5)", n = i === e.getBoundingClientRect().width && !(f && kt), Nt.removeChild(t)), n
                            }(),
                            Ut = function(t, e, i, n, r, o) {
                                var a, l, c, h, u, d, p, f, m, g, v, y, _, x, b = t._gsTransform,
                                    w = Gt(t, !0);
                                b && (_ = b.xOrigin, x = b.yOrigin), (!n || (a = n.split(" ")).length < 2) && (p = t.getBBox(), 0 === p.x && 0 === p.y && p.width + p.height === 0 && (p = {
                                    x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                                    y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                                    width: 0,
                                    height: 0
                                }), e = lt(e).split(" "), a = [(e[0].indexOf("%") !== -1 ? parseFloat(e[0]) / 100 * p.width : parseFloat(e[0])) + p.x, (e[1].indexOf("%") !== -1 ? parseFloat(e[1]) / 100 * p.height : parseFloat(e[1])) + p.y]), i.xOrigin = h = parseFloat(a[0]), i.yOrigin = u = parseFloat(a[1]), n && w !== jt && (d = w[0], p = w[1], f = w[2], m = w[3], g = w[4], v = w[5], y = d * m - p * f, y && (l = h * (m / y) + u * (-f / y) + (f * v - m * g) / y, c = h * (-p / y) + u * (d / y) - (d * v - p * g) / y, h = i.xOrigin = a[0] = l, u = i.yOrigin = a[1] = c)), b && (o && (i.xOffset = b.xOffset, i.yOffset = b.yOffset, b = i), r || r !== !1 && s.defaultSmoothOrigin !== !1 ? (l = h - _, c = u - x, b.xOffset += l * w[0] + c * w[2] - l, b.yOffset += l * w[1] + c * w[3] - c) : b.xOffset = b.yOffset = 0), o || t.setAttribute("data-svg-origin", a.join(" "))
                            },
                            Ft = function(t) {
                                var e, i = j("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                                    n = this.parentNode,
                                    r = this.nextSibling,
                                    o = this.style.cssText;
                                if (Nt.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                                    e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Ft
                                } catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox());
                                return r ? n.insertBefore(this, r) : n.appendChild(this), Nt.removeChild(i), this.style.cssText = o, e
                            },
                            zt = function(t) {
                                try {
                                    return t.getBBox()
                                } catch (e) {
                                    return Ft.call(t, !0)
                                }
                            },
                            Ht = function(t) {
                                return !(!Dt || !t.getCTM || t.parentNode && !t.ownerSVGElement || !zt(t))
                            },
                            jt = [1, 0, 0, 1, 0, 0],
                            Gt = function(t, e) {
                                var i, n, r, o, a, s, l = t._gsTransform || new Ot,
                                    c = 1e5,
                                    h = t.style;
                                if (Pt ? n = tt(t, Rt, null, !0) : t.currentStyle && (n = t.currentStyle.filter.match(O), n = n && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), l.x || 0, l.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, !Pt || !(s = !K(t) || "none" === K(t).display) && t.parentNode || (s && (o = h.display, h.display = "block"), t.parentNode || (a = 1, Nt.appendChild(t)), n = tt(t, Rt, null, !0), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, o ? h.display = o : s && $t(h, "display"), a && Nt.removeChild(t)), (l.svg || t.getCTM && Ht(t)) && (i && (h[Pt] + "").indexOf("matrix") !== -1 && (n = h[Pt], i = 0), r = t.getAttribute("transform"), i && r && (r = t.transform.baseVal.consolidate().matrix, n = "matrix(" + r.a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", i = 0)), i) return jt;
                                for (r = (n || "").match(_) || [], Tt = r.length; --Tt > -1;) o = Number(r[Tt]), r[Tt] = (a = o - (o |= 0)) ? (a * c + (a < 0 ? -.5 : .5) | 0) / c + o : o;
                                return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
                            },
                            Vt = W.getTransform = function(t, i, n, r) {
                                if (t._gsTransform && n && !r) return t._gsTransform;
                                var o, a, l, c, h, u, d = n ? t._gsTransform || new Ot : new Ot,
                                    p = d.scaleX < 0,
                                    f = 2e-5,
                                    m = 1e5,
                                    g = kt ? parseFloat(tt(t, Lt, i, !1, "0 0 0").split(" ")[2]) || d.zOrigin || 0 : 0,
                                    v = parseFloat(s.defaultTransformPerspective) || 0;
                                if (d.svg = !(!t.getCTM || !Ht(t)), d.svg && (Ut(t, tt(t, Lt, i, !1, "50% 50%") + "", d, t.getAttribute("data-svg-origin")), At = s.useSVGTransformAttr || Bt), o = Gt(t), o !== jt) {
                                    if (16 === o.length) {
                                        var y, _, x, b, w, T = o[0],
                                            S = o[1],
                                            M = o[2],
                                            E = o[3],
                                            A = o[4],
                                            C = o[5],
                                            P = o[6],
                                            R = o[7],
                                            L = o[8],
                                            k = o[9],
                                            O = o[10],
                                            D = o[12],
                                            I = o[13],
                                            N = o[14],
                                            B = o[11],
                                            F = Math.atan2(P, O);
                                        d.zOrigin && (N = -d.zOrigin, D = L * N - o[12], I = k * N - o[13], N = O * N + d.zOrigin - o[14]), d.rotationX = F * U, F && (b = Math.cos(-F), w = Math.sin(-F), y = A * b + L * w, _ = C * b + k * w, x = P * b + O * w, L = A * -w + L * b, k = C * -w + k * b, O = P * -w + O * b, B = R * -w + B * b, A = y, C = _, P = x), F = Math.atan2(-M, O), d.rotationY = F * U, F && (b = Math.cos(-F), w = Math.sin(-F), y = T * b - L * w, _ = S * b - k * w, x = M * b - O * w, k = S * w + k * b, O = M * w + O * b, B = E * w + B * b, T = y, S = _, M = x), F = Math.atan2(S, T), d.rotation = F * U, F && (b = Math.cos(F), w = Math.sin(F), y = T * b + S * w, _ = A * b + C * w, x = L * b + k * w, S = S * b - T * w, C = C * b - A * w, k = k * b - L * w, T = y, A = _, L = x), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), F = Math.atan2(A, C), d.scaleX = (Math.sqrt(T * T + S * S + M * M) * m + .5 | 0) / m, d.scaleY = (Math.sqrt(C * C + P * P) * m + .5 | 0) / m, d.scaleZ = (Math.sqrt(L * L + k * k + O * O) * m + .5 | 0) / m, T /= d.scaleX, A /= d.scaleY, S /= d.scaleX, C /= d.scaleY, Math.abs(F) > f ? (d.skewX = F * U, A = 0, "simple" !== d.skewType && (d.scaleY *= 1 / Math.cos(F))) : d.skewX = 0, d.perspective = B ? 1 / (B < 0 ? -B : B) : 0, d.x = D, d.y = I, d.z = N, d.svg && (d.x -= d.xOrigin - (d.xOrigin * T - d.yOrigin * A), d.y -= d.yOrigin - (d.yOrigin * S - d.xOrigin * C))
                                    } else if (!kt || r || !o.length || d.x !== o[4] || d.y !== o[5] || !d.rotationX && !d.rotationY) {
                                        var z = o.length >= 6,
                                            H = z ? o[0] : 1,
                                            j = o[1] || 0,
                                            G = o[2] || 0,
                                            V = z ? o[3] : 1;
                                        d.x = o[4] || 0, d.y = o[5] || 0, l = Math.sqrt(H * H + j * j), c = Math.sqrt(V * V + G * G), h = H || j ? Math.atan2(j, H) * U : d.rotation || 0, u = G || V ? Math.atan2(G, V) * U + h : d.skewX || 0, d.scaleX = l, d.scaleY = c, d.rotation = h, d.skewX = u, kt && (d.rotationX = d.rotationY = d.z = 0, d.perspective = v, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * H + d.yOrigin * G), d.y -= d.yOrigin - (d.xOrigin * j + d.yOrigin * V))
                                    }
                                    Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (p ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180)), d.zOrigin = g;
                                    for (a in d) d[a] < f && d[a] > -f && (d[a] = 0)
                                }
                                return n && (t._gsTransform = d, d.svg && (At && t.style[Pt] ? e.delayedCall(.001, function() {
                                    $t(t.style, Pt)
                                }) : !At && t.getAttribute("transform") && e.delayedCall(.001, function() {
                                    t.removeAttribute("transform")
                                }))), d
                            },
                            Wt = function(t) {
                                var e, i, n = this.data,
                                    r = -n.rotation * B,
                                    o = r + n.skewX * B,
                                    a = 1e5,
                                    s = (Math.cos(r) * n.scaleX * a | 0) / a,
                                    l = (Math.sin(r) * n.scaleX * a | 0) / a,
                                    c = (Math.sin(o) * -n.scaleY * a | 0) / a,
                                    h = (Math.cos(o) * n.scaleY * a | 0) / a,
                                    u = this.t.style,
                                    d = this.t.currentStyle;
                                if (d) {
                                    i = l, l = -c, c = -i, e = d.filter, u.filter = "";
                                    var p, f, m = this.t.offsetWidth,
                                        v = this.t.offsetHeight,
                                        y = "absolute" !== d.position,
                                        _ = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + l + ", M21=" + c + ", M22=" + h,
                                        x = n.x + m * n.xPercent / 100,
                                        b = n.y + v * n.yPercent / 100;
                                    if (null != n.ox && (p = (n.oxp ? m * n.ox * .01 : n.ox) - m / 2, f = (n.oyp ? v * n.oy * .01 : n.oy) - v / 2, x += p - (p * s + f * l), b += f - (p * c + f * h)), y ? (p = m / 2, f = v / 2, _ += ", Dx=" + (p - (p * s + f * l) + x) + ", Dy=" + (f - (p * c + f * h) + b) + ")") : _ += ", sizingMethod='auto expand')", e.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1 ? u.filter = e.replace(D, _) : u.filter = _ + " " + e, 0 !== t && 1 !== t || 1 === s && 0 === l && 0 === c && 1 === h && (y && _.indexOf("Dx=0, Dy=0") === -1 || S.test(e) && 100 !== parseFloat(RegExp.$1) || e.indexOf(e.indexOf("Alpha")) === -1 && u.removeAttribute("filter")), !y) {
                                        var w, M, E, A = g < 8 ? 1 : -1;
                                        for (p = n.ieOffsetX || 0, f = n.ieOffsetY || 0, n.ieOffsetX = Math.round((m - ((s < 0 ? -s : s) * m + (l < 0 ? -l : l) * v)) / 2 + x), n.ieOffsetY = Math.round((v - ((h < 0 ? -h : h) * v + (c < 0 ? -c : c) * m)) / 2 + b), Tt = 0; Tt < 4; Tt++) M = at[Tt], w = d[M], i = w.indexOf("px") !== -1 ? parseFloat(w) : et(this.t, M, parseFloat(w), w.replace(T, "")) || 0, E = i !== n[M] ? Tt < 2 ? -n.ieOffsetX : -n.ieOffsetY : Tt < 2 ? p - n.ieOffsetX : f - n.ieOffsetY, u[M] = (n[M] = Math.round(i - E * (0 === Tt || 2 === Tt ? 1 : A))) + "px"
                                    }
                                }
                            },
                            Xt = W.set3DTransformRatio = W.setTransformRatio = function(t) {
                                var e, i, n, r, o, a, s, l, c, h, u, d, p, m, g, v, y, _, x, b, w, T, S, M = this.data,
                                    E = this.t.style,
                                    A = M.rotation,
                                    C = M.rotationX,
                                    P = M.rotationY,
                                    R = M.scaleX,
                                    L = M.scaleY,
                                    k = M.scaleZ,
                                    O = M.x,
                                    D = M.y,
                                    I = M.z,
                                    N = M.svg,
                                    U = M.perspective,
                                    F = M.force3D,
                                    z = M.skewY,
                                    H = M.skewX;
                                if (z && (H += z, A += z), ((1 === t || 0 === t) && "auto" === F && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !F) && !I && !U && !P && !C && 1 === k || At && N || !kt) return void(A || H || N ? (A *= B, T = H * B, S = 1e5, i = Math.cos(A) * R, o = Math.sin(A) * R, n = Math.sin(A - T) * -L, a = Math.cos(A - T) * L, T && "simple" === M.skewType && (e = Math.tan(T - z * B), e = Math.sqrt(1 + e * e), n *= e, a *= e, z && (e = Math.tan(z * B), e = Math.sqrt(1 + e * e), i *= e, o *= e)), N && (O += M.xOrigin - (M.xOrigin * i + M.yOrigin * n) + M.xOffset, D += M.yOrigin - (M.xOrigin * o + M.yOrigin * a) + M.yOffset, At && (M.xPercent || M.yPercent) && (g = this.t.getBBox(), O += .01 * M.xPercent * g.width, D += .01 * M.yPercent * g.height), g = 1e-6, O < g && O > -g && (O = 0), D < g && D > -g && (D = 0)), x = (i * S | 0) / S + "," + (o * S | 0) / S + "," + (n * S | 0) / S + "," + (a * S | 0) / S + "," + O + "," + D + ")", N && At ? this.t.setAttribute("transform", "matrix(" + x) : E[Pt] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix(" : "matrix(") + x) : E[Pt] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix(" : "matrix(") + R + ",0,0," + L + "," + O + "," + D + ")");
                                if (f && (g = 1e-4, R < g && R > -g && (R = k = 2e-5), L < g && L > -g && (L = k = 2e-5), !U || M.z || M.rotationX || M.rotationY || (U = 0)), A || H) A *= B, v = i = Math.cos(A), y = o = Math.sin(A), H && (A -= H * B, v = Math.cos(A), y = Math.sin(A), "simple" === M.skewType && (e = Math.tan((H - z) * B), e = Math.sqrt(1 + e * e), v *= e, y *= e, M.skewY && (e = Math.tan(z * B), e = Math.sqrt(1 + e * e), i *= e, o *= e))), n = -y, a = v;
                                else {
                                    if (!(P || C || 1 !== k || U || N)) return void(E[Pt] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) translate3d(" : "translate3d(") + O + "px," + D + "px," + I + "px)" + (1 !== R || 1 !== L ? " scale(" + R + "," + L + ")" : ""));
                                    i = a = 1, n = o = 0
                                }
                                h = 1, r = s = l = c = u = d = 0, p = U ? -1 / U : 0, m = M.zOrigin, g = 1e-6, b = ",", w = "0", A = P * B, A && (v = Math.cos(A), y = Math.sin(A), l = -y, u = p * -y, r = i * y, s = o * y, h = v, p *= v, i *= v, o *= v), A = C * B, A && (v = Math.cos(A), y = Math.sin(A), e = n * v + r * y, _ = a * v + s * y, c = h * y, d = p * y, r = n * -y + r * v, s = a * -y + s * v, h *= v, p *= v, n = e, a = _), 1 !== k && (r *= k, s *= k, h *= k, p *= k), 1 !== L && (n *= L, a *= L, c *= L, d *= L), 1 !== R && (i *= R, o *= R, l *= R, u *= R), (m || N) && (m && (O += r * -m, D += s * -m, I += h * -m + m), N && (O += M.xOrigin - (M.xOrigin * i + M.yOrigin * n) + M.xOffset, D += M.yOrigin - (M.xOrigin * o + M.yOrigin * a) + M.yOffset), O < g && O > -g && (O = w), D < g && D > -g && (D = w), I < g && I > -g && (I = 0)), x = M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix3d(" : "matrix3d(", x += (i < g && i > -g ? w : i) + b + (o < g && o > -g ? w : o) + b + (l < g && l > -g ? w : l), x += b + (u < g && u > -g ? w : u) + b + (n < g && n > -g ? w : n) + b + (a < g && a > -g ? w : a), C || P || 1 !== k ? (x += b + (c < g && c > -g ? w : c) + b + (d < g && d > -g ? w : d) + b + (r < g && r > -g ? w : r), x += b + (s < g && s > -g ? w : s) + b + (h < g && h > -g ? w : h) + b + (p < g && p > -g ? w : p) + b) : x += ",0,0,0,0,1,0,", x += O + b + D + b + I + b + (U ? 1 + -I / U : 1) + ")", E[Pt] = x
                            };
                        h = Ot.prototype, h.x = h.y = h.z = h.skewX = h.skewY = h.rotation = h.rotationX = h.rotationY = h.zOrigin = h.xPercent = h.yPercent = h.xOffset = h.yOffset = 0, h.scaleX = h.scaleY = h.scaleZ = 1, Mt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                            parser: function(t, e, i, n, o, a, l) {
                                if (n._lastParsedTransform === l) return o;
                                n._lastParsedTransform = l;
                                var c, h = l.scale && "function" == typeof l.scale ? l.scale : 0;
                                "function" == typeof l[i] && (c = l[i], l[i] = e), h && (l.scale = h(y, t));
                                var u, d, p, f, m, g, _, x, b, w = t._gsTransform,
                                    T = t.style,
                                    S = 1e-6,
                                    M = Ct.length,
                                    E = l,
                                    A = {},
                                    C = "transformOrigin",
                                    P = Vt(t, r, !0, E.parseTransform),
                                    R = E.transform && ("function" == typeof E.transform ? E.transform(y, v) : E.transform);
                                if (P.skewType = E.skewType || P.skewType || s.defaultSkewType, n._transform = P, R && "string" == typeof R && Pt) d = G.style, d[Pt] = R, d.display = "block", d.position = "absolute", R.indexOf("%") !== -1 && (d.width = tt(t, "width"), d.height = tt(t, "height")), H.body.appendChild(G), u = Vt(G, null, !1), "simple" === P.skewType && (u.scaleY *= Math.cos(u.skewX * B)), P.svg && (g = P.xOrigin, _ = P.yOrigin, u.x -= P.xOffset, u.y -= P.yOffset, (E.transformOrigin || E.svgOrigin) && (R = {}, Ut(t, lt(E.transformOrigin), R, E.svgOrigin, E.smoothOrigin, !0), g = R.xOrigin, _ = R.yOrigin, u.x -= R.xOffset - P.xOffset, u.y -= R.yOffset - P.yOffset), (g || _) && (x = Gt(G, !0), u.x -= g - (g * x[0] + _ * x[2]), u.y -= _ - (g * x[1] + _ * x[3]))), H.body.removeChild(G), u.perspective || (u.perspective = P.perspective), null != E.xPercent && (u.xPercent = ht(E.xPercent, P.xPercent)), null != E.yPercent && (u.yPercent = ht(E.yPercent, P.yPercent));
                                else if ("object" == typeof E) {
                                    if (u = {
                                            scaleX: ht(null != E.scaleX ? E.scaleX : E.scale, P.scaleX),
                                            scaleY: ht(null != E.scaleY ? E.scaleY : E.scale, P.scaleY),
                                            scaleZ: ht(E.scaleZ, P.scaleZ),
                                            x: ht(E.x, P.x),
                                            y: ht(E.y, P.y),
                                            z: ht(E.z, P.z),
                                            xPercent: ht(E.xPercent, P.xPercent),
                                            yPercent: ht(E.yPercent, P.yPercent),
                                            perspective: ht(E.transformPerspective, P.perspective)
                                        }, m = E.directionalRotation, null != m)
                                        if ("object" == typeof m)
                                            for (d in m) E[d] = m[d];
                                        else E.rotation = m;
                                    "string" == typeof E.x && E.x.indexOf("%") !== -1 && (u.x = 0, u.xPercent = ht(E.x, P.xPercent)), "string" == typeof E.y && E.y.indexOf("%") !== -1 && (u.y = 0, u.yPercent = ht(E.y, P.yPercent)), u.rotation = ut("rotation" in E ? E.rotation : "shortRotation" in E ? E.shortRotation + "_short" : "rotationZ" in E ? E.rotationZ : P.rotation, P.rotation, "rotation", A), kt && (u.rotationX = ut("rotationX" in E ? E.rotationX : "shortRotationX" in E ? E.shortRotationX + "_short" : P.rotationX || 0, P.rotationX, "rotationX", A), u.rotationY = ut("rotationY" in E ? E.rotationY : "shortRotationY" in E ? E.shortRotationY + "_short" : P.rotationY || 0, P.rotationY, "rotationY", A)), u.skewX = ut(E.skewX, P.skewX), u.skewY = ut(E.skewY, P.skewY)
                                }
                                for (kt && null != E.force3D && (P.force3D = E.force3D, f = !0), p = P.force3D || P.z || P.rotationX || P.rotationY || u.z || u.rotationX || u.rotationY || u.perspective, p || null == E.scale || (u.scaleZ = 1); --M > -1;) b = Ct[M], R = u[b] - P[b], (R > S || R < -S || null != E[b] || null != F[b]) && (f = !0, o = new xt(P, b, P[b], R, o), b in A && (o.e = A[b]), o.xs0 = 0, o.plugin = a, n._overwriteProps.push(o.n));
                                return R = E.transformOrigin, P.svg && (R || E.svgOrigin) && (g = P.xOffset, _ = P.yOffset, Ut(t, lt(R), u, E.svgOrigin, E.smoothOrigin), o = bt(P, "xOrigin", (w ? P : u).xOrigin, u.xOrigin, o, C), o = bt(P, "yOrigin", (w ? P : u).yOrigin, u.yOrigin, o, C), g === P.xOffset && _ === P.yOffset || (o = bt(P, "xOffset", w ? g : P.xOffset, P.xOffset, o, C), o = bt(P, "yOffset", w ? _ : P.yOffset, P.yOffset, o, C)), R = "0px 0px"), (R || kt && p && P.zOrigin) && (Pt ? (f = !0, b = Lt, R = (R || tt(t, b, r, !1, "50% 50%")) + "", o = new xt(T, b, 0, 0, o, -1, C), o.b = T[b], o.plugin = a, kt ? (d = P.zOrigin, R = R.split(" "), P.zOrigin = (R.length > 2 && (0 === d || "0px" !== R[2]) ? parseFloat(R[2]) : d) || 0, o.xs0 = o.e = R[0] + " " + (R[1] || "50%") + " 0px", o = new xt(P, "zOrigin", 0, 0, o, -1, o.n), o.b = d, o.xs0 = o.e = P.zOrigin) : o.xs0 = o.e = R) : lt(R + "", P)), f && (n._transformType = P.svg && At || !p && 3 !== this._transformType ? 2 : 3), c && (l[i] = c), h && (l.scale = h), o
                            },
                            prefix: !0
                        }), Mt("boxShadow", {
                            defaultValue: "0px 0px 0px 0px #999",
                            prefix: !0,
                            color: !0,
                            multi: !0,
                            keyword: "inset"
                        }), Mt("borderRadius", {
                            defaultValue: "0px",
                            parser: function(t, e, i, o, a, s) {
                                e = this.format(e);
                                var l, c, h, u, d, p, f, m, g, v, y, _, x, b, w, T, S = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                    M = t.style;
                                for (g = parseFloat(t.offsetWidth), v = parseFloat(t.offsetHeight), l = e.split(" "), c = 0; c < S.length; c++) this.p.indexOf("border") && (S[c] = J(S[c])), d = u = tt(t, S[c], r, !1, "0px"), d.indexOf(" ") !== -1 && (u = d.split(" "), d = u[0], u = u[1]), p = h = l[c], f = parseFloat(d), _ = d.substr((f + "").length), x = "=" === p.charAt(1), x ? (m = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), m *= parseFloat(p), y = p.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(p), y = p.substr((m + "").length)), "" === y && (y = n[i] || _), y !== _ && (b = et(t, "borderLeft", f, _), w = et(t, "borderTop", f, _), "%" === y ? (d = b / g * 100 + "%", u = w / v * 100 + "%") : "em" === y ? (T = et(t, "borderLeft", 1, "em"), d = b / T + "em", u = w / T + "em") : (d = b + "px", u = w + "px"), x && (p = parseFloat(d) + m + y, h = parseFloat(u) + m + y)), a = wt(M, S[c], d + " " + u, p + " " + h, !1, "0px", a);
                                return a
                            },
                            prefix: !0,
                            formatter: vt("0px 0px 0px 0px", !1, !0)
                        }), Mt("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                            defaultValue: "0px",
                            parser: function(t, e, i, n, o, a) {
                                return wt(t.style, i, this.format(tt(t, i, r, !1, "0px 0px")), this.format(e), !1, "0px", o)
                            },
                            prefix: !0,
                            formatter: vt("0px 0px", !1, !0)
                        }), Mt("backgroundPosition", {
                            defaultValue: "0 0",
                            parser: function(t, e, i, n, o, a) {
                                var s, l, c, h, u, d, p = "background-position",
                                    f = r || K(t, null),
                                    m = this.format((f ? g ? f.getPropertyValue(p + "-x") + " " + f.getPropertyValue(p + "-y") : f.getPropertyValue(p) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                                    v = this.format(e);
                                if (m.indexOf("%") !== -1 != (v.indexOf("%") !== -1) && v.split(",").length < 2 && (d = tt(t, "backgroundImage").replace(R, ""), d && "none" !== d)) {
                                    for (s = m.split(" "), l = v.split(" "), V.setAttribute("src", d), c = 2; --c > -1;) m = s[c], h = m.indexOf("%") !== -1, h !== (l[c].indexOf("%") !== -1) && (u = 0 === c ? t.offsetWidth - V.width : t.offsetHeight - V.height, s[c] = h ? parseFloat(m) / 100 * u + "px" : parseFloat(m) / u * 100 + "%");
                                    m = s.join(" ")
                                }
                                return this.parseComplex(t.style, m, v, o, a)
                            },
                            formatter: lt
                        }), Mt("backgroundSize", {
                            defaultValue: "0 0",
                            formatter: function(t) {
                                return t += "", "co" === t.substr(0, 2) ? t : lt(t.indexOf(" ") === -1 ? t + " " + t : t)
                            }
                        }), Mt("perspective", {
                            defaultValue: "0px",
                            prefix: !0
                        }), Mt("perspectiveOrigin", {
                            defaultValue: "50% 50%",
                            prefix: !0
                        }), Mt("transformStyle", {
                            prefix: !0
                        }), Mt("backfaceVisibility", {
                            prefix: !0
                        }), Mt("userSelect", {
                            prefix: !0
                        }), Mt("margin", {
                            parser: yt("marginTop,marginRight,marginBottom,marginLeft")
                        }), Mt("padding", {
                            parser: yt("paddingTop,paddingRight,paddingBottom,paddingLeft")
                        }), Mt("clip", {
                            defaultValue: "rect(0px,0px,0px,0px)",
                            parser: function(t, e, i, n, o, a) {
                                var s, l, c;
                                return g < 9 ? (l = t.currentStyle, c = g < 8 ? " " : ",", s = "rect(" + l.clipTop + c + l.clipRight + c + l.clipBottom + c + l.clipLeft + ")", e = this.format(e).split(",").join(c)) : (s = this.format(tt(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, s, e, o, a)
                            }
                        }), Mt("textShadow", {
                            defaultValue: "0px 0px 0px #999",
                            color: !0,
                            multi: !0
                        }), Mt("autoRound,strictUnits", {
                            parser: function(t, e, i, n, r) {
                                return r
                            }
                        }), Mt("border", {
                            defaultValue: "0px solid #000",
                            parser: function(t, e, i, n, o, a) {
                                var s = tt(t, "borderTopWidth", r, !1, "0px"),
                                    l = this.format(e).split(" "),
                                    c = l[0].replace(T, "");
                                return "px" !== c && (s = parseFloat(s) / et(t, "borderTopWidth", 1, c) + c), this.parseComplex(t.style, this.format(s + " " + tt(t, "borderTopStyle", r, !1, "solid") + " " + tt(t, "borderTopColor", r, !1, "#000")), l.join(" "), o, a)
                            },
                            color: !0,
                            formatter: function(t) {
                                var e = t.split(" ");
                                return e[0] + " " + (e[1] || "solid") + " " + (t.match(gt) || ["#000"])[0]
                            }
                        }), Mt("borderWidth", {
                            parser: yt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                        }), Mt("float,cssFloat,styleFloat", {
                            parser: function(t, e, i, n, r, o) {
                                var a = t.style,
                                    s = "cssFloat" in a ? "cssFloat" : "styleFloat";
                                return new xt(a, s, 0, 0, r, -1, i, !1, 0, a[s], e)
                            }
                        });
                        var qt = function(t) {
                            var e, i = this.t,
                                n = i.filter || tt(this.data, "filter") || "",
                                r = this.s + this.c * t | 0;
                            100 === r && (n.indexOf("atrix(") === -1 && n.indexOf("radient(") === -1 && n.indexOf("oader(") === -1 ? (i.removeAttribute("filter"), e = !tt(this.data, "filter")) : (i.filter = n.replace(E, ""), e = !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), n.indexOf("pacity") === -1 ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(S, "opacity=" + r))
                        };
                        Mt("opacity,alpha,autoAlpha", {
                            defaultValue: "1",
                            parser: function(t, e, i, n, o, a) {
                                var s = parseFloat(tt(t, "opacity", r, !1, "1")),
                                    l = t.style,
                                    c = "autoAlpha" === i;
                                return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + s), c && 1 === s && "hidden" === tt(t, "visibility", r) && 0 !== e && (s = 0), q ? o = new xt(l, "opacity", s, e - s, o) : (o = new xt(l, "opacity", 100 * s, 100 * (e - s), o), o.xn1 = c ? 1 : 0, l.zoom = 1, o.type = 2, o.b = "alpha(opacity=" + o.s + ")", o.e = "alpha(opacity=" + (o.s + o.c) + ")", o.data = t, o.plugin = a, o.setRatio = qt), c && (o = new xt(l, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), o.xs0 = "inherit", n._overwriteProps.push(o.n), n._overwriteProps.push(i)), o
                            }
                        });
                        var $t = function(t, e) {
                                e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(C, "-$1").toLowerCase())) : t.removeAttribute(e))
                            },
                            Yt = function(t) {
                                if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                                    this.t.setAttribute("class", 0 === t ? this.b : this.e);
                                    for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : $t(i, e.p), e = e._next;
                                    1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                            };
                        Mt("className", {
                            parser: function(t, e, n, o, a, s, l) {
                                var c, h, u, d, p, f = t.getAttribute("class") || "",
                                    m = t.style.cssText;
                                if (a = o._classNamePT = new xt(t, n, 0, 0, a, 2), a.setRatio = Yt, a.pr = -11, i = !0, a.b = f, h = nt(t, r), u = t._gsClassPT) {
                                    for (d = {}, p = u.data; p;) d[p.p] = 1, p = p._next;
                                    u.setRatio(1)
                                }
                                return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : f.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", a.e), c = rt(t, h, nt(t), l, d), t.setAttribute("class", f), a.data = c.firstMPT, t.style.cssText = m, a = a.xfirst = o.parse(t, c.difs, a, s)
                            }
                        });
                        var Zt = function(t) {
                            if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                                var e, i, n, r, o, a = this.t.style,
                                    s = c.transform.parse;
                                if ("all" === this.e) a.cssText = "", r = !0;
                                else
                                    for (e = this.e.split(" ").join("").split(","), n = e.length; --n > -1;) i = e[n], c[i] && (c[i].parse === s ? r = !0 : i = "transformOrigin" === i ? Lt : c[i].p), $t(a, i);
                                r && ($t(a, Pt), o = this.t._gsTransform, o && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                            }
                        };
                        for (Mt("clearProps", {
                                parser: function(t, e, n, r, o) {
                                    return o = new xt(t, n, 0, 0, o, 2), o.setRatio = Zt, o.e = e, o.pr = -10, o.data = r._tween, i = !0, o
                                }
                            }), h = "bezier,throwProps,physicsProps,physics2D".split(","), Tt = h.length; Tt--;) Et(h[Tt]);
                        h = s.prototype, h._firstPT = h._lastParsedTransform = h._transform = null, h._onInitTween = function(t, e, o, l) {
                            if (!t.nodeType) return !1;
                            this._target = v = t, this._tween = o, this._vars = e, y = l, u = e.autoRound, i = !1, n = e.suffixMap || s.suffixMap, r = K(t, ""), a = this._overwriteProps;
                            var h, f, g, _, x, b, w, T, S, E = t.style;
                            if (d && "" === E.zIndex && (h = tt(t, "zIndex", r), "auto" !== h && "" !== h || this._addLazySet(E, "zIndex", 0)), "string" == typeof e && (_ = E.cssText, h = nt(t, r), E.cssText = _ + ";" + e, h = rt(t, h, nt(t)).difs, !q && M.test(e) && (h.opacity = parseFloat(RegExp.$1)), e = h, E.cssText = _), e.className ? this._firstPT = f = c.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = f = this.parse(t, e, null), this._transformType) {
                                for (S = 3 === this._transformType, Pt ? p && (d = !0, "" === E.zIndex && (w = tt(t, "zIndex", r), "auto" !== w && "" !== w || this._addLazySet(E, "zIndex", 0)), m && this._addLazySet(E, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (S ? "visible" : "hidden"))) : E.zoom = 1, g = f; g && g._next;) g = g._next;
                                T = new xt(t, "transform", 0, 0, null, 2), this._linkCSSP(T, null, g), T.setRatio = Pt ? Xt : Wt, T.data = this._transform || Vt(t, r, !0), T.tween = o, T.pr = -1, a.pop()
                            }
                            if (i) {
                                for (; f;) {
                                    for (b = f._next, g = _; g && g.pr > f.pr;) g = g._next;
                                    (f._prev = g ? g._prev : x) ? f._prev._next = f: _ = f, (f._next = g) ? g._prev = f : x = f, f = b
                                }
                                this._firstPT = _
                            }
                            return !0
                        }, h.parse = function(t, e, i, o) {
                            var a, s, l, h, d, p, f, m, g, _, x = t.style;
                            for (a in e) {
                                if (p = e[a], "function" == typeof p && (p = p(y, v)), s = c[a]) i = s.parse(t, p, a, this, i, o, e);
                                else {
                                    if ("--" === a.substr(0, 2)) {
                                        this._tween._propLookup[a] = this._addTween.call(this._tween, t.style, "setProperty", K(t).getPropertyValue(a) + "", p + "", a, !1, a);
                                        continue
                                    }
                                    d = tt(t, a, r) + "", g = "string" == typeof p, "color" === a || "fill" === a || "stroke" === a || a.indexOf("Color") !== -1 || g && A.test(p) ? (g || (p = ft(p), p = (p.length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), i = wt(x, a, d, p, !0, "transparent", i, 0, o)) : g && N.test(p) ? i = wt(x, a, d, p, !0, null, i, 0, o) : (l = parseFloat(d), f = l || 0 === l ? d.substr((l + "").length) : "", "" !== d && "auto" !== d || ("width" === a || "height" === a ? (l = st(t, a, r), f = "px") : "left" === a || "top" === a ? (l = it(t, a, r), f = "px") : (l = "opacity" !== a ? 0 : 1, f = "")), _ = g && "=" === p.charAt(1), _ ? (h = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), h *= parseFloat(p), m = p.replace(T, "")) : (h = parseFloat(p), m = g ? p.replace(T, "") : ""), "" === m && (m = a in n ? n[a] : f), p = h || 0 === h ? (_ ? h + l : h) + m : e[a], f !== m && ("" === m && "lineHeight" !== a || (h || 0 === h) && l && (l = et(t, a, l, f), "%" === m ? (l /= et(t, a, 100, "%") / 100, e.strictUnits !== !0 && (d = l + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? l /= et(t, a, 1, m) : "px" !== m && (h = et(t, a, h, m), m = "px"), _ && (h || 0 === h) && (p = h + l + m))), _ && (h += l), !l && 0 !== l || !h && 0 !== h ? void 0 !== x[a] && (p || p + "" != "NaN" && null != p) ? (i = new xt(x, a, h || l || 0, 0, i, -1, a, !1, 0, d, p), i.xs0 = "none" !== p || "display" !== a && a.indexOf("Style") === -1 ? p : d) : Y("invalid " + a + " tween value: " + e[a]) : (i = new xt(x, a, l, h - l, i, 0, a, u !== !1 && ("px" === m || "zIndex" === a), 0, d, p), i.xs0 = m))
                                }
                                o && i && !i.plugin && (i.plugin = o)
                            }
                            return i
                        }, h.setRatio = function(t) {
                            var e, i, n, r = this._firstPT,
                                o = 1e-6;
                            if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                                if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
                                    for (; r;) {
                                        if (e = r.c * t + r.s, r.r ? e = r.r(e) : e < o && e > -o && (e = 0), r.type)
                                            if (1 === r.type)
                                                if (n = r.l, 2 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                                else if (3 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                                        else if (4 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                                        else if (5 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                                        else {
                                            for (i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                            r.t[r.p] = i
                                        } else r.type === -1 ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                                        else r.t[r.p] = e + r.xs0;
                                        r = r._next
                                    } else
                                        for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                                else
                                    for (; r;) {
                                        if (2 !== r.type)
                                            if (r.r && r.type !== -1)
                                                if (e = r.r(r.s + r.c), r.type) {
                                                    if (1 === r.type) {
                                                        for (n = r.l, i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                                        r.t[r.p] = i
                                                    }
                                                } else r.t[r.p] = e + r.xs0;
                                        else r.t[r.p] = r.e;
                                        else r.setRatio(t);
                                        r = r._next
                                    }
                        }, h._enableTransforms = function(t) {
                            this._transform = this._transform || Vt(this._target, r, !0), this._transformType = this._transform.svg && At || !t && 3 !== this._transformType ? 2 : 3
                        };
                        var Qt = function(t) {
                            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                        };
                        h._addLazySet = function(t, e, i) {
                            var n = this._firstPT = new xt(t, e, 0, 0, this._firstPT, 2);
                            n.e = i, n.setRatio = Qt, n.data = this
                        }, h._linkCSSP = function(t, e, i, n) {
                            return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
                        }, h._mod = function(t) {
                            for (var e = this._firstPT; e;) "function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next
                        }, h._kill = function(e) {
                            var i, n, r, o = e;
                            if (e.autoAlpha || e.alpha) {
                                o = {};
                                for (n in e) o[n] = e[n];
                                o.opacity = 1, o.autoAlpha && (o.visibility = 1)
                            }
                            for (e.className && (i = this._classNamePT) && (r = i.xfirst, r && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), i = this._firstPT; i;) i.plugin && i.plugin !== n && i.plugin._kill && (i.plugin._kill(e), n = i.plugin), i = i._next;
                            return t.prototype._kill.call(this, o)
                        };
                        var Jt = function(t, e, i) {
                            var n, r, o, a;
                            if (t.slice)
                                for (r = t.length; --r > -1;) Jt(t[r], e, i);
                            else
                                for (n = t.childNodes, r = n.length; --r > -1;) o = n[r], a = o.type, o.style && (e.push(nt(o)), i && i.push(o)), 1 !== a && 9 !== a && 11 !== a || !o.childNodes.length || Jt(o, e, i)
                        };
                        return s.cascadeTo = function(t, i, n) {
                            var r, o, a, s, l = e.to(t, i, n),
                                c = [l],
                                h = [],
                                u = [],
                                d = [],
                                p = e._internals.reservedProps;
                            for (t = l._targets || l.target, Jt(t, h, d), l.render(i, !0, !0), Jt(t, u), l.render(0, !0, !0), l._enabled(!0), r = d.length; --r > -1;)
                                if (o = rt(d[r], h[r], u[r]), o.firstMPT) {
                                    o = o.difs;
                                    for (a in n) p[a] && (o[a] = n[a]);
                                    s = {};
                                    for (a in o) s[a] = h[r][a];
                                    c.push(e.fromTo(d[r], i, s, o))
                                }
                            return c
                        }, t.activate([s]), s
                    }, !0),
                    function() {
                        var t = o._gsDefine.plugin({
                                propName: "roundProps",
                                version: "1.7.0",
                                priority: -1,
                                API: 2,
                                init: function(t, e, i) {
                                    return this._tween = i, !0
                                }
                            }),
                            e = function(t) {
                                var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
                                return function(i) {
                                    return (Math.round(i / t) * t * e | 0) / e
                                }
                            },
                            i = function(t, e) {
                                for (; t;) t.f || t.blob || (t.m = e || Math.round), t = t._next
                            },
                            n = t.prototype;
                        n._onInitAllProps = function() {
                            var t, n, r, o, a = this._tween,
                                s = a.vars.roundProps,
                                l = {},
                                c = a._propLookup.roundProps;
                            if ("object" != typeof s || s.push)
                                for ("string" == typeof s && (s = s.split(",")), r = s.length; --r > -1;) l[s[r]] = Math.round;
                            else
                                for (o in s) l[o] = e(s[o]);
                            for (o in l)
                                for (t = a._firstPT; t;) n = t._next, t.pg ? t.t._mod(l) : t.n === o && (2 === t.f && t.t ? i(t.t._firstPT, l[o]) : (this._add(t.t, o, t.s, t.c, l[o]), n && (n._prev = t._prev), t._prev ? t._prev._next = n : a._firstPT === t && (a._firstPT = n), t._next = t._prev = null, a._propLookup[o] = c)), t = n;
                            return !1
                        }, n._add = function(t, e, i, n, r) {
                            this._addTween(t, e, i, i + n, e, r || Math.round), this._overwriteProps.push(e)
                        }
                    }(),
                    function() {
                        o._gsDefine.plugin({
                            propName: "attr",
                            API: 2,
                            version: "0.6.1",
                            init: function(t, e, i, n) {
                                var r, o;
                                if ("function" != typeof t.setAttribute) return !1;
                                for (r in e) o = e[r], "function" == typeof o && (o = o(n, t)), this._addTween(t, "setAttribute", t.getAttribute(r) + "", o + "", r, !1, r), this._overwriteProps.push(r);
                                return !0
                            }
                        })
                    }(), o._gsDefine.plugin({
                        propName: "directionalRotation",
                        version: "0.3.1",
                        API: 2,
                        init: function(t, e, i, n) {
                            "object" != typeof e && (e = {
                                rotation: e
                            }), this.finals = {};
                            var r, o, a, s, l, c, h = e.useRadians === !0 ? 2 * Math.PI : 360,
                                u = 1e-6;
                            for (r in e) "useRadians" !== r && (s = e[r], "function" == typeof s && (s = s(n, t)), c = (s + "").split("_"), o = c[0], a = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), s = this.finals[r] = "string" == typeof o && "=" === o.charAt(1) ? a + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0, l = s - a, c.length && (o = c.join("_"), o.indexOf("short") !== -1 && (l %= h, l !== l % (h / 2) && (l = l < 0 ? l + h : l - h)), o.indexOf("_cw") !== -1 && l < 0 ? l = (l + 9999999999 * h) % h - (l / h | 0) * h : o.indexOf("ccw") !== -1 && l > 0 && (l = (l - 9999999999 * h) % h - (l / h | 0) * h)), (l > u || l < -u) && (this._addTween(t, r, a, a + l, r), this._overwriteProps.push(r)));
                            return !0
                        },
                        set: function(t) {
                            var e;
                            if (1 !== t) this._super.setRatio.call(this, t);
                            else
                                for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
                        }
                    })._autoCSS = !0, o._gsDefine("easing.Back", ["easing.Ease"], function(t) {
                        var e, i, n, r, a = o.GreenSockGlobals || o,
                            s = a.com.greensock,
                            l = 2 * Math.PI,
                            c = Math.PI / 2,
                            h = s._class,
                            u = function(e, i) {
                                var n = h("easing." + e, function() {}, !0),
                                    r = n.prototype = new t;
                                return r.constructor = n, r.getRatio = i, n
                            },
                            d = t.register || function() {},
                            p = function(t, e, i, n, r) {
                                var o = h("easing." + t, {
                                    easeOut: new e,
                                    easeIn: new i,
                                    easeInOut: new n
                                }, !0);
                                return d(o, t), o
                            },
                            f = function(t, e, i) {
                                this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
                            },
                            m = function(e, i) {
                                var n = h("easing." + e, function(t) {
                                        this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                                    }, !0),
                                    r = n.prototype = new t;
                                return r.constructor = n, r.getRatio = i, r.config = function(t) {
                                    return new n(t)
                                }, n
                            },
                            g = p("Back", m("BackOut", function(t) {
                                return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                            }), m("BackIn", function(t) {
                                return t * t * ((this._p1 + 1) * t - this._p1)
                            }), m("BackInOut", function(t) {
                                return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                            })),
                            v = h("easing.SlowMo", function(t, e, i) {
                                e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0
                            }, !0),
                            y = v.prototype = new t;
                        return y.constructor = v, y.getRatio = function(t) {
                            var e = t + (.5 - t) * this._p;
                            return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
                        }, v.ease = new v(.7, .7), y.config = v.config = function(t, e, i) {
                            return new v(t, e, i)
                        }, e = h("easing.SteppedEase", function(t, e) {
                            t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0
                        }, !0), y = e.prototype = new t, y.constructor = e, y.getRatio = function(t) {
                            return t < 0 ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1
                        }, y.config = e.config = function(t, i) {
                            return new e(t, i)
                        }, i = h("easing.ExpoScaleEase", function(t, e, i) {
                            this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = i
                        }, !0), y = i.prototype = new t, y.constructor = i, y.getRatio = function(t) {
                            return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2
                        }, y.config = i.config = function(t, e, n) {
                            return new i(t, e, n)
                        }, n = h("easing.RoughEase", function(e) {
                            e = e || {};
                            for (var i, n, r, o, a, s, l = e.taper || "none", c = [], h = 0, u = 0 | (e.points || 20), d = u, p = e.randomize !== !1, m = e.clamp === !0, g = e.template instanceof t ? e.template : null, v = "number" == typeof e.strength ? .4 * e.strength : .4; --d > -1;) i = p ? Math.random() : 1 / u * d, n = g ? g.getRatio(i) : i, "none" === l ? r = v : "out" === l ? (o = 1 - i, r = o * o * v) : "in" === l ? r = i * i * v : i < .5 ? (o = 2 * i, r = o * o * .5 * v) : (o = 2 * (1 - i), r = o * o * .5 * v), p ? n += Math.random() * r - .5 * r : d % 2 ? n += .5 * r : n -= .5 * r, m && (n > 1 ? n = 1 : n < 0 && (n = 0)), c[h++] = {
                                x: i,
                                y: n
                            };
                            for (c.sort(function(t, e) {
                                    return t.x - e.x
                                }), s = new f(1, 1, null), d = u; --d > -1;) a = c[d], s = new f(a.x, a.y, s);
                            this._prev = new f(0, 0, 0 !== s.t ? s : s.next)
                        }, !0), y = n.prototype = new t, y.constructor = n, y.getRatio = function(t) {
                            var e = this._prev;
                            if (t > e.t) {
                                for (; e.next && t >= e.t;) e = e.next;
                                e = e.prev
                            } else
                                for (; e.prev && t <= e.t;) e = e.prev;
                            return this._prev = e, e.v + (t - e.t) / e.gap * e.c
                        }, y.config = function(t) {
                            return new n(t)
                        }, n.ease = new n, p("Bounce", u("BounceOut", function(t) {
                            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                        }), u("BounceIn", function(t) {
                            return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
                        }), u("BounceInOut", function(t) {
                            var e = t < .5;
                            return t = e ? 1 - 2 * t : 2 * t - 1, t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
                        })), p("Circ", u("CircOut", function(t) {
                            return Math.sqrt(1 - (t -= 1) * t)
                        }), u("CircIn", function(t) {
                            return -(Math.sqrt(1 - t * t) - 1)
                        }), u("CircInOut", function(t) {
                            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                        })), r = function(e, i, n) {
                            var r = h("easing." + e, function(t, e) {
                                    this._p1 = t >= 1 ? t : 1, this._p2 = (e || n) / (t < 1 ? t : 1), this._p3 = this._p2 / l * (Math.asin(1 / this._p1) || 0), this._p2 = l / this._p2
                                }, !0),
                                o = r.prototype = new t;
                            return o.constructor = r, o.getRatio = i, o.config = function(t, e) {
                                return new r(t, e)
                            }, r
                        }, p("Elastic", r("ElasticOut", function(t) {
                            return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
                        }, .3), r("ElasticIn", function(t) {
                            return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2))
                        }, .3), r("ElasticInOut", function(t) {
                            return (t *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
                        }, .45)), p("Expo", u("ExpoOut", function(t) {
                            return 1 - Math.pow(2, -10 * t)
                        }), u("ExpoIn", function(t) {
                            return Math.pow(2, 10 * (t - 1)) - .001
                        }), u("ExpoInOut", function(t) {
                            return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                        })), p("Sine", u("SineOut", function(t) {
                            return Math.sin(t * c)
                        }), u("SineIn", function(t) {
                            return -Math.cos(t * c) + 1
                        }), u("SineInOut", function(t) {
                            return -.5 * (Math.cos(Math.PI * t) - 1)
                        })), h("easing.EaseLookup", {
                            find: function(e) {
                                return t.map[e]
                            }
                        }, !0), d(a.SlowMo, "SlowMo", "ease,"), d(n, "RoughEase", "ease,"), d(e, "SteppedEase", "ease,"), g
                    }, !0)
            }), o._gsDefine && o._gsQueue.pop()(),
            function(i, o) {
                "use strict";
                var a = {},
                    s = i.document,
                    l = i.GreenSockGlobals = i.GreenSockGlobals || i;
                if (l.TweenLite) return l.TweenLite;
                var c, h, u, d, p, f = function(t) {
                        var e, i = t.split("."),
                            n = l;
                        for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
                        return n
                    },
                    m = f("com.greensock"),
                    g = 1e-10,
                    v = function(t) {
                        var e, i = [],
                            n = t.length;
                        for (e = 0; e !== n; i.push(t[e++]));
                        return i
                    },
                    y = function() {},
                    _ = function() {
                        var t = Object.prototype.toString,
                            e = t.call([]);
                        return function(i) {
                            return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                        }
                    }(),
                    x = {},
                    b = function(i, s, c, h) {
                        this.sc = x[i] ? x[i].sc : [], x[i] = this, this.gsClass = null, this.func = c;
                        var u = [];
                        this.check = function(d) {
                            for (var p, m, g, v, y = s.length, _ = y; --y > -1;)(p = x[s[y]] || new b(s[y], [])).gsClass ? (u[y] = p.gsClass, _--) : d && p.sc.push(this);
                            if (0 === _ && c) {
                                if (m = ("com.greensock." + i).split("."), g = m.pop(), v = f(m.join("."))[g] = this.gsClass = c.apply(c, u), h)
                                    if (l[g] = a[g] = v, "undefined" != typeof t && t.exports)
                                        if (i === o) {
                                            t.exports = a[o] = v;
                                            for (y in a) v[y] = a[y]
                                        } else a[o] && (a[o][g] = v);
                                else n = [], r = function() {
                                    return v
                                }.apply(e, n), !(void 0 !== r && (t.exports = r));
                                for (y = 0; y < this.sc.length; y++) this.sc[y].check()
                            }
                        }, this.check(!0)
                    },
                    w = i._gsDefine = function(t, e, i, n) {
                        return new b(t, e, i, n)
                    },
                    T = m._class = function(t, e, i) {
                        return e = e || function() {}, w(t, [], function() {
                            return e
                        }, i), e
                    };
                w.globals = l;
                var S = [0, 0, 1, 1],
                    M = T("easing.Ease", function(t, e, i, n) {
                        this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? S.concat(e) : S
                    }, !0),
                    E = M.map = {},
                    A = M.register = function(t, e, i, n) {
                        for (var r, o, a, s, l = e.split(","), c = l.length, h = (i || "easeIn,easeOut,easeInOut").split(","); --c > -1;)
                            for (o = l[c], r = n ? T("easing." + o, null, !0) : m.easing[o] || {}, a = h.length; --a > -1;) s = h[a], E[o + "." + s] = E[s + o] = r[s] = t.getRatio ? t : t[s] || new t
                    };
                for (u = M.prototype, u._calcEnd = !1, u.getRatio = function(t) {
                        if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                        var e = this._type,
                            i = this._power,
                            n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                        return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                    }, c = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], h = c.length; --h > -1;) u = c[h] + ",Power" + h, A(new M(null, null, 1, h), u, "easeOut", !0), A(new M(null, null, 2, h), u, "easeIn" + (0 === h ? ",easeNone" : "")), A(new M(null, null, 3, h), u, "easeInOut");
                E.linear = m.easing.Linear.easeIn, E.swing = m.easing.Quad.easeInOut;
                var C = T("events.EventDispatcher", function(t) {
                    this._listeners = {}, this._eventTarget = t || this
                });
                u = C.prototype, u.addEventListener = function(t, e, i, n, r) {
                    r = r || 0;
                    var o, a, s = this._listeners[t],
                        l = 0;
                    for (this !== d || p || d.wake(), null == s && (this._listeners[t] = s = []), a = s.length; --a > -1;) o = s[a], o.c === e && o.s === i ? s.splice(a, 1) : 0 === l && o.pr < r && (l = a + 1);
                    s.splice(l, 0, {
                        c: e,
                        s: i,
                        up: n,
                        pr: r
                    })
                }, u.removeEventListener = function(t, e) {
                    var i, n = this._listeners[t];
                    if (n)
                        for (i = n.length; --i > -1;)
                            if (n[i].c === e) return void n.splice(i, 1)
                }, u.dispatchEvent = function(t) {
                    var e, i, n, r = this._listeners[t];
                    if (r)
                        for (e = r.length, e > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;) n = r[e], n && (n.up ? n.c.call(n.s || i, {
                            type: t,
                            target: i
                        }) : n.c.call(n.s || i))
                };
                var P = i.requestAnimationFrame,
                    R = i.cancelAnimationFrame,
                    L = Date.now || function() {
                        return (new Date).getTime()
                    },
                    k = L();
                for (c = ["ms", "moz", "webkit", "o"], h = c.length; --h > -1 && !P;) P = i[c[h] + "RequestAnimationFrame"], R = i[c[h] + "CancelAnimationFrame"] || i[c[h] + "CancelRequestAnimationFrame"];
                T("Ticker", function(t, e) {
                    var i, n, r, o, a, l = this,
                        c = L(),
                        h = !(e === !1 || !P) && "auto",
                        u = 500,
                        f = 33,
                        m = "tick",
                        v = function(t) {
                            var e, s, h = L() - k;
                            h > u && (c += h - f), k += h, l.time = (k - c) / 1e3, e = l.time - a, (!i || e > 0 || t === !0) && (l.frame++, a += e + (e >= o ? .004 : o - e), s = !0), t !== !0 && (r = n(v)), s && l.dispatchEvent(m)
                        };
                    C.call(l), l.time = l.frame = 0, l.tick = function() {
                        v(!0)
                    }, l.lagSmoothing = function(t, e) {
                        return arguments.length ? (u = t || 1 / g, void(f = Math.min(e, u, 0))) : u < 1 / g
                    }, l.sleep = function() {
                        null != r && (h && R ? R(r) : clearTimeout(r), n = y, r = null, l === d && (p = !1))
                    }, l.wake = function(t) {
                        null !== r ? l.sleep() : t ? c += -k + (k = L()) : l.frame > 10 && (k = L() - u + 5), n = 0 === i ? y : h && P ? P : function(t) {
                            return setTimeout(t, 1e3 * (a - l.time) + 1 | 0)
                        }, l === d && (p = !0), v(2)
                    }, l.fps = function(t) {
                        return arguments.length ? (i = t, o = 1 / (i || 60), a = this.time + o, void l.wake()) : i
                    }, l.useRAF = function(t) {
                        return arguments.length ? (l.sleep(), h = t, void l.fps(i)) : h
                    }, l.fps(t), setTimeout(function() {
                        "auto" === h && l.frame < 5 && "hidden" !== (s || {}).visibilityState && l.useRAF(!1)
                    }, 1500)
                }), u = m.Ticker.prototype = new m.events.EventDispatcher, u.constructor = m.Ticker;
                var O = T("core.Animation", function(t, e) {
                    if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = e.immediateRender === !0, this.data = e.data, this._reversed = e.reversed === !0, K) {
                        p || d.wake();
                        var i = this.vars.useFrames ? J : K;
                        i.add(this, i._time), this.vars.paused && this.paused(!0)
                    }
                });
                d = O.ticker = new m.Ticker,
                    u = O.prototype, u._dirty = u._gc = u._initted = u._paused = !1, u._totalTime = u._time = 0, u._rawPrevTime = -1, u._next = u._last = u._onUpdate = u._timeline = u.timeline = null, u._paused = !1;
                var D = function() {
                    p && L() - k > 2e3 && ("hidden" !== (s || {}).visibilityState || !d.lagSmoothing()) && d.wake();
                    var t = setTimeout(D, 2e3);
                    t.unref && t.unref()
                };
                D(), u.play = function(t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, u.pause = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, u.resume = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!1)
                }, u.seek = function(t, e) {
                    return this.totalTime(Number(t), e !== !1)
                }, u.restart = function(t, e) {
                    return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0)
                }, u.reverse = function(t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, u.render = function(t, e, i) {}, u.invalidate = function() {
                    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                }, u.isActive = function() {
                    var t, e = this._timeline,
                        i = this._startTime;
                    return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
                }, u._enabled = function(t, e) {
                    return p || d.wake(), this._gc = !t, this._active = this.isActive(), e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
                }, u._kill = function(t, e) {
                    return this._enabled(!1, !1)
                }, u.kill = function(t, e) {
                    return this._kill(t, e), this
                }, u._uncache = function(t) {
                    for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                    return this
                }, u._swapSelfInParams = function(t) {
                    for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
                    return i
                }, u._callback = function(t) {
                    var e = this.vars,
                        i = e[t],
                        n = e[t + "Params"],
                        r = e[t + "Scope"] || e.callbackScope || this,
                        o = n ? n.length : 0;
                    switch (o) {
                        case 0:
                            i.call(r);
                            break;
                        case 1:
                            i.call(r, n[0]);
                            break;
                        case 2:
                            i.call(r, n[0], n[1]);
                            break;
                        default:
                            i.apply(r, n)
                    }
                }, u.eventCallback = function(t, e, i, n) {
                    if ("on" === (t || "").substr(0, 2)) {
                        var r = this.vars;
                        if (1 === arguments.length) return r[t];
                        null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = _(i) && i.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
                    }
                    return this
                }, u.delay = function(t) {
                    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
                }, u.duration = function(t) {
                    return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
                }, u.totalDuration = function(t) {
                    return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
                }, u.time = function(t, e) {
                    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                }, u.totalTime = function(t, e, i) {
                    if (p || d.wake(), !arguments.length) return this._totalTime;
                    if (this._timeline) {
                        if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                            this._dirty && this.totalDuration();
                            var n = this._totalDuration,
                                r = this._timeline;
                            if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                        }
                        this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (F.length && et(), this.render(t, e, !1), F.length && et())
                    }
                    return this
                }, u.progress = u.totalProgress = function(t, e) {
                    var i = this.duration();
                    return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
                }, u.startTime = function(t) {
                    return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
                }, u.endTime = function(t) {
                    return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                }, u.timeScale = function(t) {
                    if (!arguments.length) return this._timeScale;
                    var e, i;
                    for (t = t || g, this._timeline && this._timeline.smoothChildTiming && (e = this._pauseTime, i = e || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
                    return this
                }, u.reversed = function(t) {
                    return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                }, u.paused = function(t) {
                    if (!arguments.length) return this._paused;
                    var e, i, n = this._timeline;
                    return t != this._paused && n && (p || t || d.wake(), e = n.rawTime(), i = e - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
                };
                var I = T("core.SimpleTimeline", function(t) {
                    O.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
                });
                u = I.prototype = new O, u.constructor = I, u.kill()._gc = !1, u._first = u._last = u._recent = null, u._sortChildren = !1, u.add = u.insert = function(t, e, i, n) {
                    var r, o;
                    if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                        for (o = t._startTime; r && r._startTime > o;) r = r._prev;
                    return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
                }, u._remove = function(t, e) {
                    return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                }, u.render = function(t, e, i) {
                    var n, r = this._first;
                    for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
                }, u.rawTime = function() {
                    return p || d.wake(), this._totalTime
                };
                var N = T("TweenLite", function(t, e, n) {
                        if (O.call(this, e, n), this.render = N.prototype.render, null == t) throw "Cannot tween a null target.";
                        this.target = t = "string" != typeof t ? t : N.selector(t) || t;
                        var r, o, a, s = t.jquery || t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType),
                            l = this.vars.overwrite;
                        if (this._overwrite = l = null == l ? Q[N.defaultOverwrite] : "number" == typeof l ? l >> 0 : Q[l], (s || t instanceof Array || t.push && _(t)) && "number" != typeof t[0])
                            for (this._targets = a = v(t), this._propLookup = [], this._siblings = [], r = 0; r < a.length; r++) o = a[r], o ? "string" != typeof o ? o.length && o !== i && o[0] && (o[0] === i || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(v(o))) : (this._siblings[r] = it(o, this, !1), 1 === l && this._siblings[r].length > 1 && rt(o, this, null, 1, this._siblings[r])) : (o = a[r--] = N.selector(o), "string" == typeof o && a.splice(r + 1, 1)) : a.splice(r--, 1);
                        else this._propLookup = {}, this._siblings = it(t, this, !1), 1 === l && this._siblings.length > 1 && rt(t, this, null, 1, this._siblings);
                        (this.vars.immediateRender || 0 === e && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -g, this.render(Math.min(0, -this._delay)))
                    }, !0),
                    B = function(t) {
                        return t && t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType)
                    },
                    U = function(t, e) {
                        var i, n = {};
                        for (i in t) Z[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!q[i] || q[i] && q[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                        t.css = n
                    };
                u = N.prototype = new O, u.constructor = N, u.kill()._gc = !1, u.ratio = 0, u._firstPT = u._targets = u._overwrittenProps = u._startAt = null, u._notifyPluginsOfEnabled = u._lazy = !1, N.version = "1.20.5", N.defaultEase = u._ease = new M(null, null, 1, 1), N.defaultOverwrite = "auto", N.ticker = d, N.autoSleep = 120, N.lagSmoothing = function(t, e) {
                    d.lagSmoothing(t, e)
                }, N.selector = i.$ || i.jQuery || function(t) {
                    var e = i.$ || i.jQuery;
                    return e ? (N.selector = e, e(t)) : (s || (s = i.document), s ? s.querySelectorAll ? s.querySelectorAll(t) : s.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t)
                };
                var F = [],
                    z = {},
                    H = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                    j = /[\+-]=-?[\.\d]/,
                    G = function(t) {
                        for (var e, i = this._firstPT, n = 1e-6; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : e < n && e > -n && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                    },
                    V = function(t, e, i, n) {
                        var r, o, a, s, l, c, h, u = [],
                            d = 0,
                            p = "",
                            f = 0;
                        for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, r = t.match(H) || [], o = e.match(H) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), l = o.length, s = 0; s < l; s++) h = o[s], c = e.substr(d, e.indexOf(h, d) - d), p += c || !s ? c : ",", d += c.length, f ? f = (f + 1) % 5 : "rgba(" === c.substr(-5) && (f = 1), h === r[s] || r.length <= s ? p += h : (p && (u.push(p), p = ""), a = parseFloat(r[s]), u.push(a), u._firstPT = {
                            _next: u._firstPT,
                            t: u,
                            p: u.length - 1,
                            s: a,
                            c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - a) || 0,
                            f: 0,
                            m: f && f < 4 ? Math.round : 0
                        }), d += h.length;
                        return p += e.substr(d), p && u.push(p), u.setRatio = G, j.test(e) && (u.end = null), u
                    },
                    W = function(t, e, i, n, r, o, a, s, l) {
                        "function" == typeof n && (n = n(l || 0, t));
                        var c, h = typeof t[e],
                            u = "function" !== h ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                            d = "get" !== i ? i : u ? a ? t[u](a) : t[u]() : t[e],
                            p = "string" == typeof n && "=" === n.charAt(1),
                            f = {
                                t: t,
                                p: e,
                                s: d,
                                f: "function" === h,
                                pg: 0,
                                n: r || e,
                                m: o ? "function" == typeof o ? o : Math.round : 0,
                                pr: 0,
                                c: p ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - d || 0
                            };
                        if (("number" != typeof d || "number" != typeof n && !p) && (a || isNaN(d) || !p && isNaN(n) || "boolean" == typeof d || "boolean" == typeof n ? (f.fp = a, c = V(d, p ? parseFloat(f.s) + f.c + (f.s + "").replace(/[0-9\-\.]/g, "") : n, s || N.defaultStringFilter, f), f = {
                                t: c,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 2,
                                pg: 0,
                                n: r || e,
                                pr: 0,
                                m: 0
                            }) : (f.s = parseFloat(d), p || (f.c = parseFloat(n) - f.s || 0))), f.c) return (f._next = this._firstPT) && (f._next._prev = f), this._firstPT = f, f
                    },
                    X = N._internals = {
                        isArray: _,
                        isSelector: B,
                        lazyTweens: F,
                        blobDif: V
                    },
                    q = N._plugins = {},
                    $ = X.tweenLookup = {},
                    Y = 0,
                    Z = X.reservedProps = {
                        ease: 1,
                        delay: 1,
                        overwrite: 1,
                        onComplete: 1,
                        onCompleteParams: 1,
                        onCompleteScope: 1,
                        useFrames: 1,
                        runBackwards: 1,
                        startAt: 1,
                        onUpdate: 1,
                        onUpdateParams: 1,
                        onUpdateScope: 1,
                        onStart: 1,
                        onStartParams: 1,
                        onStartScope: 1,
                        onReverseComplete: 1,
                        onReverseCompleteParams: 1,
                        onReverseCompleteScope: 1,
                        onRepeat: 1,
                        onRepeatParams: 1,
                        onRepeatScope: 1,
                        easeParams: 1,
                        yoyo: 1,
                        immediateRender: 1,
                        repeat: 1,
                        repeatDelay: 1,
                        data: 1,
                        paused: 1,
                        reversed: 1,
                        autoCSS: 1,
                        lazy: 1,
                        onOverwrite: 1,
                        callbackScope: 1,
                        stringFilter: 1,
                        id: 1,
                        yoyoEase: 1
                    },
                    Q = {
                        none: 0,
                        all: 1,
                        auto: 2,
                        concurrent: 3,
                        allOnStart: 4,
                        preexisting: 5,
                        true: 1,
                        false: 0
                    },
                    J = O._rootFramesTimeline = new I,
                    K = O._rootTimeline = new I,
                    tt = 30,
                    et = X.lazyRender = function() {
                        var t, e = F.length;
                        for (z = {}; --e > -1;) t = F[e], t && t._lazy !== !1 && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                        F.length = 0
                    };
                K._startTime = d.time, J._startTime = d.frame, K._active = J._active = !0, setTimeout(et, 1), O._updateRoot = N.render = function() {
                    var t, e, i;
                    if (F.length && et(), K.render((d.time - K._startTime) * K._timeScale, !1, !1), J.render((d.frame - J._startTime) * J._timeScale, !1, !1), F.length && et(), d.frame >= tt) {
                        tt = d.frame + (parseInt(N.autoSleep, 10) || 120);
                        for (i in $) {
                            for (e = $[i].tweens, t = e.length; --t > -1;) e[t]._gc && e.splice(t, 1);
                            0 === e.length && delete $[i]
                        }
                        if (i = K._first, (!i || i._paused) && N.autoSleep && !J._first && 1 === d._listeners.tick.length) {
                            for (; i && i._paused;) i = i._next;
                            i || d.sleep()
                        }
                    }
                }, d.addEventListener("tick", O._updateRoot);
                var it = function(t, e, i) {
                        var n, r, o = t._gsTweenID;
                        if ($[o || (t._gsTweenID = o = "t" + Y++)] || ($[o] = {
                                target: t,
                                tweens: []
                            }), e && (n = $[o].tweens, n[r = n.length] = e, i))
                            for (; --r > -1;) n[r] === e && n.splice(r, 1);
                        return $[o].tweens
                    },
                    nt = function(t, e, i, n) {
                        var r, o, a = t.vars.onOverwrite;
                        return a && (r = a(t, e, i, n)), a = N.onOverwrite, a && (o = a(t, e, i, n)), r !== !1 && o !== !1
                    },
                    rt = function(t, e, i, n, r) {
                        var o, a, s, l;
                        if (1 === n || n >= 4) {
                            for (l = r.length, o = 0; o < l; o++)
                                if ((s = r[o]) !== e) s._gc || s._kill(null, t, e) && (a = !0);
                                else if (5 === n) break;
                            return a
                        }
                        var c, h = e._startTime + g,
                            u = [],
                            d = 0,
                            p = 0 === e._duration;
                        for (o = r.length; --o > -1;)(s = r[o]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (c = c || ot(e, 0, p), 0 === ot(s, c, p) && (u[d++] = s)) : s._startTime <= h && s._startTime + s.totalDuration() / s._timeScale > h && ((p || !s._initted) && h - s._startTime <= 2e-10 || (u[d++] = s)));
                        for (o = d; --o > -1;)
                            if (s = u[o], 2 === n && s._kill(i, t, e) && (a = !0), 2 !== n || !s._firstPT && s._initted) {
                                if (2 !== n && !nt(s, e)) continue;
                                s._enabled(!1, !1) && (a = !0)
                            }
                        return a
                    },
                    ot = function(t, e, i) {
                        for (var n = t._timeline, r = n._timeScale, o = t._startTime; n._timeline;) {
                            if (o += n._startTime, r *= n._timeScale, n._paused) return -100;
                            n = n._timeline
                        }
                        return o /= r, o > e ? o - e : i && o === e || !t._initted && o - e < 2 * g ? g : (o += t.totalDuration() / t._timeScale / r) > e + g ? 0 : o - e - g
                    };
                u._init = function() {
                    var t, e, i, n, r, o, a = this.vars,
                        s = this._overwrittenProps,
                        l = this._duration,
                        c = !!a.immediateRender,
                        h = a.ease;
                    if (a.startAt) {
                        this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {};
                        for (n in a.startAt) r[n] = a.startAt[n];
                        if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = c && a.lazy !== !1, r.startAt = r.delay = null, r.onUpdate = a.onUpdate, r.onUpdateParams = a.onUpdateParams, r.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = N.to(this.target || {}, 0, r), c)
                            if (this._time > 0) this._startAt = null;
                            else if (0 !== l) return
                    } else if (a.runBackwards && 0 !== l)
                        if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                        else {
                            0 !== this._time && (c = !1), i = {};
                            for (n in a) Z[n] && "autoCSS" !== n || (i[n] = a[n]);
                            if (i.overwrite = 0, i.data = "isFromStart", i.lazy = c && a.lazy !== !1, i.immediateRender = c, this._startAt = N.to(this.target, 0, i), c) {
                                if (0 === this._time) return
                            } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                        }
                    if (this._ease = h = h ? h instanceof M ? h : "function" == typeof h ? new M(h, a.easeParams) : E[h] || N.defaultEase : N.defaultEase, a.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                        for (o = this._targets.length, t = 0; t < o; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
                    else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                    if (e && N._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                        for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                    this._onUpdate = a.onUpdate, this._initted = !0
                }, u._initProps = function(t, e, n, r, o) {
                    var a, s, l, c, h, u;
                    if (null == t) return !1;
                    z[t._gsTweenID] && et(), this.vars.css || t.style && t !== i && t.nodeType && q.css && this.vars.autoCSS !== !1 && U(this.vars, t);
                    for (a in this.vars)
                        if (u = this.vars[a], Z[a]) u && (u instanceof Array || u.push && _(u)) && u.join("").indexOf("{self}") !== -1 && (this.vars[a] = u = this._swapSelfInParams(u, this));
                        else if (q[a] && (c = new q[a])._onInitTween(t, this.vars[a], this, o)) {
                        for (this._firstPT = h = {
                                _next: this._firstPT,
                                t: c,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 1,
                                n: a,
                                pg: 1,
                                pr: c._priority,
                                m: 0
                            }, s = c._overwriteProps.length; --s > -1;) e[c._overwriteProps[s]] = this._firstPT;
                        (c._priority || c._onInitAllProps) && (l = !0), (c._onDisable || c._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h)
                    } else e[a] = W.call(this, t, a, "get", u, a, 0, null, this.vars.stringFilter, o);
                    return r && this._kill(r, t) ? this._initProps(t, e, n, r, o) : this._overwrite > 1 && this._firstPT && n.length > 1 && rt(t, this, e, this._overwrite, n) ? (this._kill(e, t), this._initProps(t, e, n, r, o)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (z[t._gsTweenID] = !0), l)
                }, u.render = function(t, e, i) {
                    var n, r, o, a, s = this._time,
                        l = this._duration,
                        c = this._rawPrevTime;
                    if (t >= l - 1e-7 && t >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (c < 0 || t <= 0 && t >= -1e-7 || c === g && "isPause" !== this.data) && c !== t && (i = !0, c > g && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || c === t ? t : g);
                    else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === l && c > 0) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (c >= 0 && (c !== g || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || c === t ? t : g)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
                    else if (this._totalTime = this._time = t, this._easeType) {
                        var h = t / l,
                            u = this._easeType,
                            d = this._easePower;
                        (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === d ? h *= h : 2 === d ? h *= h * h : 3 === d ? h *= h * h * h : 4 === d && (h *= h * h * h * h), 1 === u ? this.ratio = 1 - h : 2 === u ? this.ratio = h : t / l < .5 ? this.ratio = h / 2 : this.ratio = 1 - h / 2
                    } else this.ratio = this._ease.getRatio(t / l);
                    if (this._time !== s || i) {
                        if (!this._initted) {
                            if (this._init(), !this._initted || this._gc) return;
                            if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = c, F.push(this), void(this._lazy = [t, e]);
                            this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                        }
                        for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0), 0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                        this._onUpdate && (t < 0 && this._startAt && t !== -1e-4 && this._startAt.render(t, !0, i), e || (this._time !== s || n || i) && this._callback("onUpdate")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && t !== -1e-4 && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === l && this._rawPrevTime === g && a !== g && (this._rawPrevTime = 0)))
                    }
                }, u._kill = function(t, e, i) {
                    if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                    e = "string" != typeof e ? e || this._targets || this.target : N.selector(e) || e;
                    var n, r, o, a, s, l, c, h, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                    if ((_(e) || B(e)) && "number" != typeof e[0])
                        for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (l = !0);
                    else {
                        if (this._targets) {
                            for (n = this._targets.length; --n > -1;)
                                if (e === this._targets[n]) {
                                    s = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                    break
                                }
                        } else {
                            if (e !== this.target) return !1;
                            s = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                        }
                        if (s) {
                            if (c = t || s, h = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill), i && (N.onOverwrite || this.vars.onOverwrite)) {
                                for (o in c) s[o] && (u || (u = []), u.push(o));
                                if ((u || !t) && !nt(this, i, e, u)) return !1
                            }
                            for (o in c)(a = s[o]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, l = !0), a.pg && a.t._kill(c) && (l = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), h && (r[o] = 1);
                            !this._firstPT && this._initted && this._enabled(!1, !1)
                        }
                    }
                    return l
                }, u.invalidate = function() {
                    return this._notifyPluginsOfEnabled && N._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], O.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -g, this.render(Math.min(0, -this._delay))), this
                }, u._enabled = function(t, e) {
                    if (p || d.wake(), t && this._gc) {
                        var i, n = this._targets;
                        if (n)
                            for (i = n.length; --i > -1;) this._siblings[i] = it(n[i], this, !0);
                        else this._siblings = it(this.target, this, !0)
                    }
                    return O.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && N._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                }, N.to = function(t, e, i) {
                    return new N(t, e, i)
                }, N.from = function(t, e, i) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new N(t, e, i)
                }, N.fromTo = function(t, e, i, n) {
                    return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new N(t, e, n)
                }, N.delayedCall = function(t, e, i, n, r) {
                    return new N(e, 0, {
                        delay: t,
                        onComplete: e,
                        onCompleteParams: i,
                        callbackScope: n,
                        onReverseComplete: e,
                        onReverseCompleteParams: i,
                        immediateRender: !1,
                        lazy: !1,
                        useFrames: r,
                        overwrite: 0
                    })
                }, N.set = function(t, e) {
                    return new N(t, 0, e)
                }, N.getTweensOf = function(t, e) {
                    if (null == t) return [];
                    t = "string" != typeof t ? t : N.selector(t) || t;
                    var i, n, r, o;
                    if ((_(t) || B(t)) && "number" != typeof t[0]) {
                        for (i = t.length, n = []; --i > -1;) n = n.concat(N.getTweensOf(t[i], e));
                        for (i = n.length; --i > -1;)
                            for (o = n[i], r = i; --r > -1;) o === n[r] && n.splice(i, 1)
                    } else if (t._gsTweenID)
                        for (n = it(t).concat(), i = n.length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                    return n || []
                }, N.killTweensOf = N.killDelayedCallsTo = function(t, e, i) {
                    "object" == typeof e && (i = e, e = !1);
                    for (var n = N.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
                };
                var at = T("plugins.TweenPlugin", function(t, e) {
                    this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = at.prototype
                }, !0);
                if (u = at.prototype, at.version = "1.19.0", at.API = 2, u._firstPT = null, u._addTween = W, u.setRatio = G, u._kill = function(t) {
                        var e, i = this._overwriteProps,
                            n = this._firstPT;
                        if (null != t[this._propName]) this._overwriteProps = [];
                        else
                            for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                        for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                        return !1
                    }, u._mod = u._roundProps = function(t) {
                        for (var e, i = this._firstPT; i;) e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")], e && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
                    }, N._onPluginEvent = function(t, e) {
                        var i, n, r, o, a, s = e._firstPT;
                        if ("_onInitAllProps" === t) {
                            for (; s;) {
                                for (a = s._next, n = r; n && n.pr > s.pr;) n = n._next;
                                (s._prev = n ? n._prev : o) ? s._prev._next = s: r = s, (s._next = n) ? n._prev = s : o = s, s = a
                            }
                            s = e._firstPT = r
                        }
                        for (; s;) s.pg && "function" == typeof s.t[t] && s.t[t]() && (i = !0), s = s._next;
                        return i
                    }, at.activate = function(t) {
                        for (var e = t.length; --e > -1;) t[e].API === at.API && (q[(new t[e])._propName] = t[e]);
                        return !0
                    }, w.plugin = function(t) {
                        if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                        var e, i = t.propName,
                            n = t.priority || 0,
                            r = t.overwriteProps,
                            o = {
                                init: "_onInitTween",
                                set: "setRatio",
                                kill: "_kill",
                                round: "_mod",
                                mod: "_mod",
                                initAll: "_onInitAllProps"
                            },
                            a = T("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                                at.call(this, i, n), this._overwriteProps = r || []
                            }, t.global === !0),
                            s = a.prototype = new at(i);
                        s.constructor = a, a.API = t.API;
                        for (e in o) "function" == typeof t[e] && (s[o[e]] = t[e]);
                        return a.version = t.version, at.activate([a]), a
                    }, c = i._gsQueue) {
                    for (h = 0; h < c.length; h++) c[h]();
                    for (u in x) x[u].func || i.console.log("GSAP encountered missing dependency: " + u)
                }
                p = !1
            }("undefined" != typeof t && t.exports && "undefined" != typeof i ? i : this || window, "TweenMax")
    }).call(e, function() {
        return this
    }())
}, function(t, e, i) {
    "use strict";

    function n(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(1),
        o = n(r);
    i(6), i(8), e.default = function() {
        (0, o.default)(".custom-scroll").mCustomScrollbar()
    }
}, function(t, e, i) {
    var n, r, o;
    ! function(a) {
        r = [i(1)], n = a, o = "function" == typeof n ? n.apply(e, r) : n, !(void 0 !== o && (t.exports = o))
    }(function(e) {
        ! function(n) {
            var r = i(7),
                o = "undefined" != typeof t && t.exports,
                a = "https:" == document.location.protocol ? "https:" : "http:",
                s = "cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js";
            r || (o ? i(8)(e) : e.event.special.mousewheel || e("head").append(decodeURI("%3Cscript src=" + a + "//" + s + "%3E%3C/script%3E"))), n()
        }(function() {
            var t, i = "mCustomScrollbar",
                n = "mCS",
                r = ".mCustomScrollbar",
                o = {
                    setTop: 0,
                    setLeft: 0,
                    axis: "y",
                    scrollbarPosition: "inside",
                    scrollInertia: 950,
                    autoDraggerLength: !0,
                    alwaysShowScrollbar: 0,
                    snapOffset: 0,
                    mouseWheel: {
                        enable: !0,
                        scrollAmount: "auto",
                        axis: "y",
                        deltaFactor: "auto",
                        disableOver: ["select", "option", "keygen", "datalist", "textarea"]
                    },
                    scrollButtons: {
                        scrollType: "stepless",
                        scrollAmount: "auto"
                    },
                    keyboard: {
                        enable: !0,
                        scrollType: "stepless",
                        scrollAmount: "auto"
                    },
                    contentTouchScroll: 25,
                    documentTouchScroll: !0,
                    advanced: {
                        autoScrollOnFocus: "input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
                        updateOnContentResize: !0,
                        updateOnImageLoad: "auto",
                        autoUpdateTimeout: 60
                    },
                    theme: "light",
                    callbacks: {
                        onTotalScrollOffset: 0,
                        onTotalScrollBackOffset: 0,
                        alwaysTriggerOffsets: !0
                    }
                },
                a = 0,
                s = {},
                l = window.attachEvent && !window.addEventListener ? 1 : 0,
                c = !1,
                h = ["mCSB_dragger_onDrag", "mCSB_scrollTools_onDrag", "mCS_img_loaded", "mCS_disabled", "mCS_destroyed", "mCS_no_scrollbar", "mCS-autoHide", "mCS-dir-rtl", "mCS_no_scrollbar_y", "mCS_no_scrollbar_x", "mCS_y_hidden", "mCS_x_hidden", "mCSB_draggerContainer", "mCSB_buttonUp", "mCSB_buttonDown", "mCSB_buttonLeft", "mCSB_buttonRight"],
                u = {
                    init: function(t) {
                        var t = e.extend(!0, {}, o, t),
                            i = d.call(this);
                        if (t.live) {
                            var l = t.liveSelector || this.selector || r,
                                c = e(l);
                            if ("off" === t.live) return void f(l);
                            s[l] = setTimeout(function() {
                                c.mCustomScrollbar(t), "once" === t.live && c.length && f(l)
                            }, 500)
                        } else f(l);
                        return t.setWidth = t.set_width ? t.set_width : t.setWidth, t.setHeight = t.set_height ? t.set_height : t.setHeight, t.axis = t.horizontalScroll ? "x" : m(t.axis), t.scrollInertia = t.scrollInertia > 0 && t.scrollInertia < 17 ? 17 : t.scrollInertia, "object" != typeof t.mouseWheel && 1 == t.mouseWheel && (t.mouseWheel = {
                            enable: !0,
                            scrollAmount: "auto",
                            axis: "y",
                            preventDefault: !1,
                            deltaFactor: "auto",
                            normalizeDelta: !1,
                            invert: !1
                        }), t.mouseWheel.scrollAmount = t.mouseWheelPixels ? t.mouseWheelPixels : t.mouseWheel.scrollAmount, t.mouseWheel.normalizeDelta = t.advanced.normalizeMouseWheelDelta ? t.advanced.normalizeMouseWheelDelta : t.mouseWheel.normalizeDelta, t.scrollButtons.scrollType = g(t.scrollButtons.scrollType), p(t), e(i).each(function() {
                            var i = e(this);
                            if (!i.data(n)) {
                                i.data(n, {
                                    idx: ++a,
                                    opt: t,
                                    scrollRatio: {
                                        y: null,
                                        x: null
                                    },
                                    overflowed: null,
                                    contentReset: {
                                        y: null,
                                        x: null
                                    },
                                    bindEvents: !1,
                                    tweenRunning: !1,
                                    sequential: {},
                                    langDir: i.css("direction"),
                                    cbOffsets: null,
                                    trigger: null,
                                    poll: {
                                        size: {
                                            o: 0,
                                            n: 0
                                        },
                                        img: {
                                            o: 0,
                                            n: 0
                                        },
                                        change: {
                                            o: 0,
                                            n: 0
                                        }
                                    }
                                });
                                var r = i.data(n),
                                    o = r.opt,
                                    s = i.data("mcs-axis"),
                                    l = i.data("mcs-scrollbar-position"),
                                    c = i.data("mcs-theme");
                                s && (o.axis = s), l && (o.scrollbarPosition = l), c && (o.theme = c, p(o)), v.call(this), r && o.callbacks.onCreate && "function" == typeof o.callbacks.onCreate && o.callbacks.onCreate.call(this), e("#mCSB_" + r.idx + "_container img:not(." + h[2] + ")").addClass(h[2]), u.update.call(null, i)
                            }
                        })
                    },
                    update: function(t, i) {
                        var r = t || d.call(this);
                        return e(r).each(function() {
                            var t = e(this);
                            if (t.data(n)) {
                                var r = t.data(n),
                                    o = r.opt,
                                    a = e("#mCSB_" + r.idx + "_container"),
                                    s = e("#mCSB_" + r.idx),
                                    l = [e("#mCSB_" + r.idx + "_dragger_vertical"), e("#mCSB_" + r.idx + "_dragger_horizontal")];
                                if (!a.length) return;
                                r.tweenRunning && $(t), i && r && o.callbacks.onBeforeUpdate && "function" == typeof o.callbacks.onBeforeUpdate && o.callbacks.onBeforeUpdate.call(this), t.hasClass(h[3]) && t.removeClass(h[3]), t.hasClass(h[4]) && t.removeClass(h[4]), s.css("max-height", "none"), s.height() !== t.height() && s.css("max-height", t.height()), _.call(this), "y" === o.axis || o.advanced.autoExpandHorizontalScroll || a.css("width", y(a)), r.overflowed = S.call(this), C.call(this), o.autoDraggerLength && b.call(this), w.call(this), E.call(this);
                                var c = [Math.abs(a[0].offsetTop), Math.abs(a[0].offsetLeft)];
                                "x" !== o.axis && (r.overflowed[0] ? l[0].height() > l[0].parent().height() ? M.call(this) : (Y(t, c[0].toString(), {
                                    dir: "y",
                                    dur: 0,
                                    overwrite: "none"
                                }), r.contentReset.y = null) : (M.call(this), "y" === o.axis ? A.call(this) : "yx" === o.axis && r.overflowed[1] && Y(t, c[1].toString(), {
                                    dir: "x",
                                    dur: 0,
                                    overwrite: "none"
                                }))), "y" !== o.axis && (r.overflowed[1] ? l[1].width() > l[1].parent().width() ? M.call(this) : (Y(t, c[1].toString(), {
                                    dir: "x",
                                    dur: 0,
                                    overwrite: "none"
                                }), r.contentReset.x = null) : (M.call(this), "x" === o.axis ? A.call(this) : "yx" === o.axis && r.overflowed[0] && Y(t, c[0].toString(), {
                                    dir: "y",
                                    dur: 0,
                                    overwrite: "none"
                                }))), i && r && (2 === i && o.callbacks.onImageLoad && "function" == typeof o.callbacks.onImageLoad ? o.callbacks.onImageLoad.call(this) : 3 === i && o.callbacks.onSelectorChange && "function" == typeof o.callbacks.onSelectorChange ? o.callbacks.onSelectorChange.call(this) : o.callbacks.onUpdate && "function" == typeof o.callbacks.onUpdate && o.callbacks.onUpdate.call(this)), X.call(this)
                            }
                        })
                    },
                    scrollTo: function(t, i) {
                        if ("undefined" != typeof t && null != t) {
                            var r = d.call(this);
                            return e(r).each(function() {
                                var r = e(this);
                                if (r.data(n)) {
                                    var o = r.data(n),
                                        a = o.opt,
                                        s = {
                                            trigger: "external",
                                            scrollInertia: a.scrollInertia,
                                            scrollEasing: "mcsEaseInOut",
                                            moveDragger: !1,
                                            timeout: 60,
                                            callbacks: !0,
                                            onStart: !0,
                                            onUpdate: !0,
                                            onComplete: !0
                                        },
                                        l = e.extend(!0, {}, s, i),
                                        c = V.call(this, t),
                                        h = l.scrollInertia > 0 && l.scrollInertia < 17 ? 17 : l.scrollInertia;
                                    c[0] = W.call(this, c[0], "y"), c[1] = W.call(this, c[1], "x"), l.moveDragger && (c[0] *= o.scrollRatio.y, c[1] *= o.scrollRatio.x), l.dur = rt() ? 0 : h, setTimeout(function() {
                                        null !== c[0] && "undefined" != typeof c[0] && "x" !== a.axis && o.overflowed[0] && (l.dir = "y", l.overwrite = "all", Y(r, c[0].toString(), l)), null !== c[1] && "undefined" != typeof c[1] && "y" !== a.axis && o.overflowed[1] && (l.dir = "x", l.overwrite = "none", Y(r, c[1].toString(), l))
                                    }, l.timeout)
                                }
                            })
                        }
                    },
                    stop: function() {
                        var t = d.call(this);
                        return e(t).each(function() {
                            var t = e(this);
                            t.data(n) && $(t)
                        })
                    },
                    disable: function(t) {
                        var i = d.call(this);
                        return e(i).each(function() {
                            var i = e(this);
                            if (i.data(n)) {
                                i.data(n);
                                X.call(this, "remove"), A.call(this), t && M.call(this), C.call(this, !0), i.addClass(h[3])
                            }
                        })
                    },
                    destroy: function() {
                        var t = d.call(this);
                        return e(t).each(function() {
                            var r = e(this);
                            if (r.data(n)) {
                                var o = r.data(n),
                                    a = o.opt,
                                    s = e("#mCSB_" + o.idx),
                                    l = e("#mCSB_" + o.idx + "_container"),
                                    c = e(".mCSB_" + o.idx + "_scrollbar");
                                a.live && f(a.liveSelector || e(t).selector), X.call(this, "remove"), A.call(this), M.call(this), r.removeData(n), K(this, "mcs"), c.remove(), l.find("img." + h[2]).removeClass(h[2]), s.replaceWith(l.contents()), r.removeClass(i + " _" + n + "_" + o.idx + " " + h[6] + " " + h[7] + " " + h[5] + " " + h[3]).addClass(h[4])
                            }
                        })
                    }
                },
                d = function() {
                    return "object" != typeof e(this) || e(this).length < 1 ? r : this
                },
                p = function(t) {
                    var i = ["rounded", "rounded-dark", "rounded-dots", "rounded-dots-dark"],
                        n = ["rounded-dots", "rounded-dots-dark", "3d", "3d-dark", "3d-thick", "3d-thick-dark", "inset", "inset-dark", "inset-2", "inset-2-dark", "inset-3", "inset-3-dark"],
                        r = ["minimal", "minimal-dark"],
                        o = ["minimal", "minimal-dark"],
                        a = ["minimal", "minimal-dark"];
                    t.autoDraggerLength = !(e.inArray(t.theme, i) > -1) && t.autoDraggerLength, t.autoExpandScrollbar = !(e.inArray(t.theme, n) > -1) && t.autoExpandScrollbar, t.scrollButtons.enable = !(e.inArray(t.theme, r) > -1) && t.scrollButtons.enable, t.autoHideScrollbar = e.inArray(t.theme, o) > -1 || t.autoHideScrollbar, t.scrollbarPosition = e.inArray(t.theme, a) > -1 ? "outside" : t.scrollbarPosition
                },
                f = function(t) {
                    s[t] && (clearTimeout(s[t]), K(s, t))
                },
                m = function(t) {
                    return "yx" === t || "xy" === t || "auto" === t ? "yx" : "x" === t || "horizontal" === t ? "x" : "y"
                },
                g = function(t) {
                    return "stepped" === t || "pixels" === t || "step" === t || "click" === t ? "stepped" : "stepless"
                },
                v = function() {
                    var t = e(this),
                        r = t.data(n),
                        o = r.opt,
                        a = o.autoExpandScrollbar ? " " + h[1] + "_expand" : "",
                        s = ["<div id='mCSB_" + r.idx + "_scrollbar_vertical' class='mCSB_scrollTools mCSB_" + r.idx + "_scrollbar mCS-" + o.theme + " mCSB_scrollTools_vertical" + a + "'><div class='" + h[12] + "'><div id='mCSB_" + r.idx + "_dragger_vertical' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>", "<div id='mCSB_" + r.idx + "_scrollbar_horizontal' class='mCSB_scrollTools mCSB_" + r.idx + "_scrollbar mCS-" + o.theme + " mCSB_scrollTools_horizontal" + a + "'><div class='" + h[12] + "'><div id='mCSB_" + r.idx + "_dragger_horizontal' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>"],
                        l = "yx" === o.axis ? "mCSB_vertical_horizontal" : "x" === o.axis ? "mCSB_horizontal" : "mCSB_vertical",
                        c = "yx" === o.axis ? s[0] + s[1] : "x" === o.axis ? s[1] : s[0],
                        u = "yx" === o.axis ? "<div id='mCSB_" + r.idx + "_container_wrapper' class='mCSB_container_wrapper' />" : "",
                        d = o.autoHideScrollbar ? " " + h[6] : "",
                        p = "x" !== o.axis && "rtl" === r.langDir ? " " + h[7] : "";
                    o.setWidth && t.css("width", o.setWidth), o.setHeight && t.css("height", o.setHeight), o.setLeft = "y" !== o.axis && "rtl" === r.langDir ? "989999px" : o.setLeft, t.addClass(i + " _" + n + "_" + r.idx + d + p).wrapInner("<div id='mCSB_" + r.idx + "' class='mCustomScrollBox mCS-" + o.theme + " " + l + "'><div id='mCSB_" + r.idx + "_container' class='mCSB_container' style='position:relative; top:" + o.setTop + "; left:" + o.setLeft + ";' dir='" + r.langDir + "' /></div>");
                    var f = e("#mCSB_" + r.idx),
                        m = e("#mCSB_" + r.idx + "_container");
                    "y" === o.axis || o.advanced.autoExpandHorizontalScroll || m.css("width", y(m)), "outside" === o.scrollbarPosition ? ("static" === t.css("position") && t.css("position", "relative"), t.css("overflow", "visible"), f.addClass("mCSB_outside").after(c)) : (f.addClass("mCSB_inside").append(c), m.wrap(u)), x.call(this);
                    var g = [e("#mCSB_" + r.idx + "_dragger_vertical"), e("#mCSB_" + r.idx + "_dragger_horizontal")];
                    g[0].css("min-height", g[0].height()), g[1].css("min-width", g[1].width())
                },
                y = function(t) {
                    var i = [t[0].scrollWidth, Math.max.apply(Math, t.children().map(function() {
                            return e(this).outerWidth(!0)
                        }).get())],
                        n = t.parent().width();
                    return i[0] > n ? i[0] : i[1] > n ? i[1] : "100%"
                },
                _ = function() {
                    var t = e(this),
                        i = t.data(n),
                        r = i.opt,
                        o = e("#mCSB_" + i.idx + "_container");
                    if (r.advanced.autoExpandHorizontalScroll && "y" !== r.axis) {
                        o.css({
                            width: "auto",
                            "min-width": 0,
                            "overflow-x": "scroll"
                        });
                        var a = Math.ceil(o[0].scrollWidth);
                        3 === r.advanced.autoExpandHorizontalScroll || 2 !== r.advanced.autoExpandHorizontalScroll && a > o.parent().width() ? o.css({
                            width: a,
                            "min-width": "100%",
                            "overflow-x": "inherit"
                        }) : o.css({
                            "overflow-x": "inherit",
                            position: "absolute"
                        }).wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />").css({
                            width: Math.ceil(o[0].getBoundingClientRect().right + .4) - Math.floor(o[0].getBoundingClientRect().left),
                            "min-width": "100%",
                            position: "relative"
                        }).unwrap()
                    }
                },
                x = function() {
                    var t = e(this),
                        i = t.data(n),
                        r = i.opt,
                        o = e(".mCSB_" + i.idx + "_scrollbar:first"),
                        a = it(r.scrollButtons.tabindex) ? "tabindex='" + r.scrollButtons.tabindex + "'" : "",
                        s = ["<a href='#' class='" + h[13] + "' " + a + " />", "<a href='#' class='" + h[14] + "' " + a + " />", "<a href='#' class='" + h[15] + "' " + a + " />", "<a href='#' class='" + h[16] + "' " + a + " />"],
                        l = ["x" === r.axis ? s[2] : s[0], "x" === r.axis ? s[3] : s[1], s[2], s[3]];
                    r.scrollButtons.enable && o.prepend(l[0]).append(l[1]).next(".mCSB_scrollTools").prepend(l[2]).append(l[3])
                },
                b = function() {
                    var t = e(this),
                        i = t.data(n),
                        r = e("#mCSB_" + i.idx),
                        o = e("#mCSB_" + i.idx + "_container"),
                        a = [e("#mCSB_" + i.idx + "_dragger_vertical"), e("#mCSB_" + i.idx + "_dragger_horizontal")],
                        s = [r.height() / o.outerHeight(!1), r.width() / o.outerWidth(!1)],
                        c = [parseInt(a[0].css("min-height")), Math.round(s[0] * a[0].parent().height()), parseInt(a[1].css("min-width")), Math.round(s[1] * a[1].parent().width())],
                        h = l && c[1] < c[0] ? c[0] : c[1],
                        u = l && c[3] < c[2] ? c[2] : c[3];
                    a[0].css({
                        height: h,
                        "max-height": a[0].parent().height() - 10
                    }).find(".mCSB_dragger_bar").css({
                        "line-height": c[0] + "px"
                    }), a[1].css({
                        width: u,
                        "max-width": a[1].parent().width() - 10
                    })
                },
                w = function() {
                    var t = e(this),
                        i = t.data(n),
                        r = e("#mCSB_" + i.idx),
                        o = e("#mCSB_" + i.idx + "_container"),
                        a = [e("#mCSB_" + i.idx + "_dragger_vertical"), e("#mCSB_" + i.idx + "_dragger_horizontal")],
                        s = [o.outerHeight(!1) - r.height(), o.outerWidth(!1) - r.width()],
                        l = [s[0] / (a[0].parent().height() - a[0].height()), s[1] / (a[1].parent().width() - a[1].width())];
                    i.scrollRatio = {
                        y: l[0],
                        x: l[1]
                    }
                },
                T = function(t, e, i) {
                    var n = i ? h[0] + "_expanded" : "",
                        r = t.closest(".mCSB_scrollTools");
                    "active" === e ? (t.toggleClass(h[0] + " " + n), r.toggleClass(h[1]), t[0]._draggable = t[0]._draggable ? 0 : 1) : t[0]._draggable || ("hide" === e ? (t.removeClass(h[0]), r.removeClass(h[1])) : (t.addClass(h[0]), r.addClass(h[1])))
                },
                S = function() {
                    var t = e(this),
                        i = t.data(n),
                        r = e("#mCSB_" + i.idx),
                        o = e("#mCSB_" + i.idx + "_container"),
                        a = null == i.overflowed ? o.height() : o.outerHeight(!1),
                        s = null == i.overflowed ? o.width() : o.outerWidth(!1),
                        l = o[0].scrollHeight,
                        c = o[0].scrollWidth;
                    return l > a && (a = l), c > s && (s = c), [a > r.height(), s > r.width()]
                },
                M = function() {
                    var t = e(this),
                        i = t.data(n),
                        r = i.opt,
                        o = e("#mCSB_" + i.idx),
                        a = e("#mCSB_" + i.idx + "_container"),
                        s = [e("#mCSB_" + i.idx + "_dragger_vertical"), e("#mCSB_" + i.idx + "_dragger_horizontal")];
                    if ($(t), ("x" !== r.axis && !i.overflowed[0] || "y" === r.axis && i.overflowed[0]) && (s[0].add(a).css("top", 0), Y(t, "_resetY")), "y" !== r.axis && !i.overflowed[1] || "x" === r.axis && i.overflowed[1]) {
                        var l = dx = 0;
                        "rtl" === i.langDir && (l = o.width() - a.outerWidth(!1), dx = Math.abs(l / i.scrollRatio.x)), a.css("left", l), s[1].css("left", dx), Y(t, "_resetX")
                    }
                },
                E = function() {
                    function t() {
                        a = setTimeout(function() {
                            e.event.special.mousewheel ? (clearTimeout(a), O.call(i[0])) : t()
                        }, 100)
                    }
                    var i = e(this),
                        r = i.data(n),
                        o = r.opt;
                    if (!r.bindEvents) {
                        if (R.call(this), o.contentTouchScroll && L.call(this), k.call(this), o.mouseWheel.enable) {
                            var a;
                            t()
                        }
                        U.call(this), z.call(this), o.advanced.autoScrollOnFocus && F.call(this), o.scrollButtons.enable && H.call(this), o.keyboard.enable && j.call(this), r.bindEvents = !0
                    }
                },
                A = function() {
                    var t = e(this),
                        i = t.data(n),
                        r = i.opt,
                        o = n + "_" + i.idx,
                        a = ".mCSB_" + i.idx + "_scrollbar",
                        s = e("#mCSB_" + i.idx + ",#mCSB_" + i.idx + "_container,#mCSB_" + i.idx + "_container_wrapper," + a + " ." + h[12] + ",#mCSB_" + i.idx + "_dragger_vertical,#mCSB_" + i.idx + "_dragger_horizontal," + a + ">a"),
                        l = e("#mCSB_" + i.idx + "_container");
                    r.advanced.releaseDraggableSelectors && s.add(e(r.advanced.releaseDraggableSelectors)), r.advanced.extraDraggableSelectors && s.add(e(r.advanced.extraDraggableSelectors)), i.bindEvents && (e(document).add(e(!I() || top.document)).unbind("." + o), s.each(function() {
                        e(this).unbind("." + o)
                    }), clearTimeout(t[0]._focusTimeout), K(t[0], "_focusTimeout"), clearTimeout(i.sequential.step), K(i.sequential, "step"), clearTimeout(l[0].onCompleteTimeout), K(l[0], "onCompleteTimeout"), i.bindEvents = !1)
                },
                C = function(t) {
                    var i = e(this),
                        r = i.data(n),
                        o = r.opt,
                        a = e("#mCSB_" + r.idx + "_container_wrapper"),
                        s = a.length ? a : e("#mCSB_" + r.idx + "_container"),
                        l = [e("#mCSB_" + r.idx + "_scrollbar_vertical"), e("#mCSB_" + r.idx + "_scrollbar_horizontal")],
                        c = [l[0].find(".mCSB_dragger"), l[1].find(".mCSB_dragger")];
                    "x" !== o.axis && (r.overflowed[0] && !t ? (l[0].add(c[0]).add(l[0].children("a")).css("display", "block"), s.removeClass(h[8] + " " + h[10])) : (o.alwaysShowScrollbar ? (2 !== o.alwaysShowScrollbar && c[0].css("display", "none"), s.removeClass(h[10])) : (l[0].css("display", "none"), s.addClass(h[10])), s.addClass(h[8]))), "y" !== o.axis && (r.overflowed[1] && !t ? (l[1].add(c[1]).add(l[1].children("a")).css("display", "block"), s.removeClass(h[9] + " " + h[11])) : (o.alwaysShowScrollbar ? (2 !== o.alwaysShowScrollbar && c[1].css("display", "none"), s.removeClass(h[11])) : (l[1].css("display", "none"), s.addClass(h[11])), s.addClass(h[9]))), r.overflowed[0] || r.overflowed[1] ? i.removeClass(h[5]) : i.addClass(h[5])
                },
                P = function(t) {
                    var i = t.type,
                        n = t.target.ownerDocument !== document && null !== frameElement ? [e(frameElement).offset().top, e(frameElement).offset().left] : null,
                        r = I() && t.target.ownerDocument !== top.document && null !== frameElement ? [e(t.view.frameElement).offset().top, e(t.view.frameElement).offset().left] : [0, 0];
                    switch (i) {
                        case "pointerdown":
                        case "MSPointerDown":
                        case "pointermove":
                        case "MSPointerMove":
                        case "pointerup":
                        case "MSPointerUp":
                            return n ? [t.originalEvent.pageY - n[0] + r[0], t.originalEvent.pageX - n[1] + r[1], !1] : [t.originalEvent.pageY, t.originalEvent.pageX, !1];
                        case "touchstart":
                        case "touchmove":
                        case "touchend":
                            var o = t.originalEvent.touches[0] || t.originalEvent.changedTouches[0],
                                a = t.originalEvent.touches.length || t.originalEvent.changedTouches.length;
                            return t.target.ownerDocument !== document ? [o.screenY, o.screenX, a > 1] : [o.pageY, o.pageX, a > 1];
                        default:
                            return n ? [t.pageY - n[0] + r[0], t.pageX - n[1] + r[1], !1] : [t.pageY, t.pageX, !1]
                    }
                },
                R = function() {
                    function t(t, e, n, r) {
                        if (p[0].idleTimer = h.scrollInertia < 233 ? 250 : 0, i.attr("id") === d[1]) var o = "x",
                            l = (i[0].offsetLeft - e + r) * s.scrollRatio.x;
                        else var o = "y",
                            l = (i[0].offsetTop - t + n) * s.scrollRatio.y;
                        Y(a, l.toString(), {
                            dir: o,
                            drag: !0
                        })
                    }
                    var i, r, o, a = e(this),
                        s = a.data(n),
                        h = s.opt,
                        u = n + "_" + s.idx,
                        d = ["mCSB_" + s.idx + "_dragger_vertical", "mCSB_" + s.idx + "_dragger_horizontal"],
                        p = e("#mCSB_" + s.idx + "_container"),
                        f = e("#" + d[0] + ",#" + d[1]),
                        m = h.advanced.releaseDraggableSelectors ? f.add(e(h.advanced.releaseDraggableSelectors)) : f,
                        g = h.advanced.extraDraggableSelectors ? e(!I() || top.document).add(e(h.advanced.extraDraggableSelectors)) : e(!I() || top.document);
                    f.bind("contextmenu." + u, function(t) {
                        t.preventDefault()
                    }).bind("mousedown." + u + " touchstart." + u + " pointerdown." + u + " MSPointerDown." + u, function(t) {
                        if (t.stopImmediatePropagation(), t.preventDefault(), tt(t)) {
                            c = !0, l && (document.onselectstart = function() {
                                return !1
                            }), N.call(p, !1), $(a), i = e(this);
                            var n = i.offset(),
                                s = P(t)[0] - n.top,
                                u = P(t)[1] - n.left,
                                d = i.height() + n.top,
                                f = i.width() + n.left;
                            s < d && s > 0 && u < f && u > 0 && (r = s, o = u), T(i, "active", h.autoExpandScrollbar)
                        }
                    }).bind("touchmove." + u, function(e) {
                        e.stopImmediatePropagation(), e.preventDefault();
                        var n = i.offset(),
                            a = P(e)[0] - n.top,
                            s = P(e)[1] - n.left;
                        t(r, o, a, s)
                    }), e(document).add(g).bind("mousemove." + u + " pointermove." + u + " MSPointerMove." + u, function(e) {
                        if (i) {
                            var n = i.offset(),
                                a = P(e)[0] - n.top,
                                s = P(e)[1] - n.left;
                            if (r === a && o === s) return;
                            t(r, o, a, s)
                        }
                    }).add(m).bind("mouseup." + u + " touchend." + u + " pointerup." + u + " MSPointerUp." + u, function(t) {
                        i && (T(i, "active", h.autoExpandScrollbar), i = null), c = !1, l && (document.onselectstart = null), N.call(p, !0)
                    })
                },
                L = function() {
                    function i(e) {
                        if (!et(e) || c || P(e)[2]) return void(t = 0);
                        t = 1, w = 0, T = 0, h = 1, S.removeClass("mCS_touch_action");
                        var i = R.offset();
                        u = P(e)[0] - i.top, d = P(e)[1] - i.left, B = [P(e)[0], P(e)[1]]
                    }

                    function r(t) {
                        if (et(t) && !c && !P(t)[2] && (E.documentTouchScroll || t.preventDefault(), t.stopImmediatePropagation(), (!T || w) && h)) {
                            g = Q();
                            var e = C.offset(),
                                i = P(t)[0] - e.top,
                                n = P(t)[1] - e.left,
                                r = "mcsLinearOut";
                            if (k.push(i), O.push(n), B[2] = Math.abs(P(t)[0] - B[0]), B[3] = Math.abs(P(t)[1] - B[1]), M.overflowed[0]) var o = L[0].parent().height() - L[0].height(),
                                a = u - i > 0 && i - u > -(o * M.scrollRatio.y) && (2 * B[3] < B[2] || "yx" === E.axis);
                            if (M.overflowed[1]) var s = L[1].parent().width() - L[1].width(),
                                p = d - n > 0 && n - d > -(s * M.scrollRatio.x) && (2 * B[2] < B[3] || "yx" === E.axis);
                            a || p ? (z || t.preventDefault(), w = 1) : (T = 1, S.addClass("mCS_touch_action")), z && t.preventDefault(), x = "yx" === E.axis ? [u - i, d - n] : "x" === E.axis ? [null, d - n] : [u - i, null], R[0].idleTimer = 250, M.overflowed[0] && l(x[0], D, r, "y", "all", !0), M.overflowed[1] && l(x[1], D, r, "x", N, !0)
                        }
                    }

                    function o(e) {
                        if (!et(e) || c || P(e)[2]) return void(t = 0);
                        t = 1, e.stopImmediatePropagation(), $(S), m = Q();
                        var i = C.offset();
                        p = P(e)[0] - i.top, f = P(e)[1] - i.left, k = [], O = []
                    }

                    function a(t) {
                        if (et(t) && !c && !P(t)[2]) {
                            h = 0, t.stopImmediatePropagation(), w = 0, T = 0, v = Q();
                            var e = C.offset(),
                                i = P(t)[0] - e.top,
                                n = P(t)[1] - e.left;
                            if (!(v - g > 30)) {
                                _ = 1e3 / (v - m);
                                var r = "mcsEaseOut",
                                    o = _ < 2.5,
                                    a = o ? [k[k.length - 2], O[O.length - 2]] : [0, 0];
                                y = o ? [i - a[0], n - a[1]] : [i - p, n - f];
                                var u = [Math.abs(y[0]), Math.abs(y[1])];
                                _ = o ? [Math.abs(y[0] / 4), Math.abs(y[1] / 4)] : [_, _];
                                var d = [Math.abs(R[0].offsetTop) - y[0] * s(u[0] / _[0], _[0]), Math.abs(R[0].offsetLeft) - y[1] * s(u[1] / _[1], _[1])];
                                x = "yx" === E.axis ? [d[0], d[1]] : "x" === E.axis ? [null, d[1]] : [d[0], null], b = [4 * u[0] + E.scrollInertia, 4 * u[1] + E.scrollInertia];
                                var S = parseInt(E.contentTouchScroll) || 0;
                                x[0] = u[0] > S ? x[0] : 0, x[1] = u[1] > S ? x[1] : 0, M.overflowed[0] && l(x[0], b[0], r, "y", N, !1), M.overflowed[1] && l(x[1], b[1], r, "x", N, !1)
                            }
                        }
                    }

                    function s(t, e) {
                        var i = [1.5 * e, 2 * e, e / 1.5, e / 2];
                        return t > 90 ? e > 4 ? i[0] : i[3] : t > 60 ? e > 3 ? i[3] : i[2] : t > 30 ? e > 8 ? i[1] : e > 6 ? i[0] : e > 4 ? e : i[2] : e > 8 ? e : i[3]
                    }

                    function l(t, e, i, n, r, o) {
                        t && Y(S, t.toString(), {
                            dur: e,
                            scrollEasing: i,
                            dir: n,
                            overwrite: r,
                            drag: o
                        })
                    }
                    var h, u, d, p, f, m, g, v, y, _, x, b, w, T, S = e(this),
                        M = S.data(n),
                        E = M.opt,
                        A = n + "_" + M.idx,
                        C = e("#mCSB_" + M.idx),
                        R = e("#mCSB_" + M.idx + "_container"),
                        L = [e("#mCSB_" + M.idx + "_dragger_vertical"), e("#mCSB_" + M.idx + "_dragger_horizontal")],
                        k = [],
                        O = [],
                        D = 0,
                        N = "yx" === E.axis ? "none" : "all",
                        B = [],
                        U = R.find("iframe"),
                        F = ["touchstart." + A + " pointerdown." + A + " MSPointerDown." + A, "touchmove." + A + " pointermove." + A + " MSPointerMove." + A, "touchend." + A + " pointerup." + A + " MSPointerUp." + A],
                        z = void 0 !== document.body.style.touchAction && "" !== document.body.style.touchAction;
                    R.bind(F[0], function(t) {
                        i(t)
                    }).bind(F[1], function(t) {
                        r(t)
                    }), C.bind(F[0], function(t) {
                        o(t)
                    }).bind(F[2], function(t) {
                        a(t)
                    }), U.length && U.each(function() {
                        e(this).bind("load", function() {
                            I(this) && e(this.contentDocument || this.contentWindow.document).bind(F[0], function(t) {
                                i(t), o(t)
                            }).bind(F[1], function(t) {
                                r(t)
                            }).bind(F[2], function(t) {
                                a(t)
                            })
                        })
                    })
                },
                k = function() {
                    function i() {
                        return window.getSelection ? window.getSelection().toString() : document.selection && "Control" != document.selection.type ? document.selection.createRange().text : 0
                    }

                    function r(t, e, i) {
                        h.type = i && o ? "stepped" : "stepless", h.scrollAmount = 10, G(a, t, e, "mcsLinearOut", i ? 60 : null)
                    }
                    var o, a = e(this),
                        s = a.data(n),
                        l = s.opt,
                        h = s.sequential,
                        u = n + "_" + s.idx,
                        d = e("#mCSB_" + s.idx + "_container"),
                        p = d.parent();
                    d.bind("mousedown." + u, function(e) {
                        t || o || (o = 1, c = !0)
                    }).add(document).bind("mousemove." + u, function(e) {
                        if (!t && o && i()) {
                            var n = d.offset(),
                                a = P(e)[0] - n.top + d[0].offsetTop,
                                c = P(e)[1] - n.left + d[0].offsetLeft;
                            a > 0 && a < p.height() && c > 0 && c < p.width() ? h.step && r("off", null, "stepped") : ("x" !== l.axis && s.overflowed[0] && (a < 0 ? r("on", 38) : a > p.height() && r("on", 40)), "y" !== l.axis && s.overflowed[1] && (c < 0 ? r("on", 37) : c > p.width() && r("on", 39)))
                        }
                    }).bind("mouseup." + u + " dragend." + u, function(e) {
                        t || (o && (o = 0, r("off", null)), c = !1)
                    })
                },
                O = function() {
                    function t(t, n) {
                        if ($(i), !B(i, t.target)) {
                            var a = "auto" !== o.mouseWheel.deltaFactor ? parseInt(o.mouseWheel.deltaFactor) : l && t.deltaFactor < 100 ? 100 : t.deltaFactor || 100,
                                h = o.scrollInertia;
                            if ("x" === o.axis || "x" === o.mouseWheel.axis) var u = "x",
                                d = [Math.round(a * r.scrollRatio.x), parseInt(o.mouseWheel.scrollAmount)],
                                p = "auto" !== o.mouseWheel.scrollAmount ? d[1] : d[0] >= s.width() ? .9 * s.width() : d[0],
                                f = Math.abs(e("#mCSB_" + r.idx + "_container")[0].offsetLeft),
                                m = c[1][0].offsetLeft,
                                g = c[1].parent().width() - c[1].width(),
                                v = "y" === o.mouseWheel.axis ? t.deltaY || n : t.deltaX;
                            else var u = "y",
                                d = [Math.round(a * r.scrollRatio.y), parseInt(o.mouseWheel.scrollAmount)],
                                p = "auto" !== o.mouseWheel.scrollAmount ? d[1] : d[0] >= s.height() ? .9 * s.height() : d[0],
                                f = Math.abs(e("#mCSB_" + r.idx + "_container")[0].offsetTop),
                                m = c[0][0].offsetTop,
                                g = c[0].parent().height() - c[0].height(),
                                v = t.deltaY || n;
                            "y" === u && !r.overflowed[0] || "x" === u && !r.overflowed[1] || ((o.mouseWheel.invert || t.webkitDirectionInvertedFromDevice) && (v = -v), o.mouseWheel.normalizeDelta && (v = v < 0 ? -1 : 1), (v > 0 && 0 !== m || v < 0 && m !== g || o.mouseWheel.preventDefault) && (t.stopImmediatePropagation(), t.preventDefault()), t.deltaFactor < 5 && !o.mouseWheel.normalizeDelta && (p = t.deltaFactor, h = 17), Y(i, (f - v * p).toString(), {
                                dir: u,
                                dur: h
                            }))
                        }
                    }
                    if (e(this).data(n)) {
                        var i = e(this),
                            r = i.data(n),
                            o = r.opt,
                            a = n + "_" + r.idx,
                            s = e("#mCSB_" + r.idx),
                            c = [e("#mCSB_" + r.idx + "_dragger_vertical"), e("#mCSB_" + r.idx + "_dragger_horizontal")],
                            h = e("#mCSB_" + r.idx + "_container").find("iframe");
                        h.length && h.each(function() {
                            e(this).bind("load", function() {
                                I(this) && e(this.contentDocument || this.contentWindow.document).bind("mousewheel." + a, function(e, i) {
                                    t(e, i)
                                })
                            })
                        }), s.bind("mousewheel." + a, function(e, i) {
                            t(e, i)
                        })
                    }
                },
                D = new Object,
                I = function(t) {
                    var i = !1,
                        n = !1,
                        r = null;
                    if (void 0 === t ? n = "#empty" : void 0 !== e(t).attr("id") && (n = e(t).attr("id")), n !== !1 && void 0 !== D[n]) return D[n];
                    if (t) {
                        try {
                            var o = t.contentDocument || t.contentWindow.document;
                            r = o.body.innerHTML
                        } catch (t) {}
                        i = null !== r
                    } else {
                        try {
                            var o = top.document;
                            r = o.body.innerHTML
                        } catch (t) {}
                        i = null !== r
                    }
                    return n !== !1 && (D[n] = i), i
                },
                N = function(t) {
                    var e = this.find("iframe");
                    if (e.length) {
                        var i = t ? "auto" : "none";
                        e.css("pointer-events", i)
                    }
                },
                B = function(t, i) {
                    var r = i.nodeName.toLowerCase(),
                        o = t.data(n).opt.mouseWheel.disableOver,
                        a = ["select", "textarea"];
                    return e.inArray(r, o) > -1 && !(e.inArray(r, a) > -1 && !e(i).is(":focus"))
                },
                U = function() {
                    var t, i = e(this),
                        r = i.data(n),
                        o = n + "_" + r.idx,
                        a = e("#mCSB_" + r.idx + "_container"),
                        s = a.parent(),
                        l = e(".mCSB_" + r.idx + "_scrollbar ." + h[12]);
                    l.bind("mousedown." + o + " touchstart." + o + " pointerdown." + o + " MSPointerDown." + o, function(i) {
                        c = !0, e(i.target).hasClass("mCSB_dragger") || (t = 1)
                    }).bind("touchend." + o + " pointerup." + o + " MSPointerUp." + o, function(t) {
                        c = !1
                    }).bind("click." + o, function(n) {
                        if (t && (t = 0, e(n.target).hasClass(h[12]) || e(n.target).hasClass("mCSB_draggerRail"))) {
                            $(i);
                            var o = e(this),
                                l = o.find(".mCSB_dragger");
                            if (o.parent(".mCSB_scrollTools_horizontal").length > 0) {
                                if (!r.overflowed[1]) return;
                                var c = "x",
                                    u = n.pageX > l.offset().left ? -1 : 1,
                                    d = Math.abs(a[0].offsetLeft) - u * (.9 * s.width())
                            } else {
                                if (!r.overflowed[0]) return;
                                var c = "y",
                                    u = n.pageY > l.offset().top ? -1 : 1,
                                    d = Math.abs(a[0].offsetTop) - u * (.9 * s.height())
                            }
                            Y(i, d.toString(), {
                                dir: c,
                                scrollEasing: "mcsEaseInOut"
                            })
                        }
                    })
                },
                F = function() {
                    var t = e(this),
                        i = t.data(n),
                        r = i.opt,
                        o = n + "_" + i.idx,
                        a = e("#mCSB_" + i.idx + "_container"),
                        s = a.parent();
                    a.bind("focusin." + o, function(i) {
                        var n = e(document.activeElement),
                            o = a.find(".mCustomScrollBox").length,
                            l = 0;
                        n.is(r.advanced.autoScrollOnFocus) && ($(t), clearTimeout(t[0]._focusTimeout), t[0]._focusTimer = o ? (l + 17) * o : 0, t[0]._focusTimeout = setTimeout(function() {
                            var e = [nt(n)[0], nt(n)[1]],
                                i = [a[0].offsetTop, a[0].offsetLeft],
                                o = [i[0] + e[0] >= 0 && i[0] + e[0] < s.height() - n.outerHeight(!1), i[1] + e[1] >= 0 && i[0] + e[1] < s.width() - n.outerWidth(!1)],
                                c = "yx" !== r.axis || o[0] || o[1] ? "all" : "none";
                            "x" === r.axis || o[0] || Y(t, e[0].toString(), {
                                dir: "y",
                                scrollEasing: "mcsEaseInOut",
                                overwrite: c,
                                dur: l
                            }), "y" === r.axis || o[1] || Y(t, e[1].toString(), {
                                dir: "x",
                                scrollEasing: "mcsEaseInOut",
                                overwrite: c,
                                dur: l
                            })
                        }, t[0]._focusTimer))
                    })
                },
                z = function() {
                    var t = e(this),
                        i = t.data(n),
                        r = n + "_" + i.idx,
                        o = e("#mCSB_" + i.idx + "_container").parent();
                    o.bind("scroll." + r, function(t) {
                        0 === o.scrollTop() && 0 === o.scrollLeft() || e(".mCSB_" + i.idx + "_scrollbar").css("visibility", "hidden")
                    })
                },
                H = function() {
                    var t = e(this),
                        i = t.data(n),
                        r = i.opt,
                        o = i.sequential,
                        a = n + "_" + i.idx,
                        s = ".mCSB_" + i.idx + "_scrollbar",
                        l = e(s + ">a");
                    l.bind("contextmenu." + a, function(t) {
                        t.preventDefault()
                    }).bind("mousedown." + a + " touchstart." + a + " pointerdown." + a + " MSPointerDown." + a + " mouseup." + a + " touchend." + a + " pointerup." + a + " MSPointerUp." + a + " mouseout." + a + " pointerout." + a + " MSPointerOut." + a + " click." + a, function(n) {
                        function a(e, i) {
                            o.scrollAmount = r.scrollButtons.scrollAmount, G(t, e, i)
                        }
                        if (n.preventDefault(), tt(n)) {
                            var s = e(this).attr("class");
                            switch (o.type = r.scrollButtons.scrollType, n.type) {
                                case "mousedown":
                                case "touchstart":
                                case "pointerdown":
                                case "MSPointerDown":
                                    if ("stepped" === o.type) return;
                                    c = !0, i.tweenRunning = !1, a("on", s);
                                    break;
                                case "mouseup":
                                case "touchend":
                                case "pointerup":
                                case "MSPointerUp":
                                case "mouseout":
                                case "pointerout":
                                case "MSPointerOut":
                                    if ("stepped" === o.type) return;
                                    c = !1, o.dir && a("off", s);
                                    break;
                                case "click":
                                    if ("stepped" !== o.type || i.tweenRunning) return;
                                    a("on", s)
                            }
                        }
                    })
                },
                j = function() {
                    function t(t) {
                        function n(t, e) {
                            a.type = o.keyboard.scrollType, a.scrollAmount = o.keyboard.scrollAmount, "stepped" === a.type && r.tweenRunning || G(i, t, e)
                        }
                        switch (t.type) {
                            case "blur":
                                r.tweenRunning && a.dir && n("off", null);
                                break;
                            case "keydown":
                            case "keyup":
                                var s = t.keyCode ? t.keyCode : t.which,
                                    l = "on";
                                if ("x" !== o.axis && (38 === s || 40 === s) || "y" !== o.axis && (37 === s || 39 === s)) {
                                    if ((38 === s || 40 === s) && !r.overflowed[0] || (37 === s || 39 === s) && !r.overflowed[1]) return;
                                    "keyup" === t.type && (l = "off"), e(document.activeElement).is(u) || (t.preventDefault(), t.stopImmediatePropagation(), n(l, s))
                                } else if (33 === s || 34 === s) {
                                    if ((r.overflowed[0] || r.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()), "keyup" === t.type) {
                                        $(i);
                                        var d = 34 === s ? -1 : 1;
                                        if ("x" === o.axis || "yx" === o.axis && r.overflowed[1] && !r.overflowed[0]) var p = "x",
                                            f = Math.abs(c[0].offsetLeft) - d * (.9 * h.width());
                                        else var p = "y",
                                            f = Math.abs(c[0].offsetTop) - d * (.9 * h.height());
                                        Y(i, f.toString(), {
                                            dir: p,
                                            scrollEasing: "mcsEaseInOut"
                                        })
                                    }
                                } else if ((35 === s || 36 === s) && !e(document.activeElement).is(u) && ((r.overflowed[0] || r.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()), "keyup" === t.type)) {
                                    if ("x" === o.axis || "yx" === o.axis && r.overflowed[1] && !r.overflowed[0]) var p = "x",
                                        f = 35 === s ? Math.abs(h.width() - c.outerWidth(!1)) : 0;
                                    else var p = "y",
                                        f = 35 === s ? Math.abs(h.height() - c.outerHeight(!1)) : 0;
                                    Y(i, f.toString(), {
                                        dir: p,
                                        scrollEasing: "mcsEaseInOut"
                                    })
                                }
                        }
                    }
                    var i = e(this),
                        r = i.data(n),
                        o = r.opt,
                        a = r.sequential,
                        s = n + "_" + r.idx,
                        l = e("#mCSB_" + r.idx),
                        c = e("#mCSB_" + r.idx + "_container"),
                        h = c.parent(),
                        u = "input,textarea,select,datalist,keygen,[contenteditable='true']",
                        d = c.find("iframe"),
                        p = ["blur." + s + " keydown." + s + " keyup." + s];
                    d.length && d.each(function() {
                        e(this).bind("load", function() {
                            I(this) && e(this.contentDocument || this.contentWindow.document).bind(p[0], function(e) {
                                t(e)
                            })
                        })
                    }), l.attr("tabindex", "0").bind(p[0], function(e) {
                        t(e)
                    })
                },
                G = function(t, i, r, o, a) {
                    function s(e) {
                        u.snapAmount && (d.scrollAmount = u.snapAmount instanceof Array ? "x" === d.dir[0] ? u.snapAmount[1] : u.snapAmount[0] : u.snapAmount);
                        var i = "stepped" !== d.type,
                            n = a ? a : e ? i ? m / 1.5 : g : 1e3 / 60,
                            r = e ? i ? 7.5 : 40 : 2.5,
                            l = [Math.abs(p[0].offsetTop), Math.abs(p[0].offsetLeft)],
                            h = [c.scrollRatio.y > 10 ? 10 : c.scrollRatio.y, c.scrollRatio.x > 10 ? 10 : c.scrollRatio.x],
                            f = "x" === d.dir[0] ? l[1] + d.dir[1] * (h[1] * r) : l[0] + d.dir[1] * (h[0] * r),
                            v = "x" === d.dir[0] ? l[1] + d.dir[1] * parseInt(d.scrollAmount) : l[0] + d.dir[1] * parseInt(d.scrollAmount),
                            y = "auto" !== d.scrollAmount ? v : f,
                            _ = o ? o : e ? i ? "mcsLinearOut" : "mcsEaseInOut" : "mcsLinear",
                            x = !!e;
                        return e && n < 17 && (y = "x" === d.dir[0] ? l[1] : l[0]), Y(t, y.toString(), {
                            dir: d.dir[0],
                            scrollEasing: _,
                            dur: n,
                            onComplete: x
                        }), e ? void(d.dir = !1) : (clearTimeout(d.step), void(d.step = setTimeout(function() {
                            s()
                        }, n)))
                    }

                    function l() {
                        clearTimeout(d.step), K(d, "step"), $(t)
                    }
                    var c = t.data(n),
                        u = c.opt,
                        d = c.sequential,
                        p = e("#mCSB_" + c.idx + "_container"),
                        f = "stepped" === d.type,
                        m = u.scrollInertia < 26 ? 26 : u.scrollInertia,
                        g = u.scrollInertia < 1 ? 17 : u.scrollInertia;
                    switch (i) {
                        case "on":
                            if (d.dir = [r === h[16] || r === h[15] || 39 === r || 37 === r ? "x" : "y", r === h[13] || r === h[15] || 38 === r || 37 === r ? -1 : 1], $(t), it(r) && "stepped" === d.type) return;
                            s(f);
                            break;
                        case "off":
                            l(), (f || c.tweenRunning && d.dir) && s(!0)
                    }
                },
                V = function(t) {
                    var i = e(this).data(n).opt,
                        r = [];
                    return "function" == typeof t && (t = t()), t instanceof Array ? r = t.length > 1 ? [t[0], t[1]] : "x" === i.axis ? [null, t[0]] : [t[0], null] : (r[0] = t.y ? t.y : t.x || "x" === i.axis ? null : t, r[1] = t.x ? t.x : t.y || "y" === i.axis ? null : t), "function" == typeof r[0] && (r[0] = r[0]()), "function" == typeof r[1] && (r[1] = r[1]()), r
                },
                W = function(t, i) {
                    if (null != t && "undefined" != typeof t) {
                        var r = e(this),
                            o = r.data(n),
                            a = o.opt,
                            s = e("#mCSB_" + o.idx + "_container"),
                            l = s.parent(),
                            c = typeof t;
                        i || (i = "x" === a.axis ? "x" : "y");
                        var h = "x" === i ? s.outerWidth(!1) - l.width() : s.outerHeight(!1) - l.height(),
                            d = "x" === i ? s[0].offsetLeft : s[0].offsetTop,
                            p = "x" === i ? "left" : "top";
                        switch (c) {
                            case "function":
                                return t();
                            case "object":
                                var f = t.jquery ? t : e(t);
                                if (!f.length) return;
                                return "x" === i ? nt(f)[1] : nt(f)[0];
                            case "string":
                            case "number":
                                if (it(t)) return Math.abs(t);
                                if (t.indexOf("%") !== -1) return Math.abs(h * parseInt(t) / 100);
                                if (t.indexOf("-=") !== -1) return Math.abs(d - parseInt(t.split("-=")[1]));
                                if (t.indexOf("+=") !== -1) {
                                    var m = d + parseInt(t.split("+=")[1]);
                                    return m >= 0 ? 0 : Math.abs(m)
                                }
                                if (t.indexOf("px") !== -1 && it(t.split("px")[0])) return Math.abs(t.split("px")[0]);
                                if ("top" === t || "left" === t) return 0;
                                if ("bottom" === t) return Math.abs(l.height() - s.outerHeight(!1));
                                if ("right" === t) return Math.abs(l.width() - s.outerWidth(!1));
                                if ("first" === t || "last" === t) {
                                    var f = s.find(":" + t);
                                    return "x" === i ? nt(f)[1] : nt(f)[0]
                                }
                                return e(t).length ? "x" === i ? nt(e(t))[1] : nt(e(t))[0] : (s.css(p, t), void u.update.call(null, r[0]))
                        }
                    }
                },
                X = function(t) {
                    function i() {
                        return clearTimeout(d[0].autoUpdate), 0 === s.parents("html").length ? void(s = null) : void(d[0].autoUpdate = setTimeout(function() {
                            return c.advanced.updateOnSelectorChange && (l.poll.change.n = o(), l.poll.change.n !== l.poll.change.o) ? (l.poll.change.o = l.poll.change.n, void a(3)) : c.advanced.updateOnContentResize && (l.poll.size.n = s[0].scrollHeight + s[0].scrollWidth + d[0].offsetHeight + s[0].offsetHeight + s[0].offsetWidth, l.poll.size.n !== l.poll.size.o) ? (l.poll.size.o = l.poll.size.n, void a(1)) : !c.advanced.updateOnImageLoad || "auto" === c.advanced.updateOnImageLoad && "y" === c.axis || (l.poll.img.n = d.find("img").length, l.poll.img.n === l.poll.img.o) ? void((c.advanced.updateOnSelectorChange || c.advanced.updateOnContentResize || c.advanced.updateOnImageLoad) && i()) : (l.poll.img.o = l.poll.img.n, void d.find("img").each(function() {
                                r(this)
                            }))
                        }, c.advanced.autoUpdateTimeout))
                    }

                    function r(t) {
                        function i(t, e) {
                            return function() {
                                return e.apply(t, arguments)
                            }
                        }

                        function n() {
                            this.onload = null, e(t).addClass(h[2]), a(2)
                        }
                        if (e(t).hasClass(h[2])) return void a();
                        var r = new Image;
                        r.onload = i(r, n), r.src = t.src
                    }

                    function o() {
                        c.advanced.updateOnSelectorChange === !0 && (c.advanced.updateOnSelectorChange = "*");
                        var t = 0,
                            e = d.find(c.advanced.updateOnSelectorChange);
                        return c.advanced.updateOnSelectorChange && e.length > 0 && e.each(function() {
                            t += this.offsetHeight + this.offsetWidth
                        }), t
                    }

                    function a(t) {
                        clearTimeout(d[0].autoUpdate), u.update.call(null, s[0], t)
                    }
                    var s = e(this),
                        l = s.data(n),
                        c = l.opt,
                        d = e("#mCSB_" + l.idx + "_container");
                    return t ? (clearTimeout(d[0].autoUpdate), void K(d[0], "autoUpdate")) : void i()
                },
                q = function(t, e, i) {
                    return Math.round(t / e) * e - i
                },
                $ = function(t) {
                    var i = t.data(n),
                        r = e("#mCSB_" + i.idx + "_container,#mCSB_" + i.idx + "_container_wrapper,#mCSB_" + i.idx + "_dragger_vertical,#mCSB_" + i.idx + "_dragger_horizontal");
                    r.each(function() {
                        J.call(this)
                    })
                },
                Y = function(t, i, r) {
                    function o(t) {
                        return l && c.callbacks[t] && "function" == typeof c.callbacks[t]
                    }

                    function a() {
                        return [c.callbacks.alwaysTriggerOffsets || x >= b[0] + S, c.callbacks.alwaysTriggerOffsets || x <= -M]
                    }

                    function s() {
                        var e = [p[0].offsetTop, p[0].offsetLeft],
                            i = [y[0].offsetTop, y[0].offsetLeft],
                            n = [p.outerHeight(!1), p.outerWidth(!1)],
                            o = [d.height(), d.width()];
                        t[0].mcs = {
                            content: p,
                            top: e[0],
                            left: e[1],
                            draggerTop: i[0],
                            draggerLeft: i[1],
                            topPct: Math.round(100 * Math.abs(e[0]) / (Math.abs(n[0]) - o[0])),
                            leftPct: Math.round(100 * Math.abs(e[1]) / (Math.abs(n[1]) - o[1])),
                            direction: r.dir
                        }
                    }
                    var l = t.data(n),
                        c = l.opt,
                        h = {
                            trigger: "internal",
                            dir: "y",
                            scrollEasing: "mcsEaseOut",
                            drag: !1,
                            dur: c.scrollInertia,
                            overwrite: "all",
                            callbacks: !0,
                            onStart: !0,
                            onUpdate: !0,
                            onComplete: !0
                        },
                        r = e.extend(h, r),
                        u = [r.dur, r.drag ? 0 : r.dur],
                        d = e("#mCSB_" + l.idx),
                        p = e("#mCSB_" + l.idx + "_container"),
                        f = p.parent(),
                        m = c.callbacks.onTotalScrollOffset ? V.call(t, c.callbacks.onTotalScrollOffset) : [0, 0],
                        g = c.callbacks.onTotalScrollBackOffset ? V.call(t, c.callbacks.onTotalScrollBackOffset) : [0, 0];
                    if (l.trigger = r.trigger, 0 === f.scrollTop() && 0 === f.scrollLeft() || (e(".mCSB_" + l.idx + "_scrollbar").css("visibility", "visible"), f.scrollTop(0).scrollLeft(0)), "_resetY" !== i || l.contentReset.y || (o("onOverflowYNone") && c.callbacks.onOverflowYNone.call(t[0]), l.contentReset.y = 1), "_resetX" !== i || l.contentReset.x || (o("onOverflowXNone") && c.callbacks.onOverflowXNone.call(t[0]), l.contentReset.x = 1), "_resetY" !== i && "_resetX" !== i) {
                        if (!l.contentReset.y && t[0].mcs || !l.overflowed[0] || (o("onOverflowY") && c.callbacks.onOverflowY.call(t[0]), l.contentReset.x = null), !l.contentReset.x && t[0].mcs || !l.overflowed[1] || (o("onOverflowX") && c.callbacks.onOverflowX.call(t[0]), l.contentReset.x = null), c.snapAmount) {
                            var v = c.snapAmount instanceof Array ? "x" === r.dir ? c.snapAmount[1] : c.snapAmount[0] : c.snapAmount;
                            i = q(i, v, c.snapOffset)
                        }
                        switch (r.dir) {
                            case "x":
                                var y = e("#mCSB_" + l.idx + "_dragger_horizontal"),
                                    _ = "left",
                                    x = p[0].offsetLeft,
                                    b = [d.width() - p.outerWidth(!1), y.parent().width() - y.width()],
                                    w = [i, 0 === i ? 0 : i / l.scrollRatio.x],
                                    S = m[1],
                                    M = g[1],
                                    E = S > 0 ? S / l.scrollRatio.x : 0,
                                    A = M > 0 ? M / l.scrollRatio.x : 0;
                                break;
                            case "y":
                                var y = e("#mCSB_" + l.idx + "_dragger_vertical"),
                                    _ = "top",
                                    x = p[0].offsetTop,
                                    b = [d.height() - p.outerHeight(!1), y.parent().height() - y.height()],
                                    w = [i, 0 === i ? 0 : i / l.scrollRatio.y],
                                    S = m[0],
                                    M = g[0],
                                    E = S > 0 ? S / l.scrollRatio.y : 0,
                                    A = M > 0 ? M / l.scrollRatio.y : 0
                        }
                        w[1] < 0 || 0 === w[0] && 0 === w[1] ? w = [0, 0] : w[1] >= b[1] ? w = [b[0], b[1]] : w[0] = -w[0], t[0].mcs || (s(), o("onInit") && c.callbacks.onInit.call(t[0])), clearTimeout(p[0].onCompleteTimeout), Z(y[0], _, Math.round(w[1]), u[1], r.scrollEasing), !l.tweenRunning && (0 === x && w[0] >= 0 || x === b[0] && w[0] <= b[0]) || Z(p[0], _, Math.round(w[0]), u[0], r.scrollEasing, r.overwrite, {
                            onStart: function() {
                                r.callbacks && r.onStart && !l.tweenRunning && (o("onScrollStart") && (s(), c.callbacks.onScrollStart.call(t[0])), l.tweenRunning = !0, T(y), l.cbOffsets = a())
                            },
                            onUpdate: function() {
                                r.callbacks && r.onUpdate && o("whileScrolling") && (s(), c.callbacks.whileScrolling.call(t[0]))
                            },
                            onComplete: function() {
                                if (r.callbacks && r.onComplete) {
                                    "yx" === c.axis && clearTimeout(p[0].onCompleteTimeout);
                                    var e = p[0].idleTimer || 0;
                                    p[0].onCompleteTimeout = setTimeout(function() {
                                        o("onScroll") && (s(), c.callbacks.onScroll.call(t[0])), o("onTotalScroll") && w[1] >= b[1] - E && l.cbOffsets[0] && (s(), c.callbacks.onTotalScroll.call(t[0])), o("onTotalScrollBack") && w[1] <= A && l.cbOffsets[1] && (s(), c.callbacks.onTotalScrollBack.call(t[0])), l.tweenRunning = !1, p[0].idleTimer = 0, T(y, "hide")
                                    }, e)
                                }
                            }
                        })
                    }
                },
                Z = function(t, e, i, n, r, o, a) {
                    function s() {
                        b.stop || (y || f.call(), y = Q() - v, l(), y >= b.time && (b.time = y > b.time ? y + d - (y - b.time) : y + d - 1, b.time < y + 1 && (b.time = y + 1)), b.time < n ? b.id = p(s) : g.call())
                    }

                    function l() {
                        n > 0 ? (b.currVal = u(b.time, _, w, n, r), x[e] = Math.round(b.currVal) + "px") : x[e] = i + "px", m.call()
                    }

                    function c() {
                        d = 1e3 / 60, b.time = y + d, p = window.requestAnimationFrame ? window.requestAnimationFrame : function(t) {
                            return l(), setTimeout(t, .01)
                        }, b.id = p(s)
                    }

                    function h() {
                        null != b.id && (window.requestAnimationFrame ? window.cancelAnimationFrame(b.id) : clearTimeout(b.id), b.id = null)
                    }

                    function u(t, e, i, n, r) {
                        switch (r) {
                            case "linear":
                            case "mcsLinear":
                                return i * t / n + e;
                            case "mcsLinearOut":
                                return t /= n, t--, i * Math.sqrt(1 - t * t) + e;
                            case "easeInOutSmooth":
                                return t /= n / 2, t < 1 ? i / 2 * t * t + e : (t--, -i / 2 * (t * (t - 2) - 1) + e);
                            case "easeInOutStrong":
                                return t /= n / 2, t < 1 ? i / 2 * Math.pow(2, 10 * (t - 1)) + e : (t--, i / 2 * (-Math.pow(2, -10 * t) + 2) + e);
                            case "easeInOut":
                            case "mcsEaseInOut":
                                return t /= n / 2, t < 1 ? i / 2 * t * t * t + e : (t -= 2, i / 2 * (t * t * t + 2) + e);
                            case "easeOutSmooth":
                                return t /= n, t--, -i * (t * t * t * t - 1) + e;
                            case "easeOutStrong":
                                return i * (-Math.pow(2, -10 * t / n) + 1) + e;
                            case "easeOut":
                            case "mcsEaseOut":
                            default:
                                var o = (t /= n) * t,
                                    a = o * t;
                                return e + i * (.499999999999997 * a * o + -2.5 * o * o + 5.5 * a + -6.5 * o + 4 * t)
                        }
                    }
                    t._mTween || (t._mTween = {
                        top: {},
                        left: {}
                    });
                    var d, p, a = a || {},
                        f = a.onStart || function() {},
                        m = a.onUpdate || function() {},
                        g = a.onComplete || function() {},
                        v = Q(),
                        y = 0,
                        _ = t.offsetTop,
                        x = t.style,
                        b = t._mTween[e];
                    "left" === e && (_ = t.offsetLeft);
                    var w = i - _;
                    b.stop = 0, "none" !== o && h(), c()
                },
                Q = function() {
                    return window.performance && window.performance.now ? window.performance.now() : window.performance && window.performance.webkitNow ? window.performance.webkitNow() : Date.now ? Date.now() : (new Date).getTime()
                },
                J = function() {
                    var t = this;
                    t._mTween || (t._mTween = {
                        top: {},
                        left: {}
                    });
                    for (var e = ["top", "left"], i = 0; i < e.length; i++) {
                        var n = e[i];
                        t._mTween[n].id && (window.requestAnimationFrame ? window.cancelAnimationFrame(t._mTween[n].id) : clearTimeout(t._mTween[n].id), t._mTween[n].id = null, t._mTween[n].stop = 1)
                    }
                },
                K = function(t, e) {
                    try {
                        delete t[e]
                    } catch (i) {
                        t[e] = null
                    }
                },
                tt = function(t) {
                    return !(t.which && 1 !== t.which)
                },
                et = function(t) {
                    var e = t.originalEvent.pointerType;
                    return !(e && "touch" !== e && 2 !== e)
                },
                it = function(t) {
                    return !isNaN(parseFloat(t)) && isFinite(t)
                },
                nt = function(t) {
                    var e = t.parents(".mCSB_container");
                    return [t.offset().top - e.offset().top, t.offset().left - e.offset().left]
                },
                rt = function() {
                    function t() {
                        var t = ["webkit", "moz", "ms", "o"];
                        if ("hidden" in document) return "hidden";
                        for (var e = 0; e < t.length; e++)
                            if (t[e] + "Hidden" in document) return t[e] + "Hidden";
                        return null
                    }
                    var e = t();
                    return !!e && document[e]
                };
            e.fn[i] = function(t) {
                return u[t] ? u[t].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof t && t ? void e.error("Method " + t + " does not exist") : u.init.apply(this, arguments)
            }, e[i] = function(t) {
                return u[t] ? u[t].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof t && t ? void e.error("Method " + t + " does not exist") : u.init.apply(this, arguments)
            }, e[i].defaults = o, window[i] = !0, e(window).bind("load", function() {
                e(r)[i](), e.extend(e.expr[":"], {
                    mcsInView: e.expr[":"].mcsInView || function(t) {
                        var i, n, r = e(t),
                            o = r.parents(".mCSB_container");
                        if (o.length) return i = o.parent(), n = [o[0].offsetTop, o[0].offsetLeft], n[0] + nt(r)[0] >= 0 && n[0] + nt(r)[0] < i.height() - r.outerHeight(!1) && n[1] + nt(r)[1] >= 0 && n[1] + nt(r)[1] < i.width() - r.outerWidth(!1)
                    },
                    mcsInSight: e.expr[":"].mcsInSight || function(t, i, n) {
                        var r, o, a, s, l = e(t),
                            c = l.parents(".mCSB_container"),
                            h = "exact" === n[3] ? [
                                [1, 0],
                                [1, 0]
                            ] : [
                                [.9, .1],
                                [.6, .4]
                            ];
                        if (c.length) return r = [l.outerHeight(!1), l.outerWidth(!1)], a = [c[0].offsetTop + nt(l)[0], c[0].offsetLeft + nt(l)[1]], o = [c.parent()[0].offsetHeight, c.parent()[0].offsetWidth], s = [r[0] < o[0] ? h[0] : h[1], r[1] < o[1] ? h[0] : h[1]], a[0] - o[0] * s[0][0] < 0 && a[0] + r[0] - o[0] * s[0][1] >= 0 && a[1] - o[1] * s[1][0] < 0 && a[1] + r[1] - o[1] * s[1][1] >= 0
                    },
                    mcsOverflow: e.expr[":"].mcsOverflow || function(t) {
                        var i = e(t).data(n);
                        if (i) return i.overflowed[0] || i.overflowed[1]
                    }
                })
            })
        })
    })
}, function(t, e) {
    (function(e) {
        t.exports = e
    }).call(e, {})
}, function(t, e, i) {
    var n, r, o;
    ! function(a) {
        r = [i(1)], n = a, o = "function" == typeof n ? n.apply(e, r) : n, !(void 0 !== o && (t.exports = o))
    }(function(t) {
        function e(e) {
            var a = e || window.event,
                s = l.call(arguments, 1),
                c = 0,
                u = 0,
                d = 0,
                p = 0,
                f = 0,
                m = 0;
            if (e = t.event.fix(a), e.type = "mousewheel", "detail" in a && (d = a.detail * -1), "wheelDelta" in a && (d = a.wheelDelta), "wheelDeltaY" in a && (d = a.wheelDeltaY), "wheelDeltaX" in a && (u = a.wheelDeltaX * -1), "axis" in a && a.axis === a.HORIZONTAL_AXIS && (u = d * -1, d = 0), c = 0 === d ? u : d, "deltaY" in a && (d = a.deltaY * -1, c = d), "deltaX" in a && (u = a.deltaX, 0 === d && (c = u * -1)), 0 !== d || 0 !== u) {
                if (1 === a.deltaMode) {
                    var g = t.data(this, "mousewheel-line-height");
                    c *= g, d *= g, u *= g
                } else if (2 === a.deltaMode) {
                    var v = t.data(this, "mousewheel-page-height");
                    c *= v, d *= v, u *= v
                }
                if (p = Math.max(Math.abs(d), Math.abs(u)), (!o || p < o) && (o = p, n(a, p) && (o /= 40)), n(a, p) && (c /= 40, u /= 40, d /= 40), c = Math[c >= 1 ? "floor" : "ceil"](c / o), u = Math[u >= 1 ? "floor" : "ceil"](u / o), d = Math[d >= 1 ? "floor" : "ceil"](d / o), h.settings.normalizeOffset && this.getBoundingClientRect) {
                    var y = this.getBoundingClientRect();
                    f = e.clientX - y.left, m = e.clientY - y.top
                }
                return e.deltaX = u, e.deltaY = d, e.deltaFactor = o, e.offsetX = f, e.offsetY = m, e.deltaMode = 0, s.unshift(e, c, u, d), r && clearTimeout(r), r = setTimeout(i, 200), (t.event.dispatch || t.event.handle).apply(this, s)
            }
        }

        function i() {
            o = null
        }

        function n(t, e) {
            return h.settings.adjustOldDeltas && "mousewheel" === t.type && e % 120 === 0
        }
        var r, o, a = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
            s = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
            l = Array.prototype.slice;
        if (t.event.fixHooks)
            for (var c = a.length; c;) t.event.fixHooks[a[--c]] = t.event.mouseHooks;
        var h = t.event.special.mousewheel = {
            version: "3.1.12",
            setup: function() {
                if (this.addEventListener)
                    for (var i = s.length; i;) this.addEventListener(s[--i], e, !1);
                else this.onmousewheel = e;
                t.data(this, "mousewheel-line-height", h.getLineHeight(this)), t.data(this, "mousewheel-page-height", h.getPageHeight(this))
            },
            teardown: function() {
                if (this.removeEventListener)
                    for (var i = s.length; i;) this.removeEventListener(s[--i], e, !1);
                else this.onmousewheel = null;
                t.removeData(this, "mousewheel-line-height"), t.removeData(this, "mousewheel-page-height")
            },
            getLineHeight: function(e) {
                var i = t(e),
                    n = i["offsetParent" in t.fn ? "offsetParent" : "parent"]();
                return n.length || (n = t("body")), parseInt(n.css("fontSize"), 10) || parseInt(i.css("fontSize"), 10) || 16
            },
            getPageHeight: function(e) {
                return t(e).height()
            },
            settings: {
                adjustOldDeltas: !0,
                normalizeOffset: !0
            }
        };
        t.fn.extend({
            mousewheel: function(t) {
                return t ? this.bind("mousewheel", t) : this.trigger("mousewheel")
            },
            unmousewheel: function(t) {
                return this.unbind("mousewheel", t)
            }
        })
    })
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(10);
    e.default = function() {
        if ($(".map-holder").length) {
            var t = $(".map-holder"),
                e = JSON.parse($("#mapPoint").html()),
                i = !0;
            e.map(function(e, i) {
                var n = "<div class='point-location' style='\n      top:" + e.positionDot.top + "px;\n      left:" + e.positionDot.left + "px;'></div>";
                return t.append(n), $(".review-slider").append("\n      <div class='slide'>\n        <div class='information'>\n          <span class='name'>" + e.title + "</span>\n          <div class=\"info-row\">\n            <span class='organization'>" + e.organization + '</span>\n            <span class=\'address\'>\n            <svg class="marker_map">\n              <use xlink:href="/images/sprite.svg#marker" />\n            </svg>\n            ' + e.address + "</span>\n          </div>\n          <div class='text map-holder-scroll'>\n            <p>" + e.text + "</p>\n          </div>\n        </div>\n      </div>"), !0
            }), (0, n.reviewsSlider)(), $(window).on("resize", n.reviewsSlider), $(".point-location").each(function(t, n) {
                $(this).on("click", function() {
                    $(this).hasClass("active") ? ($(".review-box").removeClass("active").html(""), $(this).removeClass("active"), i = !0) : ($(".point-location").not(this).removeClass("active"), $(this).addClass("active"), r(e[t]))
                })
            });
            var r = function(t) {
                var e = "\n        <div class='information'>\n          <span class='name'>" + t.title + "</span>\n          <div class=\"info-row\">\n            <span class='organization'>" + t.organization + '</span>\n            <span class=\'address\'>\n            <svg class="marker_map">\n              <use xlink:href="/images/sprite.svg#marker" />\n            </svg>\n            ' + t.address + "</span>\n          </div>\n          <div class='text map-holder-scroll'>\n            <p>" + t.text + "</p>\n          </div>\n        </div>";
                i ? ($(".review-box").append(e).addClass("active").css({
                    top: t.positionPopup.top,
                    left: t.positionPopup.left
                }).attr("data-position", t.position), i = !1) : ($(".review-box").html(e), $(".review-box").find(".image-box").css({
                    opacity: 0
                }), $(".review-box").attr("data-position", t.position).animate({
                    top: t.positionPopup.top,
                    left: t.positionPopup.left
                }, 600, "swing")), $(".map-holder-scroll").mCustomScrollbar()
            }
        }
    }
}, function(t, e, i) {
    "use strict";

    function n() {
        $(".review-slider").length && $(window).width() < 1025 ? r() : $(".review-slider.slick-slider").length && $(".review-slider").slick("unslick"), $(".portfolio-boxs").length && $(window).width() < 768 ? $(".portfolio-boxs").slick({
            slidesToShow: 1,
            slidesToScroll: 1,
            arrows: !1,
            dots: !0
        }) : $(".portfolio-boxs.slick-slider").length && $(".portfolio-boxs").slick("unslick")
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.reviewsSlider = n, i(11);
    var r = function t() {
        t.done || ($(".review-slider").slick({
            slidesToShow: 1,
            slidesToScroll: 1,
            autoplaySpeed: 3e3,
            fade: !0,
            arrows: !1,
            dots: !1,
            responsive: [{
                breakpoint: 767,
                settings: {
                    fade: !1
                }
            }]
        }), $(".map-holder-scroll").mCustomScrollbar(), t.done = !0)
    }
}, function(t, e, i) {
    var n, r, o;
    ! function(a) {
        "use strict";
        r = [i(1)], n = a, o = "function" == typeof n ? n.apply(e, r) : n, !(void 0 !== o && (t.exports = o))
    }(function(t) {
        "use strict";
        var e = window.Slick || {};
        e = function() {
            function e(e, n) {
                var r, o = this;
                o.defaults = {
                    accessibility: !0,
                    adaptiveHeight: !1,
                    appendArrows: t(e),
                    appendDots: t(e),
                    arrows: !0,
                    asNavFor: null,
                    prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                    nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                    autoplay: !1,
                    autoplaySpeed: 3e3,
                    centerMode: !1,
                    centerPadding: "50px",
                    cssEase: "ease",
                    customPaging: function(e, i) {
                        return t('<button type="button" />').text(i + 1)
                    },
                    dots: !1,
                    dotsClass: "slick-dots",
                    draggable: !0,
                    easing: "linear",
                    edgeFriction: .35,
                    fade: !1,
                    focusOnSelect: !1,
                    focusOnChange: !1,
                    infinite: !0,
                    initialSlide: 0,
                    lazyLoad: "ondemand",
                    mobileFirst: !1,
                    pauseOnHover: !0,
                    pauseOnFocus: !0,
                    pauseOnDotsHover: !1,
                    respondTo: "window",
                    responsive: null,
                    rows: 1,
                    rtl: !1,
                    slide: "",
                    slidesPerRow: 1,
                    slidesToShow: 1,
                    slidesToScroll: 1,
                    speed: 500,
                    swipe: !0,
                    swipeToSlide: !1,
                    touchMove: !0,
                    touchThreshold: 5,
                    useCSS: !0,
                    useTransform: !0,
                    variableWidth: !1,
                    vertical: !1,
                    verticalSwiping: !1,
                    waitForAnimate: !0,
                    zIndex: 1e3
                }, o.initials = {
                    animating: !1,
                    dragging: !1,
                    autoPlayTimer: null,
                    currentDirection: 0,
                    currentLeft: null,
                    currentSlide: 0,
                    direction: 1,
                    $dots: null,
                    listWidth: null,
                    listHeight: null,
                    loadIndex: 0,
                    $nextArrow: null,
                    $prevArrow: null,
                    scrolling: !1,
                    slideCount: null,
                    slideWidth: null,
                    $slideTrack: null,
                    $slides: null,
                    sliding: !1,
                    slideOffset: 0,
                    swipeLeft: null,
                    swiping: !1,
                    $list: null,
                    touchObject: {},
                    transformsEnabled: !1,
                    unslicked: !1
                }, t.extend(o, o.initials), o.activeBreakpoint = null, o.animType = null, o.animProp = null, o.breakpoints = [], o.breakpointSettings = [], o.cssTransitions = !1, o.focussed = !1, o.interrupted = !1, o.hidden = "hidden", o.paused = !0, o.positionProp = null, o.respondTo = null, o.rowCount = 1, o.shouldClick = !0, o.$slider = t(e), o.$slidesCache = null, o.transformType = null, o.transitionType = null, o.visibilityChange = "visibilitychange", o.windowWidth = 0, o.windowTimer = null, r = t(e).data("slick") || {}, o.options = t.extend({}, o.defaults, n, r), o.currentSlide = o.options.initialSlide, o.originalSettings = o.options, "undefined" != typeof document.mozHidden ? (o.hidden = "mozHidden", o.visibilityChange = "mozvisibilitychange") : "undefined" != typeof document.webkitHidden && (o.hidden = "webkitHidden", o.visibilityChange = "webkitvisibilitychange"), o.autoPlay = t.proxy(o.autoPlay, o), o.autoPlayClear = t.proxy(o.autoPlayClear, o), o.autoPlayIterator = t.proxy(o.autoPlayIterator, o), o.changeSlide = t.proxy(o.changeSlide, o), o.clickHandler = t.proxy(o.clickHandler, o), o.selectHandler = t.proxy(o.selectHandler, o), o.setPosition = t.proxy(o.setPosition, o), o.swipeHandler = t.proxy(o.swipeHandler, o), o.dragHandler = t.proxy(o.dragHandler, o), o.keyHandler = t.proxy(o.keyHandler, o), o.instanceUid = i++, o.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, o.registerBreakpoints(), o.init(!0)
            }
            var i = 0;
            return e
        }(), e.prototype.activateADA = function() {
            var t = this;
            t.$slideTrack.find(".slick-active").attr({
                "aria-hidden": "false"
            }).find("a, input, button, select").attr({
                tabindex: "0"
            })
        }, e.prototype.addSlide = e.prototype.slickAdd = function(e, i, n) {
            var r = this;
            if ("boolean" == typeof i) n = i, i = null;
            else if (i < 0 || i >= r.slideCount) return !1;
            r.unload(), "number" == typeof i ? 0 === i && 0 === r.$slides.length ? t(e).appendTo(r.$slideTrack) : n ? t(e).insertBefore(r.$slides.eq(i)) : t(e).insertAfter(r.$slides.eq(i)) : n === !0 ? t(e).prependTo(r.$slideTrack) : t(e).appendTo(r.$slideTrack), r.$slides = r.$slideTrack.children(this.options.slide), r.$slideTrack.children(this.options.slide).detach(), r.$slideTrack.append(r.$slides), r.$slides.each(function(e, i) {
                t(i).attr("data-slick-index", e)
            }), r.$slidesCache = r.$slides, r.reinit()
        }, e.prototype.animateHeight = function() {
            var t = this;
            if (1 === t.options.slidesToShow && t.options.adaptiveHeight === !0 && t.options.vertical === !1) {
                var e = t.$slides.eq(t.currentSlide).outerHeight(!0);
                t.$list.animate({
                    height: e
                }, t.options.speed)
            }
        }, e.prototype.animateSlide = function(e, i) {
            var n = {},
                r = this;
            r.animateHeight(), r.options.rtl === !0 && r.options.vertical === !1 && (e = -e), r.transformsEnabled === !1 ? r.options.vertical === !1 ? r.$slideTrack.animate({
                left: e
            }, r.options.speed, r.options.easing, i) : r.$slideTrack.animate({
                top: e
            }, r.options.speed, r.options.easing, i) : r.cssTransitions === !1 ? (r.options.rtl === !0 && (r.currentLeft = -r.currentLeft), t({
                animStart: r.currentLeft
            }).animate({
                animStart: e
            }, {
                duration: r.options.speed,
                easing: r.options.easing,
                step: function(t) {
                    t = Math.ceil(t), r.options.vertical === !1 ? (n[r.animType] = "translate(" + t + "px, 0px)", r.$slideTrack.css(n)) : (n[r.animType] = "translate(0px," + t + "px)", r.$slideTrack.css(n))
                },
                complete: function() {
                    i && i.call()
                }
            })) : (r.applyTransition(), e = Math.ceil(e), r.options.vertical === !1 ? n[r.animType] = "translate3d(" + e + "px, 0px, 0px)" : n[r.animType] = "translate3d(0px," + e + "px, 0px)", r.$slideTrack.css(n), i && setTimeout(function() {
                r.disableTransition(), i.call()
            }, r.options.speed))
        }, e.prototype.getNavTarget = function() {
            var e = this,
                i = e.options.asNavFor;
            return i && null !== i && (i = t(i).not(e.$slider)), i
        }, e.prototype.asNavFor = function(e) {
            var i = this,
                n = i.getNavTarget();
            null !== n && "object" == typeof n && n.each(function() {
                var i = t(this).slick("getSlick");
                i.unslicked || i.slideHandler(e, !0)
            })
        }, e.prototype.applyTransition = function(t) {
            var e = this,
                i = {};
            e.options.fade === !1 ? i[e.transitionType] = e.transformType + " " + e.options.speed + "ms " + e.options.cssEase : i[e.transitionType] = "opacity " + e.options.speed + "ms " + e.options.cssEase, e.options.fade === !1 ? e.$slideTrack.css(i) : e.$slides.eq(t).css(i)
        }, e.prototype.autoPlay = function() {
            var t = this;
            t.autoPlayClear(), t.slideCount > t.options.slidesToShow && (t.autoPlayTimer = setInterval(t.autoPlayIterator, t.options.autoplaySpeed))
        }, e.prototype.autoPlayClear = function() {
            var t = this;
            t.autoPlayTimer && clearInterval(t.autoPlayTimer)
        }, e.prototype.autoPlayIterator = function() {
            var t = this,
                e = t.currentSlide + t.options.slidesToScroll;
            t.paused || t.interrupted || t.focussed || (t.options.infinite === !1 && (1 === t.direction && t.currentSlide + 1 === t.slideCount - 1 ? t.direction = 0 : 0 === t.direction && (e = t.currentSlide - t.options.slidesToScroll, t.currentSlide - 1 === 0 && (t.direction = 1))), t.slideHandler(e))
        }, e.prototype.buildArrows = function() {
            var e = this;
            e.options.arrows === !0 && (e.$prevArrow = t(e.options.prevArrow).addClass("slick-arrow"), e.$nextArrow = t(e.options.nextArrow).addClass("slick-arrow"), e.slideCount > e.options.slidesToShow ? (e.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.prependTo(e.options.appendArrows), e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.appendTo(e.options.appendArrows), e.options.infinite !== !0 && e.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : e.$prevArrow.add(e.$nextArrow).addClass("slick-hidden").attr({
                "aria-disabled": "true",
                tabindex: "-1"
            }))
        }, e.prototype.buildDots = function() {
            var e, i, n = this;
            if (n.options.dots === !0 && n.slideCount > n.options.slidesToShow) {
                for (n.$slider.addClass("slick-dotted"), i = t("<ul />").addClass(n.options.dotsClass), e = 0; e <= n.getDotCount(); e += 1) i.append(t("<li />").append(n.options.customPaging.call(this, n, e)));
                n.$dots = i.appendTo(n.options.appendDots), n.$dots.find("li").first().addClass("slick-active")
            }
        }, e.prototype.buildOut = function() {
            var e = this;
            e.$slides = e.$slider.children(e.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), e.slideCount = e.$slides.length, e.$slides.each(function(e, i) {
                t(i).attr("data-slick-index", e).data("originalStyling", t(i).attr("style") || "")
            }), e.$slider.addClass("slick-slider"), e.$slideTrack = 0 === e.slideCount ? t('<div class="slick-track"/>').appendTo(e.$slider) : e.$slides.wrapAll('<div class="slick-track"/>').parent(), e.$list = e.$slideTrack.wrap('<div class="slick-list"/>').parent(), e.$slideTrack.css("opacity", 0), e.options.centerMode !== !0 && e.options.swipeToSlide !== !0 || (e.options.slidesToScroll = 1), t("img[data-lazy]", e.$slider).not("[src]").addClass("slick-loading"), e.setupInfinite(), e.buildArrows(), e.buildDots(), e.updateDots(), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), e.options.draggable === !0 && e.$list.addClass("draggable")
        }, e.prototype.buildRows = function() {
            var t, e, i, n, r, o, a, s = this;
            if (n = document.createDocumentFragment(), o = s.$slider.children(), s.options.rows > 0) {
                for (a = s.options.slidesPerRow * s.options.rows, r = Math.ceil(o.length / a), t = 0; t < r; t++) {
                    var l = document.createElement("div");
                    for (e = 0; e < s.options.rows; e++) {
                        var c = document.createElement("div");
                        for (i = 0; i < s.options.slidesPerRow; i++) {
                            var h = t * a + (e * s.options.slidesPerRow + i);
                            o.get(h) && c.appendChild(o.get(h))
                        }
                        l.appendChild(c)
                    }
                    n.appendChild(l)
                }
                s.$slider.empty().append(n), s.$slider.children().children().children().css({
                    width: 100 / s.options.slidesPerRow + "%",
                    display: "inline-block"
                })
            }
        }, e.prototype.checkResponsive = function(e, i) {
            var n, r, o, a = this,
                s = !1,
                l = a.$slider.width(),
                c = window.innerWidth || t(window).width();
            if ("window" === a.respondTo ? o = c : "slider" === a.respondTo ? o = l : "min" === a.respondTo && (o = Math.min(c, l)), a.options.responsive && a.options.responsive.length && null !== a.options.responsive) {
                r = null;
                for (n in a.breakpoints) a.breakpoints.hasOwnProperty(n) && (a.originalSettings.mobileFirst === !1 ? o < a.breakpoints[n] && (r = a.breakpoints[n]) : o > a.breakpoints[n] && (r = a.breakpoints[n]));
                null !== r ? null !== a.activeBreakpoint ? (r !== a.activeBreakpoint || i) && (a.activeBreakpoint = r, "unslick" === a.breakpointSettings[r] ? a.unslick(r) : (a.options = t.extend({}, a.originalSettings, a.breakpointSettings[r]), e === !0 && (a.currentSlide = a.options.initialSlide), a.refresh(e)), s = r) : (a.activeBreakpoint = r, "unslick" === a.breakpointSettings[r] ? a.unslick(r) : (a.options = t.extend({}, a.originalSettings, a.breakpointSettings[r]), e === !0 && (a.currentSlide = a.options.initialSlide), a.refresh(e)), s = r) : null !== a.activeBreakpoint && (a.activeBreakpoint = null, a.options = a.originalSettings, e === !0 && (a.currentSlide = a.options.initialSlide), a.refresh(e), s = r), e || s === !1 || a.$slider.trigger("breakpoint", [a, s])
            }
        }, e.prototype.changeSlide = function(e, i) {
            var n, r, o, a = this,
                s = t(e.currentTarget);
            switch (s.is("a") && e.preventDefault(), s.is("li") || (s = s.closest("li")), o = a.slideCount % a.options.slidesToScroll !== 0, n = o ? 0 : (a.slideCount - a.currentSlide) % a.options.slidesToScroll, e.data.message) {
                case "previous":
                    r = 0 === n ? a.options.slidesToScroll : a.options.slidesToShow - n, a.slideCount > a.options.slidesToShow && a.slideHandler(a.currentSlide - r, !1, i);
                    break;
                case "next":
                    r = 0 === n ? a.options.slidesToScroll : n, a.slideCount > a.options.slidesToShow && a.slideHandler(a.currentSlide + r, !1, i);
                    break;
                case "index":
                    var l = 0 === e.data.index ? 0 : e.data.index || s.index() * a.options.slidesToScroll;
                    a.slideHandler(a.checkNavigable(l), !1, i), s.children().trigger("focus");
                    break;
                default:
                    return
            }
        }, e.prototype.checkNavigable = function(t) {
            var e, i, n = this;
            if (e = n.getNavigableIndexes(), i = 0, t > e[e.length - 1]) t = e[e.length - 1];
            else
                for (var r in e) {
                    if (t < e[r]) {
                        t = i;
                        break
                    }
                    i = e[r]
                }
            return t
        }, e.prototype.cleanUpEvents = function() {
            var e = this;
            e.options.dots && null !== e.$dots && (t("li", e.$dots).off("click.slick", e.changeSlide).off("mouseenter.slick", t.proxy(e.interrupt, e, !0)).off("mouseleave.slick", t.proxy(e.interrupt, e, !1)), e.options.accessibility === !0 && e.$dots.off("keydown.slick", e.keyHandler)), e.$slider.off("focus.slick blur.slick"), e.options.arrows === !0 && e.slideCount > e.options.slidesToShow && (e.$prevArrow && e.$prevArrow.off("click.slick", e.changeSlide), e.$nextArrow && e.$nextArrow.off("click.slick", e.changeSlide), e.options.accessibility === !0 && (e.$prevArrow && e.$prevArrow.off("keydown.slick", e.keyHandler), e.$nextArrow && e.$nextArrow.off("keydown.slick", e.keyHandler))), e.$list.off("touchstart.slick mousedown.slick", e.swipeHandler), e.$list.off("touchmove.slick mousemove.slick", e.swipeHandler), e.$list.off("touchend.slick mouseup.slick", e.swipeHandler), e.$list.off("touchcancel.slick mouseleave.slick", e.swipeHandler), e.$list.off("click.slick", e.clickHandler), t(document).off(e.visibilityChange, e.visibility), e.cleanUpSlideEvents(), e.options.accessibility === !0 && e.$list.off("keydown.slick", e.keyHandler), e.options.focusOnSelect === !0 && t(e.$slideTrack).children().off("click.slick", e.selectHandler), t(window).off("orientationchange.slick.slick-" + e.instanceUid, e.orientationChange), t(window).off("resize.slick.slick-" + e.instanceUid, e.resize), t("[draggable!=true]", e.$slideTrack).off("dragstart", e.preventDefault), t(window).off("load.slick.slick-" + e.instanceUid, e.setPosition)
        }, e.prototype.cleanUpSlideEvents = function() {
            var e = this;
            e.$list.off("mouseenter.slick", t.proxy(e.interrupt, e, !0)), e.$list.off("mouseleave.slick", t.proxy(e.interrupt, e, !1))
        }, e.prototype.cleanUpRows = function() {
            var t, e = this;
            e.options.rows > 0 && (t = e.$slides.children().children(), t.removeAttr("style"), e.$slider.empty().append(t))
        }, e.prototype.clickHandler = function(t) {
            var e = this;
            e.shouldClick === !1 && (t.stopImmediatePropagation(), t.stopPropagation(), t.preventDefault())
        }, e.prototype.destroy = function(e) {
            var i = this;
            i.autoPlayClear(), i.touchObject = {}, i.cleanUpEvents(), t(".slick-cloned", i.$slider).detach(), i.$dots && i.$dots.remove(), i.$prevArrow && i.$prevArrow.length && (i.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), i.htmlExpr.test(i.options.prevArrow) && i.$prevArrow.remove()), i.$nextArrow && i.$nextArrow.length && (i.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), i.htmlExpr.test(i.options.nextArrow) && i.$nextArrow.remove()), i.$slides && (i.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function() {
                t(this).attr("style", t(this).data("originalStyling"))
            }), i.$slideTrack.children(this.options.slide).detach(), i.$slideTrack.detach(), i.$list.detach(), i.$slider.append(i.$slides)), i.cleanUpRows(), i.$slider.removeClass("slick-slider"), i.$slider.removeClass("slick-initialized"), i.$slider.removeClass("slick-dotted"), i.unslicked = !0, e || i.$slider.trigger("destroy", [i])
        }, e.prototype.disableTransition = function(t) {
            var e = this,
                i = {};
            i[e.transitionType] = "", e.options.fade === !1 ? e.$slideTrack.css(i) : e.$slides.eq(t).css(i)
        }, e.prototype.fadeSlide = function(t, e) {
            var i = this;
            i.cssTransitions === !1 ? (i.$slides.eq(t).css({
                zIndex: i.options.zIndex
            }), i.$slides.eq(t).animate({
                opacity: 1
            }, i.options.speed, i.options.easing, e)) : (i.applyTransition(t), i.$slides.eq(t).css({
                opacity: 1,
                zIndex: i.options.zIndex
            }), e && setTimeout(function() {
                i.disableTransition(t), e.call()
            }, i.options.speed))
        }, e.prototype.fadeSlideOut = function(t) {
            var e = this;
            e.cssTransitions === !1 ? e.$slides.eq(t).animate({
                opacity: 0,
                zIndex: e.options.zIndex - 2
            }, e.options.speed, e.options.easing) : (e.applyTransition(t), e.$slides.eq(t).css({
                opacity: 0,
                zIndex: e.options.zIndex - 2
            }))
        }, e.prototype.filterSlides = e.prototype.slickFilter = function(t) {
            var e = this;
            null !== t && (e.$slidesCache = e.$slides, e.unload(), e.$slideTrack.children(this.options.slide).detach(), e.$slidesCache.filter(t).appendTo(e.$slideTrack), e.reinit())
        }, e.prototype.focusHandler = function() {
            var e = this;
            e.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*", function(i) {
                i.stopImmediatePropagation();
                var n = t(this);
                setTimeout(function() {
                    e.options.pauseOnFocus && (e.focussed = n.is(":focus"), e.autoPlay())
                }, 0)
            })
        }, e.prototype.getCurrent = e.prototype.slickCurrentSlide = function() {
            var t = this;
            return t.currentSlide
        }, e.prototype.getDotCount = function() {
            var t = this,
                e = 0,
                i = 0,
                n = 0;
            if (t.options.infinite === !0)
                if (t.slideCount <= t.options.slidesToShow) ++n;
                else
                    for (; e < t.slideCount;) ++n, e = i + t.options.slidesToScroll, i += t.options.slidesToScroll <= t.options.slidesToShow ? t.options.slidesToScroll : t.options.slidesToShow;
            else if (t.options.centerMode === !0) n = t.slideCount;
            else if (t.options.asNavFor)
                for (; e < t.slideCount;) ++n, e = i + t.options.slidesToScroll, i += t.options.slidesToScroll <= t.options.slidesToShow ? t.options.slidesToScroll : t.options.slidesToShow;
            else n = 1 + Math.ceil((t.slideCount - t.options.slidesToShow) / t.options.slidesToScroll);
            return n - 1
        }, e.prototype.getLeft = function(t) {
            var e, i, n, r, o = this,
                a = 0;
            return o.slideOffset = 0, i = o.$slides.first().outerHeight(!0), o.options.infinite === !0 ? (o.slideCount > o.options.slidesToShow && (o.slideOffset = o.slideWidth * o.options.slidesToShow * -1, r = -1, o.options.vertical === !0 && o.options.centerMode === !0 && (2 === o.options.slidesToShow ? r = -1.5 : 1 === o.options.slidesToShow && (r = -2)), a = i * o.options.slidesToShow * r), o.slideCount % o.options.slidesToScroll !== 0 && t + o.options.slidesToScroll > o.slideCount && o.slideCount > o.options.slidesToShow && (t > o.slideCount ? (o.slideOffset = (o.options.slidesToShow - (t - o.slideCount)) * o.slideWidth * -1, a = (o.options.slidesToShow - (t - o.slideCount)) * i * -1) : (o.slideOffset = o.slideCount % o.options.slidesToScroll * o.slideWidth * -1, a = o.slideCount % o.options.slidesToScroll * i * -1))) : t + o.options.slidesToShow > o.slideCount && (o.slideOffset = (t + o.options.slidesToShow - o.slideCount) * o.slideWidth, a = (t + o.options.slidesToShow - o.slideCount) * i), o.slideCount <= o.options.slidesToShow && (o.slideOffset = 0, a = 0), o.options.centerMode === !0 && o.slideCount <= o.options.slidesToShow ? o.slideOffset = o.slideWidth * Math.floor(o.options.slidesToShow) / 2 - o.slideWidth * o.slideCount / 2 : o.options.centerMode === !0 && o.options.infinite === !0 ? o.slideOffset += o.slideWidth * Math.floor(o.options.slidesToShow / 2) - o.slideWidth : o.options.centerMode === !0 && (o.slideOffset = 0, o.slideOffset += o.slideWidth * Math.floor(o.options.slidesToShow / 2)), e = o.options.vertical === !1 ? t * o.slideWidth * -1 + o.slideOffset : t * i * -1 + a, o.options.variableWidth === !0 && (n = o.slideCount <= o.options.slidesToShow || o.options.infinite === !1 ? o.$slideTrack.children(".slick-slide").eq(t) : o.$slideTrack.children(".slick-slide").eq(t + o.options.slidesToShow), e = o.options.rtl === !0 ? n[0] ? (o.$slideTrack.width() - n[0].offsetLeft - n.width()) * -1 : 0 : n[0] ? n[0].offsetLeft * -1 : 0, o.options.centerMode === !0 && (n = o.slideCount <= o.options.slidesToShow || o.options.infinite === !1 ? o.$slideTrack.children(".slick-slide").eq(t) : o.$slideTrack.children(".slick-slide").eq(t + o.options.slidesToShow + 1), e = o.options.rtl === !0 ? n[0] ? (o.$slideTrack.width() - n[0].offsetLeft - n.width()) * -1 : 0 : n[0] ? n[0].offsetLeft * -1 : 0, e += (o.$list.width() - n.outerWidth()) / 2)), e
        }, e.prototype.getOption = e.prototype.slickGetOption = function(t) {
            var e = this;
            return e.options[t]
        }, e.prototype.getNavigableIndexes = function() {
            var t, e = this,
                i = 0,
                n = 0,
                r = [];
            for (e.options.infinite === !1 ? t = e.slideCount : (i = e.options.slidesToScroll * -1, n = e.options.slidesToScroll * -1, t = 2 * e.slideCount); i < t;) r.push(i), i = n + e.options.slidesToScroll, n += e.options.slidesToScroll <= e.options.slidesToShow ? e.options.slidesToScroll : e.options.slidesToShow;
            return r
        }, e.prototype.getSlick = function() {
            return this
        }, e.prototype.getSlideCount = function() {
            var e, i, n, r = this;
            return n = r.options.centerMode === !0 ? r.slideWidth * Math.floor(r.options.slidesToShow / 2) : 0, r.options.swipeToSlide === !0 ? (r.$slideTrack.find(".slick-slide").each(function(e, o) {
                if (o.offsetLeft - n + t(o).outerWidth() / 2 > r.swipeLeft * -1) return i = o, !1
            }), e = Math.abs(t(i).attr("data-slick-index") - r.currentSlide) || 1) : r.options.slidesToScroll
        }, e.prototype.goTo = e.prototype.slickGoTo = function(t, e) {
            var i = this;
            i.changeSlide({
                data: {
                    message: "index",
                    index: parseInt(t)
                }
            }, e)
        }, e.prototype.init = function(e) {
            var i = this;
            t(i.$slider).hasClass("slick-initialized") || (t(i.$slider).addClass("slick-initialized"), i.buildRows(), i.buildOut(), i.setProps(), i.startLoad(), i.loadSlider(), i.initializeEvents(), i.updateArrows(), i.updateDots(), i.checkResponsive(!0), i.focusHandler()), e && i.$slider.trigger("init", [i]), i.options.accessibility === !0 && i.initADA(), i.options.autoplay && (i.paused = !1, i.autoPlay())
        }, e.prototype.initADA = function() {
            var e = this,
                i = Math.ceil(e.slideCount / e.options.slidesToShow),
                n = e.getNavigableIndexes().filter(function(t) {
                    return t >= 0 && t < e.slideCount
                });
            e.$slides.add(e.$slideTrack.find(".slick-cloned")).attr({
                "aria-hidden": "true",
                tabindex: "-1"
            }).find("a, input, button, select").attr({
                tabindex: "-1"
            }), null !== e.$dots && (e.$slides.not(e.$slideTrack.find(".slick-cloned")).each(function(i) {
                var r = n.indexOf(i);
                if (t(this).attr({
                        role: "tabpanel",
                        id: "slick-slide" + e.instanceUid + i,
                        tabindex: -1
                    }), r !== -1) {
                    var o = "slick-slide-control" + e.instanceUid + r;
                    t("#" + o).length && t(this).attr({
                        "aria-describedby": o
                    })
                }
            }), e.$dots.attr("role", "tablist").find("li").each(function(r) {
                var o = n[r];
                t(this).attr({
                    role: "presentation"
                }), t(this).find("button").first().attr({
                    role: "tab",
                    id: "slick-slide-control" + e.instanceUid + r,
                    "aria-controls": "slick-slide" + e.instanceUid + o,
                    "aria-label": r + 1 + " of " + i,
                    "aria-selected": null,
                    tabindex: "-1"
                })
            }).eq(e.currentSlide).find("button").attr({
                "aria-selected": "true",
                tabindex: "0"
            }).end());
            for (var r = e.currentSlide, o = r + e.options.slidesToShow; r < o; r++) e.options.focusOnChange ? e.$slides.eq(r).attr({
                tabindex: "0"
            }) : e.$slides.eq(r).removeAttr("tabindex");
            e.activateADA()
        }, e.prototype.initArrowEvents = function() {
            var t = this;
            t.options.arrows === !0 && t.slideCount > t.options.slidesToShow && (t.$prevArrow.off("click.slick").on("click.slick", {
                message: "previous"
            }, t.changeSlide), t.$nextArrow.off("click.slick").on("click.slick", {
                message: "next"
            }, t.changeSlide), t.options.accessibility === !0 && (t.$prevArrow.on("keydown.slick", t.keyHandler), t.$nextArrow.on("keydown.slick", t.keyHandler)))
        }, e.prototype.initDotEvents = function() {
            var e = this;
            e.options.dots === !0 && e.slideCount > e.options.slidesToShow && (t("li", e.$dots).on("click.slick", {
                message: "index"
            }, e.changeSlide), e.options.accessibility === !0 && e.$dots.on("keydown.slick", e.keyHandler)), e.options.dots === !0 && e.options.pauseOnDotsHover === !0 && e.slideCount > e.options.slidesToShow && t("li", e.$dots).on("mouseenter.slick", t.proxy(e.interrupt, e, !0)).on("mouseleave.slick", t.proxy(e.interrupt, e, !1))
        }, e.prototype.initSlideEvents = function() {
            var e = this;
            e.options.pauseOnHover && (e.$list.on("mouseenter.slick", t.proxy(e.interrupt, e, !0)), e.$list.on("mouseleave.slick", t.proxy(e.interrupt, e, !1)))
        }, e.prototype.initializeEvents = function() {
            var e = this;
            e.initArrowEvents(), e.initDotEvents(), e.initSlideEvents(), e.$list.on("touchstart.slick mousedown.slick", {
                action: "start"
            }, e.swipeHandler), e.$list.on("touchmove.slick mousemove.slick", {
                action: "move"
            }, e.swipeHandler), e.$list.on("touchend.slick mouseup.slick", {
                action: "end"
            }, e.swipeHandler), e.$list.on("touchcancel.slick mouseleave.slick", {
                action: "end"
            }, e.swipeHandler), e.$list.on("click.slick", e.clickHandler), t(document).on(e.visibilityChange, t.proxy(e.visibility, e)), e.options.accessibility === !0 && e.$list.on("keydown.slick", e.keyHandler), e.options.focusOnSelect === !0 && t(e.$slideTrack).children().on("click.slick", e.selectHandler), t(window).on("orientationchange.slick.slick-" + e.instanceUid, t.proxy(e.orientationChange, e)), t(window).on("resize.slick.slick-" + e.instanceUid, t.proxy(e.resize, e)), t("[draggable!=true]", e.$slideTrack).on("dragstart", e.preventDefault), t(window).on("load.slick.slick-" + e.instanceUid, e.setPosition), t(e.setPosition)
        }, e.prototype.initUI = function() {
            var t = this;
            t.options.arrows === !0 && t.slideCount > t.options.slidesToShow && (t.$prevArrow.show(), t.$nextArrow.show()), t.options.dots === !0 && t.slideCount > t.options.slidesToShow && t.$dots.show()
        }, e.prototype.keyHandler = function(t) {
            var e = this;
            t.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === t.keyCode && e.options.accessibility === !0 ? e.changeSlide({
                data: {
                    message: e.options.rtl === !0 ? "next" : "previous"
                }
            }) : 39 === t.keyCode && e.options.accessibility === !0 && e.changeSlide({
                data: {
                    message: e.options.rtl === !0 ? "previous" : "next"
                }
            }))
        }, e.prototype.lazyLoad = function() {
            function e(e) {
                t("img[data-lazy]", e).each(function() {
                    var e = t(this),
                        i = t(this).attr("data-lazy"),
                        n = t(this).attr("data-srcset"),
                        r = t(this).attr("data-sizes") || a.$slider.attr("data-sizes"),
                        o = document.createElement("img");
                    o.onload = function() {
                        e.animate({
                            opacity: 0
                        }, 100, function() {
                            n && (e.attr("srcset", n), r && e.attr("sizes", r)), e.attr("src", i).animate({
                                opacity: 1
                            }, 200, function() {
                                e.removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading")
                            }), a.$slider.trigger("lazyLoaded", [a, e, i])
                        })
                    }, o.onerror = function() {
                        e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), a.$slider.trigger("lazyLoadError", [a, e, i])
                    }, o.src = i
                })
            }
            var i, n, r, o, a = this;
            if (a.options.centerMode === !0 ? a.options.infinite === !0 ? (r = a.currentSlide + (a.options.slidesToShow / 2 + 1), o = r + a.options.slidesToShow + 2) : (r = Math.max(0, a.currentSlide - (a.options.slidesToShow / 2 + 1)), o = 2 + (a.options.slidesToShow / 2 + 1) + a.currentSlide) : (r = a.options.infinite ? a.options.slidesToShow + a.currentSlide : a.currentSlide, o = Math.ceil(r + a.options.slidesToShow), a.options.fade === !0 && (r > 0 && r--, o <= a.slideCount && o++)), i = a.$slider.find(".slick-slide").slice(r, o), "anticipated" === a.options.lazyLoad)
                for (var s = r - 1, l = o, c = a.$slider.find(".slick-slide"), h = 0; h < a.options.slidesToScroll; h++) s < 0 && (s = a.slideCount - 1), i = i.add(c.eq(s)), i = i.add(c.eq(l)), s--, l++;
            e(i), a.slideCount <= a.options.slidesToShow ? (n = a.$slider.find(".slick-slide"), e(n)) : a.currentSlide >= a.slideCount - a.options.slidesToShow ? (n = a.$slider.find(".slick-cloned").slice(0, a.options.slidesToShow), e(n)) : 0 === a.currentSlide && (n = a.$slider.find(".slick-cloned").slice(a.options.slidesToShow * -1), e(n))
        }, e.prototype.loadSlider = function() {
            var t = this;
            t.setPosition(), t.$slideTrack.css({
                opacity: 1
            }), t.$slider.removeClass("slick-loading"), t.initUI(), "progressive" === t.options.lazyLoad && t.progressiveLazyLoad()
        }, e.prototype.next = e.prototype.slickNext = function() {
            var t = this;
            t.changeSlide({
                data: {
                    message: "next"
                }
            })
        }, e.prototype.orientationChange = function() {
            var t = this;
            t.checkResponsive(), t.setPosition()
        }, e.prototype.pause = e.prototype.slickPause = function() {
            var t = this;
            t.autoPlayClear(), t.paused = !0
        }, e.prototype.play = e.prototype.slickPlay = function() {
            var t = this;
            t.autoPlay(), t.options.autoplay = !0, t.paused = !1, t.focussed = !1, t.interrupted = !1
        }, e.prototype.postSlide = function(e) {
            var i = this;
            if (!i.unslicked && (i.$slider.trigger("afterChange", [i, e]), i.animating = !1, i.slideCount > i.options.slidesToShow && i.setPosition(), i.swipeLeft = null, i.options.autoplay && i.autoPlay(), i.options.accessibility === !0 && (i.initADA(), i.options.focusOnChange))) {
                var n = t(i.$slides.get(i.currentSlide));
                n.attr("tabindex", 0).focus()
            }
        }, e.prototype.prev = e.prototype.slickPrev = function() {
            var t = this;
            t.changeSlide({
                data: {
                    message: "previous"
                }
            })
        }, e.prototype.preventDefault = function(t) {
            t.preventDefault()
        }, e.prototype.progressiveLazyLoad = function(e) {
            e = e || 1;
            var i, n, r, o, a, s = this,
                l = t("img[data-lazy]", s.$slider);
            l.length ? (i = l.first(), n = i.attr("data-lazy"), r = i.attr("data-srcset"), o = i.attr("data-sizes") || s.$slider.attr("data-sizes"), a = document.createElement("img"), a.onload = function() {
                r && (i.attr("srcset", r), o && i.attr("sizes", o)), i.attr("src", n).removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading"), s.options.adaptiveHeight === !0 && s.setPosition(), s.$slider.trigger("lazyLoaded", [s, i, n]), s.progressiveLazyLoad()
            }, a.onerror = function() {
                e < 3 ? setTimeout(function() {
                    s.progressiveLazyLoad(e + 1)
                }, 500) : (i.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), s.$slider.trigger("lazyLoadError", [s, i, n]), s.progressiveLazyLoad())
            }, a.src = n) : s.$slider.trigger("allImagesLoaded", [s])
        }, e.prototype.refresh = function(e) {
            var i, n, r = this;
            n = r.slideCount - r.options.slidesToShow, !r.options.infinite && r.currentSlide > n && (r.currentSlide = n), r.slideCount <= r.options.slidesToShow && (r.currentSlide = 0), i = r.currentSlide, r.destroy(!0), t.extend(r, r.initials, {
                currentSlide: i
            }), r.init(), e || r.changeSlide({
                data: {
                    message: "index",
                    index: i
                }
            }, !1)
        }, e.prototype.registerBreakpoints = function() {
            var e, i, n, r = this,
                o = r.options.responsive || null;
            if ("array" === t.type(o) && o.length) {
                r.respondTo = r.options.respondTo || "window";
                for (e in o)
                    if (n = r.breakpoints.length - 1, o.hasOwnProperty(e)) {
                        for (i = o[e].breakpoint; n >= 0;) r.breakpoints[n] && r.breakpoints[n] === i && r.breakpoints.splice(n, 1), n--;
                        r.breakpoints.push(i), r.breakpointSettings[i] = o[e].settings
                    }
                r.breakpoints.sort(function(t, e) {
                    return r.options.mobileFirst ? t - e : e - t
                })
            }
        }, e.prototype.reinit = function() {
            var e = this;
            e.$slides = e.$slideTrack.children(e.options.slide).addClass("slick-slide"), e.slideCount = e.$slides.length, e.currentSlide >= e.slideCount && 0 !== e.currentSlide && (e.currentSlide = e.currentSlide - e.options.slidesToScroll), e.slideCount <= e.options.slidesToShow && (e.currentSlide = 0), e.registerBreakpoints(), e.setProps(), e.setupInfinite(), e.buildArrows(), e.updateArrows(), e.initArrowEvents(), e.buildDots(), e.updateDots(), e.initDotEvents(), e.cleanUpSlideEvents(), e.initSlideEvents(), e.checkResponsive(!1, !0), e.options.focusOnSelect === !0 && t(e.$slideTrack).children().on("click.slick", e.selectHandler), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), e.setPosition(), e.focusHandler(), e.paused = !e.options.autoplay, e.autoPlay(), e.$slider.trigger("reInit", [e])
        }, e.prototype.resize = function() {
            var e = this;
            t(window).width() !== e.windowWidth && (clearTimeout(e.windowDelay), e.windowDelay = window.setTimeout(function() {
                e.windowWidth = t(window).width(), e.checkResponsive(), e.unslicked || e.setPosition()
            }, 50))
        }, e.prototype.removeSlide = e.prototype.slickRemove = function(t, e, i) {
            var n = this;
            return "boolean" == typeof t ? (e = t, t = e === !0 ? 0 : n.slideCount - 1) : t = e === !0 ? --t : t, !(n.slideCount < 1 || t < 0 || t > n.slideCount - 1) && (n.unload(), i === !0 ? n.$slideTrack.children().remove() : n.$slideTrack.children(this.options.slide).eq(t).remove(), n.$slides = n.$slideTrack.children(this.options.slide), n.$slideTrack.children(this.options.slide).detach(), n.$slideTrack.append(n.$slides), n.$slidesCache = n.$slides, void n.reinit())
        }, e.prototype.setCSS = function(t) {
            var e, i, n = this,
                r = {};
            n.options.rtl === !0 && (t = -t), e = "left" == n.positionProp ? Math.ceil(t) + "px" : "0px", i = "top" == n.positionProp ? Math.ceil(t) + "px" : "0px", r[n.positionProp] = t, n.transformsEnabled === !1 ? n.$slideTrack.css(r) : (r = {}, n.cssTransitions === !1 ? (r[n.animType] = "translate(" + e + ", " + i + ")", n.$slideTrack.css(r)) : (r[n.animType] = "translate3d(" + e + ", " + i + ", 0px)", n.$slideTrack.css(r)))
        }, e.prototype.setDimensions = function() {
            var t = this;
            t.options.vertical === !1 ? t.options.centerMode === !0 && t.$list.css({
                padding: "0px " + t.options.centerPadding
            }) : (t.$list.height(t.$slides.first().outerHeight(!0) * t.options.slidesToShow), t.options.centerMode === !0 && t.$list.css({
                padding: t.options.centerPadding + " 0px"
            })), t.listWidth = t.$list.width(), t.listHeight = t.$list.height(), t.options.vertical === !1 && t.options.variableWidth === !1 ? (t.slideWidth = Math.ceil(t.listWidth / t.options.slidesToShow), t.$slideTrack.width(Math.ceil(t.slideWidth * t.$slideTrack.children(".slick-slide").length))) : t.options.variableWidth === !0 ? t.$slideTrack.width(5e3 * t.slideCount) : (t.slideWidth = Math.ceil(t.listWidth), t.$slideTrack.height(Math.ceil(t.$slides.first().outerHeight(!0) * t.$slideTrack.children(".slick-slide").length)));
            var e = t.$slides.first().outerWidth(!0) - t.$slides.first().width();
            t.options.variableWidth === !1 && t.$slideTrack.children(".slick-slide").width(t.slideWidth - e)
        }, e.prototype.setFade = function() {
            var e, i = this;
            i.$slides.each(function(n, r) {
                e = i.slideWidth * n * -1, i.options.rtl === !0 ? t(r).css({
                    position: "relative",
                    right: e,
                    top: 0,
                    zIndex: i.options.zIndex - 2,
                    opacity: 0
                }) : t(r).css({
                    position: "relative",
                    left: e,
                    top: 0,
                    zIndex: i.options.zIndex - 2,
                    opacity: 0
                })
            }), i.$slides.eq(i.currentSlide).css({
                zIndex: i.options.zIndex - 1,
                opacity: 1
            })
        }, e.prototype.setHeight = function() {
            var t = this;
            if (1 === t.options.slidesToShow && t.options.adaptiveHeight === !0 && t.options.vertical === !1) {
                var e = t.$slides.eq(t.currentSlide).outerHeight(!0);
                t.$list.css("height", e)
            }
        }, e.prototype.setOption = e.prototype.slickSetOption = function() {
            var e, i, n, r, o, a = this,
                s = !1;
            if ("object" === t.type(arguments[0]) ? (n = arguments[0], s = arguments[1], o = "multiple") : "string" === t.type(arguments[0]) && (n = arguments[0], r = arguments[1], s = arguments[2], "responsive" === arguments[0] && "array" === t.type(arguments[1]) ? o = "responsive" : "undefined" != typeof arguments[1] && (o = "single")), "single" === o) a.options[n] = r;
            else if ("multiple" === o) t.each(n, function(t, e) {
                a.options[t] = e
            });
            else if ("responsive" === o)
                for (i in r)
                    if ("array" !== t.type(a.options.responsive)) a.options.responsive = [r[i]];
                    else {
                        for (e = a.options.responsive.length - 1; e >= 0;) a.options.responsive[e].breakpoint === r[i].breakpoint && a.options.responsive.splice(e, 1), e--;
                        a.options.responsive.push(r[i])
                    }
            s && (a.unload(), a.reinit())
        }, e.prototype.setPosition = function() {
            var t = this;
            t.setDimensions(), t.setHeight(), t.options.fade === !1 ? t.setCSS(t.getLeft(t.currentSlide)) : t.setFade(), t.$slider.trigger("setPosition", [t])
        }, e.prototype.setProps = function() {
            var t = this,
                e = document.body.style;
            t.positionProp = t.options.vertical === !0 ? "top" : "left", "top" === t.positionProp ? t.$slider.addClass("slick-vertical") : t.$slider.removeClass("slick-vertical"), void 0 === e.WebkitTransition && void 0 === e.MozTransition && void 0 === e.msTransition || t.options.useCSS === !0 && (t.cssTransitions = !0), t.options.fade && ("number" == typeof t.options.zIndex ? t.options.zIndex < 3 && (t.options.zIndex = 3) : t.options.zIndex = t.defaults.zIndex), void 0 !== e.OTransform && (t.animType = "OTransform", t.transformType = "-o-transform", t.transitionType = "OTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (t.animType = !1)), void 0 !== e.MozTransform && (t.animType = "MozTransform", t.transformType = "-moz-transform", t.transitionType = "MozTransition", void 0 === e.perspectiveProperty && void 0 === e.MozPerspective && (t.animType = !1)), void 0 !== e.webkitTransform && (t.animType = "webkitTransform", t.transformType = "-webkit-transform", t.transitionType = "webkitTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (t.animType = !1)), void 0 !== e.msTransform && (t.animType = "msTransform", t.transformType = "-ms-transform", t.transitionType = "msTransition", void 0 === e.msTransform && (t.animType = !1)), void 0 !== e.transform && t.animType !== !1 && (t.animType = "transform", t.transformType = "transform", t.transitionType = "transition"), t.transformsEnabled = t.options.useTransform && null !== t.animType && t.animType !== !1
        }, e.prototype.setSlideClasses = function(t) {
            var e, i, n, r, o = this;
            if (i = o.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), o.$slides.eq(t).addClass("slick-current"), o.options.centerMode === !0) {
                var a = o.options.slidesToShow % 2 === 0 ? 1 : 0;
                e = Math.floor(o.options.slidesToShow / 2), o.options.infinite === !0 && (t >= e && t <= o.slideCount - 1 - e ? o.$slides.slice(t - e + a, t + e + 1).addClass("slick-active").attr("aria-hidden", "false") : (n = o.options.slidesToShow + t, i.slice(n - e + 1 + a, n + e + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === t ? i.eq(i.length - 1 - o.options.slidesToShow).addClass("slick-center") : t === o.slideCount - 1 && i.eq(o.options.slidesToShow).addClass("slick-center")), o.$slides.eq(t).addClass("slick-center")
            } else t >= 0 && t <= o.slideCount - o.options.slidesToShow ? o.$slides.slice(t, t + o.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : i.length <= o.options.slidesToShow ? i.addClass("slick-active").attr("aria-hidden", "false") : (r = o.slideCount % o.options.slidesToShow, n = o.options.infinite === !0 ? o.options.slidesToShow + t : t, o.options.slidesToShow == o.options.slidesToScroll && o.slideCount - t < o.options.slidesToShow ? i.slice(n - (o.options.slidesToShow - r), n + r).addClass("slick-active").attr("aria-hidden", "false") : i.slice(n, n + o.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false"));
            "ondemand" !== o.options.lazyLoad && "anticipated" !== o.options.lazyLoad || o.lazyLoad()
        }, e.prototype.setupInfinite = function() {
            var e, i, n, r = this;
            if (r.options.fade === !0 && (r.options.centerMode = !1), r.options.infinite === !0 && r.options.fade === !1 && (i = null, r.slideCount > r.options.slidesToShow)) {
                for (n = r.options.centerMode === !0 ? r.options.slidesToShow + 1 : r.options.slidesToShow, e = r.slideCount; e > r.slideCount - n; e -= 1) i = e - 1, t(r.$slides[i]).clone(!0).attr("id", "").attr("data-slick-index", i - r.slideCount).prependTo(r.$slideTrack).addClass("slick-cloned");
                for (e = 0; e < n + r.slideCount; e += 1) i = e, t(r.$slides[i]).clone(!0).attr("id", "").attr("data-slick-index", i + r.slideCount).appendTo(r.$slideTrack).addClass("slick-cloned");
                r.$slideTrack.find(".slick-cloned").find("[id]").each(function() {
                    t(this).attr("id", "")
                })
            }
        }, e.prototype.interrupt = function(t) {
            var e = this;
            t || e.autoPlay(), e.interrupted = t
        }, e.prototype.selectHandler = function(e) {
            var i = this,
                n = t(e.target).is(".slick-slide") ? t(e.target) : t(e.target).parents(".slick-slide"),
                r = parseInt(n.attr("data-slick-index"));
            return r || (r = 0), i.slideCount <= i.options.slidesToShow ? void i.slideHandler(r, !1, !0) : void i.slideHandler(r)
        }, e.prototype.slideHandler = function(t, e, i) {
            var n, r, o, a, s, l = null,
                c = this;
            if (e = e || !1, !(c.animating === !0 && c.options.waitForAnimate === !0 || c.options.fade === !0 && c.currentSlide === t)) return e === !1 && c.asNavFor(t), n = t, l = c.getLeft(n), a = c.getLeft(c.currentSlide), c.currentLeft = null === c.swipeLeft ? a : c.swipeLeft, c.options.infinite === !1 && c.options.centerMode === !1 && (t < 0 || t > c.getDotCount() * c.options.slidesToScroll) ? void(c.options.fade === !1 && (n = c.currentSlide, i !== !0 && c.slideCount > c.options.slidesToShow ? c.animateSlide(a, function() {
                c.postSlide(n)
            }) : c.postSlide(n))) : c.options.infinite === !1 && c.options.centerMode === !0 && (t < 0 || t > c.slideCount - c.options.slidesToScroll) ? void(c.options.fade === !1 && (n = c.currentSlide, i !== !0 && c.slideCount > c.options.slidesToShow ? c.animateSlide(a, function() {
                c.postSlide(n)
            }) : c.postSlide(n))) : (c.options.autoplay && clearInterval(c.autoPlayTimer), r = n < 0 ? c.slideCount % c.options.slidesToScroll !== 0 ? c.slideCount - c.slideCount % c.options.slidesToScroll : c.slideCount + n : n >= c.slideCount ? c.slideCount % c.options.slidesToScroll !== 0 ? 0 : n - c.slideCount : n, c.animating = !0, c.$slider.trigger("beforeChange", [c, c.currentSlide, r]), o = c.currentSlide, c.currentSlide = r, c.setSlideClasses(c.currentSlide), c.options.asNavFor && (s = c.getNavTarget(), s = s.slick("getSlick"), s.slideCount <= s.options.slidesToShow && s.setSlideClasses(c.currentSlide)), c.updateDots(), c.updateArrows(), c.options.fade === !0 ? (i !== !0 ? (c.fadeSlideOut(o), c.fadeSlide(r, function() {
                c.postSlide(r)
            })) : c.postSlide(r), void c.animateHeight()) : void(i !== !0 && c.slideCount > c.options.slidesToShow ? c.animateSlide(l, function() {
                c.postSlide(r)
            }) : c.postSlide(r)))
        }, e.prototype.startLoad = function() {
            var t = this;
            t.options.arrows === !0 && t.slideCount > t.options.slidesToShow && (t.$prevArrow.hide(), t.$nextArrow.hide()), t.options.dots === !0 && t.slideCount > t.options.slidesToShow && t.$dots.hide(), t.$slider.addClass("slick-loading")
        }, e.prototype.swipeDirection = function() {
            var t, e, i, n, r = this;
            return t = r.touchObject.startX - r.touchObject.curX, e = r.touchObject.startY - r.touchObject.curY, i = Math.atan2(e, t), n = Math.round(180 * i / Math.PI), n < 0 && (n = 360 - Math.abs(n)), n <= 45 && n >= 0 ? r.options.rtl === !1 ? "left" : "right" : n <= 360 && n >= 315 ? r.options.rtl === !1 ? "left" : "right" : n >= 135 && n <= 225 ? r.options.rtl === !1 ? "right" : "left" : r.options.verticalSwiping === !0 ? n >= 35 && n <= 135 ? "down" : "up" : "vertical"
        }, e.prototype.swipeEnd = function(t) {
            var e, i, n = this;
            if (n.dragging = !1, n.swiping = !1, n.scrolling) return n.scrolling = !1, !1;
            if (n.interrupted = !1, n.shouldClick = !(n.touchObject.swipeLength > 10), void 0 === n.touchObject.curX) return !1;
            if (n.touchObject.edgeHit === !0 && n.$slider.trigger("edge", [n, n.swipeDirection()]), n.touchObject.swipeLength >= n.touchObject.minSwipe) {
                switch (i = n.swipeDirection()) {
                    case "left":
                    case "down":
                        e = n.options.swipeToSlide ? n.checkNavigable(n.currentSlide + n.getSlideCount()) : n.currentSlide + n.getSlideCount(), n.currentDirection = 0;
                        break;
                    case "right":
                    case "up":
                        e = n.options.swipeToSlide ? n.checkNavigable(n.currentSlide - n.getSlideCount()) : n.currentSlide - n.getSlideCount(), n.currentDirection = 1
                }
                "vertical" != i && (n.slideHandler(e), n.touchObject = {}, n.$slider.trigger("swipe", [n, i]))
            } else n.touchObject.startX !== n.touchObject.curX && (n.slideHandler(n.currentSlide), n.touchObject = {})
        }, e.prototype.swipeHandler = function(t) {
            var e = this;
            if (!(e.options.swipe === !1 || "ontouchend" in document && e.options.swipe === !1 || e.options.draggable === !1 && t.type.indexOf("mouse") !== -1)) switch (e.touchObject.fingerCount = t.originalEvent && void 0 !== t.originalEvent.touches ? t.originalEvent.touches.length : 1, e.touchObject.minSwipe = e.listWidth / e.options.touchThreshold, e.options.verticalSwiping === !0 && (e.touchObject.minSwipe = e.listHeight / e.options.touchThreshold), t.data.action) {
                case "start":
                    e.swipeStart(t);
                    break;
                case "move":
                    e.swipeMove(t);
                    break;
                case "end":
                    e.swipeEnd(t)
            }
        }, e.prototype.swipeMove = function(t) {
            var e, i, n, r, o, a, s = this;
            return o = void 0 !== t.originalEvent ? t.originalEvent.touches : null, !(!s.dragging || s.scrolling || o && 1 !== o.length) && (e = s.getLeft(s.currentSlide), s.touchObject.curX = void 0 !== o ? o[0].pageX : t.clientX, s.touchObject.curY = void 0 !== o ? o[0].pageY : t.clientY, s.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(s.touchObject.curX - s.touchObject.startX, 2))), a = Math.round(Math.sqrt(Math.pow(s.touchObject.curY - s.touchObject.startY, 2))), !s.options.verticalSwiping && !s.swiping && a > 4 ? (s.scrolling = !0, !1) : (s.options.verticalSwiping === !0 && (s.touchObject.swipeLength = a), i = s.swipeDirection(), void 0 !== t.originalEvent && s.touchObject.swipeLength > 4 && (s.swiping = !0, t.preventDefault()), r = (s.options.rtl === !1 ? 1 : -1) * (s.touchObject.curX > s.touchObject.startX ? 1 : -1), s.options.verticalSwiping === !0 && (r = s.touchObject.curY > s.touchObject.startY ? 1 : -1), n = s.touchObject.swipeLength, s.touchObject.edgeHit = !1, s.options.infinite === !1 && (0 === s.currentSlide && "right" === i || s.currentSlide >= s.getDotCount() && "left" === i) && (n = s.touchObject.swipeLength * s.options.edgeFriction, s.touchObject.edgeHit = !0), s.options.vertical === !1 ? s.swipeLeft = e + n * r : s.swipeLeft = e + n * (s.$list.height() / s.listWidth) * r, s.options.verticalSwiping === !0 && (s.swipeLeft = e + n * r), s.options.fade !== !0 && s.options.touchMove !== !1 && (s.animating === !0 ? (s.swipeLeft = null, !1) : void s.setCSS(s.swipeLeft))))
        }, e.prototype.swipeStart = function(t) {
            var e, i = this;
            return i.interrupted = !0, 1 !== i.touchObject.fingerCount || i.slideCount <= i.options.slidesToShow ? (i.touchObject = {}, !1) : (void 0 !== t.originalEvent && void 0 !== t.originalEvent.touches && (e = t.originalEvent.touches[0]), i.touchObject.startX = i.touchObject.curX = void 0 !== e ? e.pageX : t.clientX, i.touchObject.startY = i.touchObject.curY = void 0 !== e ? e.pageY : t.clientY, void(i.dragging = !0))
        }, e.prototype.unfilterSlides = e.prototype.slickUnfilter = function() {
            var t = this;
            null !== t.$slidesCache && (t.unload(), t.$slideTrack.children(this.options.slide).detach(), t.$slidesCache.appendTo(t.$slideTrack), t.reinit())
        }, e.prototype.unload = function() {
            var e = this;
            t(".slick-cloned", e.$slider).remove(), e.$dots && e.$dots.remove(), e.$prevArrow && e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.remove(), e.$nextArrow && e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.remove(), e.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "")
        }, e.prototype.unslick = function(t) {
            var e = this;
            e.$slider.trigger("unslick", [e, t]), e.destroy()
        }, e.prototype.updateArrows = function() {
            var t, e = this;
            t = Math.floor(e.options.slidesToShow / 2), e.options.arrows === !0 && e.slideCount > e.options.slidesToShow && !e.options.infinite && (e.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), e.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === e.currentSlide ? (e.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), e.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : e.currentSlide >= e.slideCount - e.options.slidesToShow && e.options.centerMode === !1 ? (e.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), e.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : e.currentSlide >= e.slideCount - 1 && e.options.centerMode === !0 && (e.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), e.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")))
        }, e.prototype.updateDots = function() {
            var t = this;
            null !== t.$dots && (t.$dots.find("li").removeClass("slick-active").end(), t.$dots.find("li").eq(Math.floor(t.currentSlide / t.options.slidesToScroll)).addClass("slick-active"))
        }, e.prototype.visibility = function() {
            var t = this;
            t.options.autoplay && (document[t.hidden] ? t.interrupted = !0 : t.interrupted = !1)
        }, t.fn.slick = function() {
            var t, i, n = this,
                r = arguments[0],
                o = Array.prototype.slice.call(arguments, 1),
                a = n.length;
            for (t = 0; t < a; t++)
                if ("object" == typeof r || "undefined" == typeof r ? n[t].slick = new e(n[t], r) : i = n[t].slick[r].apply(n[t].slick, o), "undefined" != typeof i) return i;
            return n
        }
    })
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function r(t, e) {
        for (var i in e)
            if ({}.hasOwnProperty.call(e, i)) try {
                e[i].constructor === Object ? t[i] = r(t[i], e[i]) : t[i] = e[i]
            } catch (n) {
                t[i] = e[i]
            }
        return t
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var o = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        a = i(4);
    NodeList.prototype.forEach = Array.prototype.forEach;
    var s = function() {
        function t(e) {
            return n(this, t), this.options = r({
                selector: ".tabs",
                activeClass: "active",
                checkHash: !0,
                tabLinks: "a",
                attribute: "href",
                event: "click"
            }, e), this.init(this.options)
        }
        return o(t, [{
            key: "init",
            value: function(t) {
                var e = this,
                    i = document.querySelectorAll(t.selector);
                i.forEach(function(t) {
                    e.setInitialState(t)
                })
            }
        }, {
            key: "setInitialState",
            value: function(t) {
                var e = this,
                    i = t.querySelectorAll(this.options.tabLinks);
                this.addEvents(i);
                var n = null;
                this.options.checkHash && window.location.hash && (n = t.querySelector("[" + this.options.attribute + '="' + window.location.hash + '"]')), n ? this.setActiveTab(n) : i.forEach(function(t, i) {
                    0 === i && e.setActiveTab(t)
                })
            }
        }, {
            key: "addEvents",
            value: function(t) {
                var e = this;
                t.forEach(function(t, i) {
                    t.addEventListener(e.options.event, function(i) {
                        i.preventDefault(), i.currentTarget.classList.contains(e.options.activeClass) || e.setActiveTab(t)
                    })
                })
            }
        }, {
            key: "setActiveTab",
            value: function(t) {
                t.classList.add(this.options.activeClass);
                var e = t.getAttribute(this.options.attribute),
                    i = document.querySelector(e);
                i && (i.style.display = "block", i.style.opacity = 0, a.TweenMax.fromTo(i, .5, {
                    scale: .6,
                    opacity: 0
                }, {
                    scale: 1,
                    ease: a.Power1.easeOut,
                    opacity: 1
                })), this.removeTabs(t)
            }
        }, {
            key: "removeTabs",
            value: function(t) {
                var e = this,
                    i = t.closest(this.options.selector);
                i.querySelectorAll(this.options.tabLinks).forEach(function(i) {
                    if (i !== t) {
                        i.classList.remove("active");
                        var n = i.getAttribute(e.options.attribute),
                            r = document.querySelector(n);
                        r && (r.style.display = "none")
                    }
                })
            }
        }]), t
    }();
    e.default = s
}, function(t, e, i) {
    (function(t) {
        "use strict";

        function n(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var r = i(2),
            o = n(r),
            a = i(14),
            s = i(17),
            l = n(s),
            c = i(18),
            h = i(19),
            u = i(20),
            d = i(21),
            p = i(22),
            f = i(23),
            m = i(24),
            g = i(25),
            v = i(26),
            y = i(27),
            _ = i(28),
            x = n(_);
        e.default = function() {
            function e() {
                s = (window.innerWidth - r.offsetWidth) / 2, i.style.marginLeft = "-" + s + "px"
            }
            var i = document.getElementById("dots"),
                n = document.querySelector(".video-home .arrow-down");
            window.innerWidth < 768 && i && n && n.parentNode.insertBefore(i, n.nextSibling);
            var r = document.querySelector(".home-order-block"),
                s = null;
            i && (s = (window.innerWidth - r.offsetWidth) / 2, x.default.prepare(), i.style.marginLeft = "-" + s + "px"), i && $(window).on("resize", function() {
                e()
            });
            var _ = function() {
                (0, o.default)(".video-home").once("enter", a.startVideoAnimation), (0, o.default)(".video-home").once("exit", a.finishVideoAnimation), (0, o.default)("header.header").once("enter", l.default), (0, o.default)("footer.footer").once("enter", c.startFooterAnimation), (0, o.default)("footer.footer").once("exit", c.finishFooterAnimation), (0, o.default)(".home-services__item").once("enter", f.startServicesAnimation), (0, o.default)(".home-services").once("exit", f.finishServicesAnimation), (0, o.default)(".portfolio-item").once("enter", h.startPortfolioAnimation), (0, o.default)(".portfolio-holder--home").once("exit", h.finishPortfolioAnimation), (0, o.default)(".what-we-do__text").once("enter", p.startWhatWeDoAnimation), (0, o.default)(".what-we-do").once("exit", p.finishWhatWeDoAnimation), window.innerWidth >= 768 ? (0, o.default)(".what-we-do").on("enter", t.animateDots).on("exit", t.animateDotsStop) : (0, o.default)(".video-home").on("enter", t.animateDots).on("exit", t.animateDotsStop), (0, o.default)(".team-home__item").once("enter", d.startTeamAnimation), (0, o.default)(".team-home").once("exit", d.finishTeamAnimation), (0, o.default)(".creation-mobile").on("enter", function(t) {
                    return t.classList.add("in-view")
                }).on("exit", function(t) {
                    return t.classList.remove("in-view")
                }), (0, o.default)(".clients-home__item").once("enter", u.startClientsAnimation), (0, o.default)(".clients-home").once("exit", u.finishClientsAnimation), (0, o.default)(".map-holder").once("enter", m.startReviewsAnimation), (0, o.default)(".reviews-holder--home").once("exit", m.finishReviewsAnimation), (0, o.default)(".home-tabs").once("enter", g.startHomeTextAnimation), (0, o.default)(".home-text-section").once("exit", g.finishHomeTextAnimation), (0, o.default)(".web-holder li .development-name").once("enter", v.startServicesEnAnimation), (0, o.default)(".web-holder").once("exit", v.finishServicesEnAnimation), (0, o.default)(".technologies-list .technologies-name").once("enter", y.startTechnologiesEnAnimation), (0, o.default)(".our-technologies").once("exit", y.finishTechnologiesEnAnimation)
            };
            _()
        }
    }).call(e, function() {
        return this
    }())
}, function(t, e, i) {
    "use strict";

    function n(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }

    function r() {
        var t = (0, l.default)(".video-lines").width(),
            e = (0, l.default)(".video-lines").height();
        window.innerWidth > 1024 && (c.to(".video-lines__line--item1", .5, {
            x: .1 * t,
            ease: a.Power3.easeOut,
            delay: .5
        }), c.to(".video-lines__line--item2", .4, {
            x: .3 * t,
            ease: a.Power3.easeOut
        }), c.to(".video-lines__line--item3", .3, {
            x: .5 * t + 12,
            ease: a.Power3.easeOut
        }), c.to(".video-lines__line--item4", .2, {
            x: .7 * t,
            ease: a.Power3.easeOut
        }), c.to(".video-lines__line--item5", .1, {
            x: .9 * t,
            ease: a.Power3.easeOut
        })), c.staggerTo(".video-lines__line", .3, {
            backgroundColor: "#fff",
            height: e,
            opacity: .1,
            width: 1,
            ease: a.Bounce.easeOut,
            delay: window.innerWidth > 1024 ? .5 : 0
        }, .1), c.to(".video-text--left", .1, {
            opacity: 1
        }), c.staggerTo(".video-home__subtitle", .2, {
            x: window.innerWidth > 767 ? 145 : 100,
            opacity: 1,
            ease: a.Bounce.easeOut
        }, .4), c.staggerTo(".video-home__title", .5, {
            x: 80,
            opacity: 1,
            ease: a.Power3.easeOut
        }, .5), c.to(".video-text--right", .1, {
            opacity: 1
        }), c.staggerTo(".video-counter", .2, {
            x: -90,
            opacity: 1,
            ease: a.Power3.easeOut,
            onComplete: function() {
                var t = (0, l.default)(this.target).children(".video-counter__text");
                a.TweenMax.to(t, .2, {
                    text: t.data("text"),
                    ease: a.Linear.easeOut
                })
            }
        }, .5)
    }

    function o() {
        c.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startVideoAnimation = r, e.finishVideoAnimation = o;
    var a = i(4),
        s = i(1),
        l = n(s);
    i(15);
    var c = new a.TimelineMax
}, function(t, e, i) {
    var n, r, o;
    (function(a) {
        var s = "undefined" != typeof t && t.exports && "undefined" != typeof a ? a : this || window;
        (s._gsQueue || (s._gsQueue = [])).push(function() {
                "use strict";
                var t = function(e) {
                        var i = e.nodeType,
                            n = "";
                        if (1 === i || 9 === i || 11 === i) {
                            if ("string" == typeof e.textContent) return e.textContent;
                            for (e = e.firstChild; e; e = e.nextSibling) n += t(e)
                        } else if (3 === i || 4 === i) return e.nodeValue;
                        return n
                    },
                    e = "[î-ï£¿]|ï¿½[ï¿½-ï¿½]|ï¿½[ï¿½-ï¿½]|[â-â]|ï¿½[ï¿½-ï¿½]|[ï¿½-ï¿½][ï¿½-ï¿½]",
                    i = new RegExp(e),
                    n = new RegExp(e + "|.", "g"),
                    r = function(t, e) {
                        return "" !== e && e || !i.test(t) ? t.split(e || "") : t.match(n)
                    },
                    o = s._gsDefine.plugin({
                        propName: "text",
                        API: 2,
                        version: "0.6.2",
                        init: function(e, i, n, o) {
                            var a, s = e.nodeName.toUpperCase();
                            if ("function" == typeof i && (i = i(o, e)), this._svg = e.getBBox && ("TEXT" === s || "TSPAN" === s), !("innerHTML" in e || this._svg)) return !1;
                            if (this._target = e, "object" != typeof i && (i = {
                                    value: i
                                }), void 0 === i.value) return this._text = this._original = [""], !0;
                            for (this._delimiter = i.delimiter || "", this._original = r(t(e).replace(/\s+/g, " "), this._delimiter), this._text = r(i.value.replace(/\s+/g, " "), this._delimiter), this._runBackwards = n.vars.runBackwards === !0, this._runBackwards && (s = this._original, this._original = this._text, this._text = s), "string" == typeof i.newClass && (this._newClass = i.newClass, this._hasClass = !0), "string" == typeof i.oldClass && (this._oldClass = i.oldClass, this._hasClass = !0), s = this._original.length - this._text.length, a = s < 0 ? this._original : this._text, this._fillChar = i.fillChar || (i.padSpace ? "&nbsp;" : ""), s < 0 && (s = -s); --s > -1;) a.push(this._fillChar);
                            return !0
                        },
                        set: function(t) {
                            t > 1 ? t = 1 : t < 0 && (t = 0), this._runBackwards && (t = 1 - t);
                            var e, i, n, r = this._text.length,
                                o = t * r + .5 | 0;
                            this._hasClass ? (e = this._newClass && 0 !== o, i = this._oldClass && o !== r, n = (e ? "<span class='" + this._newClass + "'>" : "") + this._text.slice(0, o).join(this._delimiter) + (e ? "</span>" : "") + (i ? "<span class='" + this._oldClass + "'>" : "") + this._delimiter + this._original.slice(o).join(this._delimiter) + (i ? "</span>" : "")) : n = this._text.slice(0, o).join(this._delimiter) + this._delimiter + this._original.slice(o).join(this._delimiter), this._svg ? this._target.textContent = n : this._target.innerHTML = "&nbsp;" === this._fillChar && n.indexOf("  ") !== -1 ? n.split("  ").join("&nbsp;&nbsp;") : n
                        }
                    }),
                    a = o.prototype;
                a._newClass = a._oldClass = a._delimiter = ""
            }), s._gsDefine && s._gsQueue.pop()(),
            function(a) {
                "use strict";
                var l = function() {
                    return (s.GreenSockGlobals || s)[a]
                };
                "undefined" != typeof t && t.exports ? (i(16), t.exports = l()) : (r = [i(16)], n = l, o = "function" == typeof n ? n.apply(e, r) : n, !(void 0 !== o && (t.exports = o)))
            }("TextPlugin")
    }).call(e, function() {
        return this
    }())
}, function(t, e, i) {
    var n, r;
    (function(i) {
        ! function(i, o) {
            "use strict";
            var a = {},
                s = i.document,
                l = i.GreenSockGlobals = i.GreenSockGlobals || i;
            if (l.TweenLite) return l.TweenLite;
            var c, h, u, d, p, f = function(t) {
                    var e, i = t.split("."),
                        n = l;
                    for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
                    return n
                },
                m = f("com.greensock"),
                g = 1e-10,
                v = function(t) {
                    var e, i = [],
                        n = t.length;
                    for (e = 0; e !== n; i.push(t[e++]));
                    return i
                },
                y = function() {},
                _ = function() {
                    var t = Object.prototype.toString,
                        e = t.call([]);
                    return function(i) {
                        return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                    }
                }(),
                x = {},
                b = function(i, s, c, h) {
                    this.sc = x[i] ? x[i].sc : [], x[i] = this, this.gsClass = null, this.func = c;
                    var u = [];
                    this.check = function(d) {
                        for (var p, m, g, v, y = s.length, _ = y; --y > -1;)(p = x[s[y]] || new b(s[y], [])).gsClass ? (u[y] = p.gsClass, _--) : d && p.sc.push(this);
                        if (0 === _ && c) {
                            if (m = ("com.greensock." + i).split("."), g = m.pop(), v = f(m.join("."))[g] = this.gsClass = c.apply(c, u), h)
                                if (l[g] = a[g] = v, "undefined" != typeof t && t.exports)
                                    if (i === o) {
                                        t.exports = a[o] = v;
                                        for (y in a) v[y] = a[y]
                                    } else a[o] && (a[o][g] = v);
                            else n = [], r = function() {
                                return v
                            }.apply(e, n), !(void 0 !== r && (t.exports = r));
                            for (y = 0; y < this.sc.length; y++) this.sc[y].check()
                        }
                    }, this.check(!0)
                },
                w = i._gsDefine = function(t, e, i, n) {
                    return new b(t, e, i, n)
                },
                T = m._class = function(t, e, i) {
                    return e = e || function() {}, w(t, [], function() {
                        return e
                    }, i), e
                };
            w.globals = l;
            var S = [0, 0, 1, 1],
                M = T("easing.Ease", function(t, e, i, n) {
                    this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? S.concat(e) : S
                }, !0),
                E = M.map = {},
                A = M.register = function(t, e, i, n) {
                    for (var r, o, a, s, l = e.split(","), c = l.length, h = (i || "easeIn,easeOut,easeInOut").split(","); --c > -1;)
                        for (o = l[c], r = n ? T("easing." + o, null, !0) : m.easing[o] || {}, a = h.length; --a > -1;) s = h[a], E[o + "." + s] = E[s + o] = r[s] = t.getRatio ? t : t[s] || new t
                };
            for (u = M.prototype, u._calcEnd = !1, u.getRatio = function(t) {
                    if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                    var e = this._type,
                        i = this._power,
                        n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                    return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                }, c = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], h = c.length; --h > -1;) u = c[h] + ",Power" + h, A(new M(null, null, 1, h), u, "easeOut", !0), A(new M(null, null, 2, h), u, "easeIn" + (0 === h ? ",easeNone" : "")), A(new M(null, null, 3, h), u, "easeInOut");
            E.linear = m.easing.Linear.easeIn, E.swing = m.easing.Quad.easeInOut;
            var C = T("events.EventDispatcher", function(t) {
                this._listeners = {}, this._eventTarget = t || this
            });
            u = C.prototype, u.addEventListener = function(t, e, i, n, r) {
                r = r || 0;
                var o, a, s = this._listeners[t],
                    l = 0;
                for (this !== d || p || d.wake(), null == s && (this._listeners[t] = s = []), a = s.length; --a > -1;) o = s[a], o.c === e && o.s === i ? s.splice(a, 1) : 0 === l && o.pr < r && (l = a + 1);
                s.splice(l, 0, {
                    c: e,
                    s: i,
                    up: n,
                    pr: r
                })
            }, u.removeEventListener = function(t, e) {
                var i, n = this._listeners[t];
                if (n)
                    for (i = n.length; --i > -1;)
                        if (n[i].c === e) return void n.splice(i, 1)
            }, u.dispatchEvent = function(t) {
                var e, i, n, r = this._listeners[t];
                if (r)
                    for (e = r.length, e > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;) n = r[e], n && (n.up ? n.c.call(n.s || i, {
                        type: t,
                        target: i
                    }) : n.c.call(n.s || i))
            };
            var P = i.requestAnimationFrame,
                R = i.cancelAnimationFrame,
                L = Date.now || function() {
                    return (new Date).getTime()
                },
                k = L();
            for (c = ["ms", "moz", "webkit", "o"], h = c.length; --h > -1 && !P;) P = i[c[h] + "RequestAnimationFrame"], R = i[c[h] + "CancelAnimationFrame"] || i[c[h] + "CancelRequestAnimationFrame"];
            T("Ticker", function(t, e) {
                var i, n, r, o, a, l = this,
                    c = L(),
                    h = !(e === !1 || !P) && "auto",
                    u = 500,
                    f = 33,
                    m = "tick",
                    v = function(t) {
                        var e, s, h = L() - k;
                        h > u && (c += h - f), k += h, l.time = (k - c) / 1e3, e = l.time - a, (!i || e > 0 || t === !0) && (l.frame++, a += e + (e >= o ? .004 : o - e), s = !0), t !== !0 && (r = n(v)), s && l.dispatchEvent(m)
                    };
                C.call(l), l.time = l.frame = 0, l.tick = function() {
                    v(!0)
                }, l.lagSmoothing = function(t, e) {
                    return arguments.length ? (u = t || 1 / g, void(f = Math.min(e, u, 0))) : u < 1 / g
                }, l.sleep = function() {
                    null != r && (h && R ? R(r) : clearTimeout(r), n = y, r = null, l === d && (p = !1))
                }, l.wake = function(t) {
                    null !== r ? l.sleep() : t ? c += -k + (k = L()) : l.frame > 10 && (k = L() - u + 5), n = 0 === i ? y : h && P ? P : function(t) {
                        return setTimeout(t, 1e3 * (a - l.time) + 1 | 0)
                    }, l === d && (p = !0), v(2)
                }, l.fps = function(t) {
                    return arguments.length ? (i = t, o = 1 / (i || 60), a = this.time + o, void l.wake()) : i
                }, l.useRAF = function(t) {
                    return arguments.length ? (l.sleep(), h = t, void l.fps(i)) : h
                }, l.fps(t), setTimeout(function() {
                    "auto" === h && l.frame < 5 && "hidden" !== (s || {}).visibilityState && l.useRAF(!1)
                }, 1500)
            }), u = m.Ticker.prototype = new m.events.EventDispatcher, u.constructor = m.Ticker;
            var O = T("core.Animation", function(t, e) {
                if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = e.immediateRender === !0, this.data = e.data, this._reversed = e.reversed === !0, K) {
                    p || d.wake();
                    var i = this.vars.useFrames ? J : K;
                    i.add(this, i._time), this.vars.paused && this.paused(!0)
                }
            });
            d = O.ticker = new m.Ticker, u = O.prototype, u._dirty = u._gc = u._initted = u._paused = !1, u._totalTime = u._time = 0, u._rawPrevTime = -1, u._next = u._last = u._onUpdate = u._timeline = u.timeline = null, u._paused = !1;
            var D = function() {
                p && L() - k > 2e3 && ("hidden" !== (s || {}).visibilityState || !d.lagSmoothing()) && d.wake();
                var t = setTimeout(D, 2e3);
                t.unref && t.unref()
            };
            D(), u.play = function(t, e) {
                return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
            }, u.pause = function(t, e) {
                return null != t && this.seek(t, e), this.paused(!0)
            }, u.resume = function(t, e) {
                return null != t && this.seek(t, e), this.paused(!1)
            }, u.seek = function(t, e) {
                return this.totalTime(Number(t), e !== !1)
            }, u.restart = function(t, e) {
                return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0)
            }, u.reverse = function(t, e) {
                return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
            }, u.render = function(t, e, i) {}, u.invalidate = function() {
                return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
            }, u.isActive = function() {
                var t, e = this._timeline,
                    i = this._startTime;
                return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
            }, u._enabled = function(t, e) {
                return p || d.wake(), this._gc = !t, this._active = this.isActive(), e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
            }, u._kill = function(t, e) {
                return this._enabled(!1, !1)
            }, u.kill = function(t, e) {
                return this._kill(t, e), this
            }, u._uncache = function(t) {
                for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                return this
            }, u._swapSelfInParams = function(t) {
                for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
                return i
            }, u._callback = function(t) {
                var e = this.vars,
                    i = e[t],
                    n = e[t + "Params"],
                    r = e[t + "Scope"] || e.callbackScope || this,
                    o = n ? n.length : 0;
                switch (o) {
                    case 0:
                        i.call(r);
                        break;
                    case 1:
                        i.call(r, n[0]);
                        break;
                    case 2:
                        i.call(r, n[0], n[1]);
                        break;
                    default:
                        i.apply(r, n)
                }
            }, u.eventCallback = function(t, e, i, n) {
                if ("on" === (t || "").substr(0, 2)) {
                    var r = this.vars;
                    if (1 === arguments.length) return r[t];
                    null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = _(i) && i.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
                }
                return this
            }, u.delay = function(t) {
                return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay),
                    this._delay = t, this) : this._delay
            }, u.duration = function(t) {
                return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
            }, u.totalDuration = function(t) {
                return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
            }, u.time = function(t, e) {
                return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
            }, u.totalTime = function(t, e, i) {
                if (p || d.wake(), !arguments.length) return this._totalTime;
                if (this._timeline) {
                    if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                        this._dirty && this.totalDuration();
                        var n = this._totalDuration,
                            r = this._timeline;
                        if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                            for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                    }
                    this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (F.length && et(), this.render(t, e, !1), F.length && et())
                }
                return this
            }, u.progress = u.totalProgress = function(t, e) {
                var i = this.duration();
                return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
            }, u.startTime = function(t) {
                return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
            }, u.endTime = function(t) {
                return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
            }, u.timeScale = function(t) {
                if (!arguments.length) return this._timeScale;
                var e, i;
                for (t = t || g, this._timeline && this._timeline.smoothChildTiming && (e = this._pauseTime, i = e || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
                return this
            }, u.reversed = function(t) {
                return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
            }, u.paused = function(t) {
                if (!arguments.length) return this._paused;
                var e, i, n = this._timeline;
                return t != this._paused && n && (p || t || d.wake(), e = n.rawTime(), i = e - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
            };
            var I = T("core.SimpleTimeline", function(t) {
                O.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
            });
            u = I.prototype = new O, u.constructor = I, u.kill()._gc = !1, u._first = u._last = u._recent = null, u._sortChildren = !1, u.add = u.insert = function(t, e, i, n) {
                var r, o;
                if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                    for (o = t._startTime; r && r._startTime > o;) r = r._prev;
                return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
            }, u._remove = function(t, e) {
                return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
            }, u.render = function(t, e, i) {
                var n, r = this._first;
                for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
            }, u.rawTime = function() {
                return p || d.wake(), this._totalTime
            };
            var N = T("TweenLite", function(t, e, n) {
                    if (O.call(this, e, n), this.render = N.prototype.render, null == t) throw "Cannot tween a null target.";
                    this.target = t = "string" != typeof t ? t : N.selector(t) || t;
                    var r, o, a, s = t.jquery || t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType),
                        l = this.vars.overwrite;
                    if (this._overwrite = l = null == l ? Q[N.defaultOverwrite] : "number" == typeof l ? l >> 0 : Q[l], (s || t instanceof Array || t.push && _(t)) && "number" != typeof t[0])
                        for (this._targets = a = v(t), this._propLookup = [], this._siblings = [], r = 0; r < a.length; r++) o = a[r], o ? "string" != typeof o ? o.length && o !== i && o[0] && (o[0] === i || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(v(o))) : (this._siblings[r] = it(o, this, !1), 1 === l && this._siblings[r].length > 1 && rt(o, this, null, 1, this._siblings[r])) : (o = a[r--] = N.selector(o), "string" == typeof o && a.splice(r + 1, 1)) : a.splice(r--, 1);
                    else this._propLookup = {}, this._siblings = it(t, this, !1), 1 === l && this._siblings.length > 1 && rt(t, this, null, 1, this._siblings);
                    (this.vars.immediateRender || 0 === e && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -g, this.render(Math.min(0, -this._delay)))
                }, !0),
                B = function(t) {
                    return t && t.length && t !== i && t[0] && (t[0] === i || t[0].nodeType && t[0].style && !t.nodeType)
                },
                U = function(t, e) {
                    var i, n = {};
                    for (i in t) Z[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!q[i] || q[i] && q[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                    t.css = n
                };
            u = N.prototype = new O, u.constructor = N, u.kill()._gc = !1, u.ratio = 0, u._firstPT = u._targets = u._overwrittenProps = u._startAt = null, u._notifyPluginsOfEnabled = u._lazy = !1, N.version = "1.20.5", N.defaultEase = u._ease = new M(null, null, 1, 1), N.defaultOverwrite = "auto", N.ticker = d, N.autoSleep = 120, N.lagSmoothing = function(t, e) {
                d.lagSmoothing(t, e)
            }, N.selector = i.$ || i.jQuery || function(t) {
                var e = i.$ || i.jQuery;
                return e ? (N.selector = e, e(t)) : (s || (s = i.document), s ? s.querySelectorAll ? s.querySelectorAll(t) : s.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t)
            };
            var F = [],
                z = {},
                H = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                j = /[\+-]=-?[\.\d]/,
                G = function(t) {
                    for (var e, i = this._firstPT, n = 1e-6; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : e < n && e > -n && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                },
                V = function(t, e, i, n) {
                    var r, o, a, s, l, c, h, u = [],
                        d = 0,
                        p = "",
                        f = 0;
                    for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, r = t.match(H) || [], o = e.match(H) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), l = o.length, s = 0; s < l; s++) h = o[s], c = e.substr(d, e.indexOf(h, d) - d), p += c || !s ? c : ",", d += c.length, f ? f = (f + 1) % 5 : "rgba(" === c.substr(-5) && (f = 1), h === r[s] || r.length <= s ? p += h : (p && (u.push(p), p = ""), a = parseFloat(r[s]), u.push(a), u._firstPT = {
                        _next: u._firstPT,
                        t: u,
                        p: u.length - 1,
                        s: a,
                        c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - a) || 0,
                        f: 0,
                        m: f && f < 4 ? Math.round : 0
                    }), d += h.length;
                    return p += e.substr(d), p && u.push(p), u.setRatio = G, j.test(e) && (u.end = null), u
                },
                W = function(t, e, i, n, r, o, a, s, l) {
                    "function" == typeof n && (n = n(l || 0, t));
                    var c, h = typeof t[e],
                        u = "function" !== h ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                        d = "get" !== i ? i : u ? a ? t[u](a) : t[u]() : t[e],
                        p = "string" == typeof n && "=" === n.charAt(1),
                        f = {
                            t: t,
                            p: e,
                            s: d,
                            f: "function" === h,
                            pg: 0,
                            n: r || e,
                            m: o ? "function" == typeof o ? o : Math.round : 0,
                            pr: 0,
                            c: p ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - d || 0
                        };
                    if (("number" != typeof d || "number" != typeof n && !p) && (a || isNaN(d) || !p && isNaN(n) || "boolean" == typeof d || "boolean" == typeof n ? (f.fp = a, c = V(d, p ? parseFloat(f.s) + f.c + (f.s + "").replace(/[0-9\-\.]/g, "") : n, s || N.defaultStringFilter, f), f = {
                            t: c,
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 2,
                            pg: 0,
                            n: r || e,
                            pr: 0,
                            m: 0
                        }) : (f.s = parseFloat(d), p || (f.c = parseFloat(n) - f.s || 0))), f.c) return (f._next = this._firstPT) && (f._next._prev = f), this._firstPT = f, f
                },
                X = N._internals = {
                    isArray: _,
                    isSelector: B,
                    lazyTweens: F,
                    blobDif: V
                },
                q = N._plugins = {},
                $ = X.tweenLookup = {},
                Y = 0,
                Z = X.reservedProps = {
                    ease: 1,
                    delay: 1,
                    overwrite: 1,
                    onComplete: 1,
                    onCompleteParams: 1,
                    onCompleteScope: 1,
                    useFrames: 1,
                    runBackwards: 1,
                    startAt: 1,
                    onUpdate: 1,
                    onUpdateParams: 1,
                    onUpdateScope: 1,
                    onStart: 1,
                    onStartParams: 1,
                    onStartScope: 1,
                    onReverseComplete: 1,
                    onReverseCompleteParams: 1,
                    onReverseCompleteScope: 1,
                    onRepeat: 1,
                    onRepeatParams: 1,
                    onRepeatScope: 1,
                    easeParams: 1,
                    yoyo: 1,
                    immediateRender: 1,
                    repeat: 1,
                    repeatDelay: 1,
                    data: 1,
                    paused: 1,
                    reversed: 1,
                    autoCSS: 1,
                    lazy: 1,
                    onOverwrite: 1,
                    callbackScope: 1,
                    stringFilter: 1,
                    id: 1,
                    yoyoEase: 1
                },
                Q = {
                    none: 0,
                    all: 1,
                    auto: 2,
                    concurrent: 3,
                    allOnStart: 4,
                    preexisting: 5,
                    true: 1,
                    false: 0
                },
                J = O._rootFramesTimeline = new I,
                K = O._rootTimeline = new I,
                tt = 30,
                et = X.lazyRender = function() {
                    var t, e = F.length;
                    for (z = {}; --e > -1;) t = F[e], t && t._lazy !== !1 && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                    F.length = 0
                };
            K._startTime = d.time, J._startTime = d.frame, K._active = J._active = !0, setTimeout(et, 1), O._updateRoot = N.render = function() {
                var t, e, i;
                if (F.length && et(), K.render((d.time - K._startTime) * K._timeScale, !1, !1), J.render((d.frame - J._startTime) * J._timeScale, !1, !1), F.length && et(), d.frame >= tt) {
                    tt = d.frame + (parseInt(N.autoSleep, 10) || 120);
                    for (i in $) {
                        for (e = $[i].tweens, t = e.length; --t > -1;) e[t]._gc && e.splice(t, 1);
                        0 === e.length && delete $[i]
                    }
                    if (i = K._first, (!i || i._paused) && N.autoSleep && !J._first && 1 === d._listeners.tick.length) {
                        for (; i && i._paused;) i = i._next;
                        i || d.sleep()
                    }
                }
            }, d.addEventListener("tick", O._updateRoot);
            var it = function(t, e, i) {
                    var n, r, o = t._gsTweenID;
                    if ($[o || (t._gsTweenID = o = "t" + Y++)] || ($[o] = {
                            target: t,
                            tweens: []
                        }), e && (n = $[o].tweens, n[r = n.length] = e, i))
                        for (; --r > -1;) n[r] === e && n.splice(r, 1);
                    return $[o].tweens
                },
                nt = function(t, e, i, n) {
                    var r, o, a = t.vars.onOverwrite;
                    return a && (r = a(t, e, i, n)), a = N.onOverwrite, a && (o = a(t, e, i, n)), r !== !1 && o !== !1
                },
                rt = function(t, e, i, n, r) {
                    var o, a, s, l;
                    if (1 === n || n >= 4) {
                        for (l = r.length, o = 0; o < l; o++)
                            if ((s = r[o]) !== e) s._gc || s._kill(null, t, e) && (a = !0);
                            else if (5 === n) break;
                        return a
                    }
                    var c, h = e._startTime + g,
                        u = [],
                        d = 0,
                        p = 0 === e._duration;
                    for (o = r.length; --o > -1;)(s = r[o]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (c = c || ot(e, 0, p), 0 === ot(s, c, p) && (u[d++] = s)) : s._startTime <= h && s._startTime + s.totalDuration() / s._timeScale > h && ((p || !s._initted) && h - s._startTime <= 2e-10 || (u[d++] = s)));
                    for (o = d; --o > -1;)
                        if (s = u[o], 2 === n && s._kill(i, t, e) && (a = !0), 2 !== n || !s._firstPT && s._initted) {
                            if (2 !== n && !nt(s, e)) continue;
                            s._enabled(!1, !1) && (a = !0)
                        }
                    return a
                },
                ot = function(t, e, i) {
                    for (var n = t._timeline, r = n._timeScale, o = t._startTime; n._timeline;) {
                        if (o += n._startTime, r *= n._timeScale, n._paused) return -100;
                        n = n._timeline
                    }
                    return o /= r, o > e ? o - e : i && o === e || !t._initted && o - e < 2 * g ? g : (o += t.totalDuration() / t._timeScale / r) > e + g ? 0 : o - e - g
                };
            u._init = function() {
                var t, e, i, n, r, o, a = this.vars,
                    s = this._overwrittenProps,
                    l = this._duration,
                    c = !!a.immediateRender,
                    h = a.ease;
                if (a.startAt) {
                    this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {};
                    for (n in a.startAt) r[n] = a.startAt[n];
                    if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = c && a.lazy !== !1, r.startAt = r.delay = null, r.onUpdate = a.onUpdate, r.onUpdateParams = a.onUpdateParams, r.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = N.to(this.target || {}, 0, r), c)
                        if (this._time > 0) this._startAt = null;
                        else if (0 !== l) return
                } else if (a.runBackwards && 0 !== l)
                    if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                    else {
                        0 !== this._time && (c = !1), i = {};
                        for (n in a) Z[n] && "autoCSS" !== n || (i[n] = a[n]);
                        if (i.overwrite = 0, i.data = "isFromStart", i.lazy = c && a.lazy !== !1, i.immediateRender = c, this._startAt = N.to(this.target, 0, i), c) {
                            if (0 === this._time) return
                        } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                    }
                if (this._ease = h = h ? h instanceof M ? h : "function" == typeof h ? new M(h, a.easeParams) : E[h] || N.defaultEase : N.defaultEase, a.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                    for (o = this._targets.length, t = 0; t < o; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
                else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                if (e && N._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                    for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                this._onUpdate = a.onUpdate, this._initted = !0
            }, u._initProps = function(t, e, n, r, o) {
                var a, s, l, c, h, u;
                if (null == t) return !1;
                z[t._gsTweenID] && et(), this.vars.css || t.style && t !== i && t.nodeType && q.css && this.vars.autoCSS !== !1 && U(this.vars, t);
                for (a in this.vars)
                    if (u = this.vars[a], Z[a]) u && (u instanceof Array || u.push && _(u)) && u.join("").indexOf("{self}") !== -1 && (this.vars[a] = u = this._swapSelfInParams(u, this));
                    else if (q[a] && (c = new q[a])._onInitTween(t, this.vars[a], this, o)) {
                    for (this._firstPT = h = {
                            _next: this._firstPT,
                            t: c,
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 1,
                            n: a,
                            pg: 1,
                            pr: c._priority,
                            m: 0
                        }, s = c._overwriteProps.length; --s > -1;) e[c._overwriteProps[s]] = this._firstPT;
                    (c._priority || c._onInitAllProps) && (l = !0), (c._onDisable || c._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h)
                } else e[a] = W.call(this, t, a, "get", u, a, 0, null, this.vars.stringFilter, o);
                return r && this._kill(r, t) ? this._initProps(t, e, n, r, o) : this._overwrite > 1 && this._firstPT && n.length > 1 && rt(t, this, e, this._overwrite, n) ? (this._kill(e, t), this._initProps(t, e, n, r, o)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (z[t._gsTweenID] = !0), l)
            }, u.render = function(t, e, i) {
                var n, r, o, a, s = this._time,
                    l = this._duration,
                    c = this._rawPrevTime;
                if (t >= l - 1e-7 && t >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (c < 0 || t <= 0 && t >= -1e-7 || c === g && "isPause" !== this.data) && c !== t && (i = !0, c > g && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || c === t ? t : g);
                else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === l && c > 0) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (c >= 0 && (c !== g || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || c === t ? t : g)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
                else if (this._totalTime = this._time = t, this._easeType) {
                    var h = t / l,
                        u = this._easeType,
                        d = this._easePower;
                    (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === d ? h *= h : 2 === d ? h *= h * h : 3 === d ? h *= h * h * h : 4 === d && (h *= h * h * h * h), 1 === u ? this.ratio = 1 - h : 2 === u ? this.ratio = h : t / l < .5 ? this.ratio = h / 2 : this.ratio = 1 - h / 2
                } else this.ratio = this._ease.getRatio(t / l);
                if (this._time !== s || i) {
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = c, F.push(this), void(this._lazy = [t, e]);
                        this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0), 0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                    this._onUpdate && (t < 0 && this._startAt && t !== -1e-4 && this._startAt.render(t, !0, i), e || (this._time !== s || n || i) && this._callback("onUpdate")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && t !== -1e-4 && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === l && this._rawPrevTime === g && a !== g && (this._rawPrevTime = 0)))
                }
            }, u._kill = function(t, e, i) {
                if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                e = "string" != typeof e ? e || this._targets || this.target : N.selector(e) || e;
                var n, r, o, a, s, l, c, h, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                if ((_(e) || B(e)) && "number" != typeof e[0])
                    for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (l = !0);
                else {
                    if (this._targets) {
                        for (n = this._targets.length; --n > -1;)
                            if (e === this._targets[n]) {
                                s = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                break
                            }
                    } else {
                        if (e !== this.target) return !1;
                        s = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                    }
                    if (s) {
                        if (c = t || s, h = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill), i && (N.onOverwrite || this.vars.onOverwrite)) {
                            for (o in c) s[o] && (u || (u = []), u.push(o));
                            if ((u || !t) && !nt(this, i, e, u)) return !1
                        }
                        for (o in c)(a = s[o]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, l = !0), a.pg && a.t._kill(c) && (l = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), h && (r[o] = 1);
                        !this._firstPT && this._initted && this._enabled(!1, !1)
                    }
                }
                return l
            }, u.invalidate = function() {
                return this._notifyPluginsOfEnabled && N._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], O.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -g, this.render(Math.min(0, -this._delay))), this
            }, u._enabled = function(t, e) {
                if (p || d.wake(), t && this._gc) {
                    var i, n = this._targets;
                    if (n)
                        for (i = n.length; --i > -1;) this._siblings[i] = it(n[i], this, !0);
                    else this._siblings = it(this.target, this, !0)
                }
                return O.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && N._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
            }, N.to = function(t, e, i) {
                return new N(t, e, i)
            }, N.from = function(t, e, i) {
                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new N(t, e, i)
            }, N.fromTo = function(t, e, i, n) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new N(t, e, n)
            }, N.delayedCall = function(t, e, i, n, r) {
                return new N(e, 0, {
                    delay: t,
                    onComplete: e,
                    onCompleteParams: i,
                    callbackScope: n,
                    onReverseComplete: e,
                    onReverseCompleteParams: i,
                    immediateRender: !1,
                    lazy: !1,
                    useFrames: r,
                    overwrite: 0
                })
            }, N.set = function(t, e) {
                return new N(t, 0, e)
            }, N.getTweensOf = function(t, e) {
                if (null == t) return [];
                t = "string" != typeof t ? t : N.selector(t) || t;
                var i, n, r, o;
                if ((_(t) || B(t)) && "number" != typeof t[0]) {
                    for (i = t.length, n = []; --i > -1;) n = n.concat(N.getTweensOf(t[i], e));
                    for (i = n.length; --i > -1;)
                        for (o = n[i], r = i; --r > -1;) o === n[r] && n.splice(i, 1)
                } else if (t._gsTweenID)
                    for (n = it(t).concat(), i = n.length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                return n || []
            }, N.killTweensOf = N.killDelayedCallsTo = function(t, e, i) {
                "object" == typeof e && (i = e, e = !1);
                for (var n = N.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
            };
            var at = T("plugins.TweenPlugin", function(t, e) {
                this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = at.prototype
            }, !0);
            if (u = at.prototype, at.version = "1.19.0", at.API = 2, u._firstPT = null, u._addTween = W, u.setRatio = G, u._kill = function(t) {
                    var e, i = this._overwriteProps,
                        n = this._firstPT;
                    if (null != t[this._propName]) this._overwriteProps = [];
                    else
                        for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                    for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                    return !1
                }, u._mod = u._roundProps = function(t) {
                    for (var e, i = this._firstPT; i;) e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")], e && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
                }, N._onPluginEvent = function(t, e) {
                    var i, n, r, o, a, s = e._firstPT;
                    if ("_onInitAllProps" === t) {
                        for (; s;) {
                            for (a = s._next, n = r; n && n.pr > s.pr;) n = n._next;
                            (s._prev = n ? n._prev : o) ? s._prev._next = s: r = s, (s._next = n) ? n._prev = s : o = s, s = a
                        }
                        s = e._firstPT = r
                    }
                    for (; s;) s.pg && "function" == typeof s.t[t] && s.t[t]() && (i = !0), s = s._next;
                    return i
                }, at.activate = function(t) {
                    for (var e = t.length; --e > -1;) t[e].API === at.API && (q[(new t[e])._propName] = t[e]);
                    return !0
                }, w.plugin = function(t) {
                    if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                    var e, i = t.propName,
                        n = t.priority || 0,
                        r = t.overwriteProps,
                        o = {
                            init: "_onInitTween",
                            set: "setRatio",
                            kill: "_kill",
                            round: "_mod",
                            mod: "_mod",
                            initAll: "_onInitAllProps"
                        },
                        a = T("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                            at.call(this, i, n), this._overwriteProps = r || []
                        }, t.global === !0),
                        s = a.prototype = new at(i);
                    s.constructor = a, a.API = t.API;
                    for (e in o) "function" == typeof t[e] && (s[o[e]] = t[e]);
                    return a.version = t.version, at.activate([a]), a
                }, c = i._gsQueue) {
                for (h = 0; h < c.length; h++) c[h]();
                for (u in x) x[u].func || i.console.log("GSAP encountered missing dependency: " + u)
            }
            p = !1
        }("undefined" != typeof t && t.exports && "undefined" != typeof i ? i : this || window, "TweenLite")
    }).call(e, function() {
        return this
    }())
}, function(t, e, i) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var n = i(4);
    e.default = function() {
        n.TweenMax.staggerFromTo(".header-animate", .5, {
            opacity: 0,
            y: 100
        }, {
            opacity: 1,
            y: 0,
            delay: .2,
            onComplete: function() {
                this.target.classList.contains("menu-ico") && n.TweenMax.staggerFromTo(".menu-ico__line", .3, {
                    opacity: 0,
                    x: 50
                }, {
                    opacity: 1,
                    x: 0
                }, .1)
            }
        }, .2)
    }
}, function(t, e, i) {
    "use strict";

    function n() {
        a.staggerFromTo(".footer__col", .3, {
            opacity: 0,
            y: 100
        }, {
            opacity: 1,
            y: 0,
            ease: o.Power3.easeOut
        }, .5).from(".footer__line", 3, {
            width: 0,
            ease: o.Power3.easeOut
        }, .1)
    }

    function r() {
        a.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startFooterAnimation = n, e.finishFooterAnimation = r;
    var o = i(4),
        a = new o.TimelineMax
}, function(t, e, i) {
    "use strict";

    function n() {
        a.fromTo(".portfolio-holder .big-title", .5, {
            y: 200,
            opacity: 0
        }, {
            y: 0,
            opacity: 1
        }).staggerFromTo(".portfolio-item", .5, {
            scale: .6,
            opacity: 0
        }, {
            scale: 1,
            opacity: 1
        }, .3).fromTo(".portfolio-holder .more-portfolio", .5, {
            opacity: 0,
            y: 100
        }, {
            opacity: 1,
            y: 0
        })
    }

    function r() {
        a.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startPortfolioAnimation = n, e.finishPortfolioAnimation = r;
    var o = i(4),
        a = new o.TimelineMax
}, function(t, e, i) {
    "use strict";

    function n() {
        a.fromTo(".clients-home .big-title", .5, {
            y: 200,
            opacity: 0
        }, {
            y: 0,
            opacity: 1
        }).fromTo(".clients-home .big-title__subtitle", .5, {
            y: 200,
            opacity: 0
        }, {
            y: 0,
            opacity: 1
        }).staggerFromTo(".clients-home__item", .3, {
            scale: .7,
            opacity: 0,
            y: 50,
            ease: o.Power3.easeOut
        }, {
            scale: 1,
            opacity: 1,
            y: 0,
            ease: o.Power3.easeOut
        }, .1).fromTo(".clients-home .more-clients", .5, {
            opacity: 0,
            y: 100
        }, {
            opacity: 1,
            y: 0
        })
    }

    function r() {
        a.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startClientsAnimation = n, e.finishClientsAnimation = r;
    var o = i(4),
        a = new o.TimelineMax
}, function(t, e, i) {
    "use strict";

    function n() {
        a.fromTo(".team-home .big-title", .5, {
            y: 200,
            opacity: 0
        }, {
            y: 0,
            opacity: 1
        }).fromTo(".team-home .big-title__subtitle", .5, {
            y: 200,
            opacity: 0
        }, {
            y: 0,
            opacity: 1
        }).staggerFromTo(".team-home__image", .3, {
            y: -50,
            x: -50,
            scale: .6,
            opacity: 0,
            ease: o.Power3.easeOut
        }, {
            x: 0,
            y: 0,
            scale: 1,
            opacity: 1,
            ease: o.Power3.easeOut
        }, .2).staggerFromTo(".team-home__description", .3, {
            y: 100,
            x: 20,
            scale: 0,
            opacity: 0,
            ease: o.Power3.easeOut
        }, {
            y: 0,
            x: 0,
            opacity: 1,
            scale: 1,
            ease: o.Power3.easeOut
        }, .1).from(".team-home__line", .5, {
            width: 0
        }).staggerFromTo(".team-counter", .3, {
            x: 150,
            scale: 0,
            ease: o.Power3.easeOut,
            delay: 1,
            opacity: 0
        }, {
            x: 0,
            opacity: 1,
            scale: 1,
            ease: o.Power3.easeOut
        }, .2).fromTo(".all-teams", .5, {
            opacity: 0,
            y: 100
        }, {
            opacity: 1,
            y: 0
        })
    }

    function r() {
        a.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startTeamAnimation = n, e.finishTeamAnimation = r;
    var o = i(4),
        a = new o.TimelineMax
}, function(t, e, i) {
    "use strict";

    function n() {
        a.from(".what-we-do__line", .5, {
            width: 0,
            ease: o.Power3.easeOut
        }, .1).staggerFromTo(".what-we-do__title span", .4, {
            scale: 0,
            opacity: 0,
            y: 100,
            ease: o.Linear.easeOut
        }, {
            scale: 1,
            opacity: 1,
            y: 0,
            ease: o.Linear.easeOut
        }, .2).staggerFromTo(".what-we-do__text span", .2, {
            opacity: 0,
            x: 40,
            ease: o.Linear.easeOut
        }, {
            opacity: 1,
            x: 0,
            ease: o.Linear.easeOut
        }, .1)
    }

    function r() {
        a.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startWhatWeDoAnimation = n, e.finishWhatWeDoAnimation = r;
    var o = i(4),
        a = new o.TimelineMax
}, function(t, e, i) {
    "use strict";

    function n() {
        a.staggerFromTo(".home-services__category", .5, {
            opacity: 0,
            y: 200,
            delay: .1
        }, {
            opacity: 1,
            y: 0,
            delay: .1
        }, .1).staggerFrom(".home-services__line", .2, {
            background: "#000",
            width: 0,
            delay: .1,
            ease: o.Power3.easeOut
        }, .1).staggerFrom(".home-services__item", .3, {
            opacity: 0,
            x: 100,
            ease: o.Power3.easeOut,
            delay: .1
        }, .1)
    }

    function r() {
        a.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startServicesAnimation = n, e.finishServicesAnimation = r;
    var o = i(4),
        a = new o.TimelineMax
}, function(t, e, i) {
    "use strict";

    function n() {
        a.fromTo(".reviews-holder--home .big-title", .5, {
            y: 200,
            opacity: 0
        }, {
            y: 0,
            opacity: 1
        }).fromTo(".reviews-holder--home .big-title__subtitle", .5, {
            y: 200,
            opacity: 0
        }, {
            y: 0,
            opacity: 1
        }).fromTo(".reviews-holder--home .map-holder", .5, {
            opacity: 0,
            y: 100
        }, {
            opacity: 1,
            y: 0
        })
    }

    function r() {
        a.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startReviewsAnimation = n, e.finishReviewsAnimation = r;
    var o = i(4),
        a = new o.TimelineMax
}, function(t, e, i) {
    "use strict";

    function n() {
        a.staggerFromTo(".home-tabs__item", .2, {
            opacity: 0
        }, {
            opacity: 1
        }, .2)
    }

    function r() {
        a.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startHomeTextAnimation = n, e.finishHomeTextAnimation = r;
    var o = i(4),
        a = new o.TimelineMax
}, function(t, e, i) {
    "use strict";

    function n() {
        a.staggerFromTo(".web-holder ul li", .3, {
            scale: .7,
            opacity: 0,
            y: 50,
            ease: o.Power3.easeOut
        }, {
            scale: 1,
            opacity: 1,
            y: 0,
            ease: o.Power3.easeOut
        }, .2)
    }

    function r() {
        a.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startServicesEnAnimation = n, e.finishServicesEnAnimation = r;
    var o = i(4),
        a = new o.TimelineMax
}, function(t, e, i) {
    "use strict";

    function n() {
        a.staggerFromTo(".technologies-list", 1, {
            opacity: 0,
            y: 150,
            ease: o.Power3.easeOut,
            delay: 1
        }, {
            opacity: 1,
            y: 0,
            ease: o.Power3.easeOut
        }, 1)
    }

    function r() {
        a.totalProgress(1).kill()
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.startTechnologiesEnAnimation = n, e.finishTechnologiesEnAnimation = r;
    var o = i(4),
        a = new o.TimelineMax
}, function(t, e, i) {
    (function(t) {
        "use strict";
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var n = i(29);
        t.THREE = n, i(30), i(31);
        var r = null;
        window.requestAnimFrame = function() {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(t) {
                window.setTimeout(t, 1e3 / 60)
            }
        }(), window.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
        var o = function() {
            function e() {
                c = document.createElement("div"), document.getElementById("dots").appendChild(c), h = new n.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2e3), h.position.z = 1e4, u = new n.Scene, u.background = new n.Color(16777215), p = [];
                for (var t = new n.SpriteCanvasMaterial({
                        color: 12303291,
                        program: function(t) {
                            t.beginPath(), t.rect(.5, .5, .5, .5), t.fill()
                        }
                    }), e = 0, r = 0; r < s; r++)
                    for (var o = 0; o < l; o++) f = p[e++] = new n.Sprite(t), f.position.x = r * a - s * a / 2, f.position.z = o * a - l * a / 2, u.add(f);
                d = new n.CanvasRenderer, d.setPixelRatio(window.devicePixelRatio), d.setSize(window.innerWidth, window.innerHeight), c.appendChild(d.domElement), window.addEventListener("resize", i, !1)
            }

            function i() {
                h.aspect = window.innerWidth / window.innerHeight, h.updateProjectionMatrix(), d.setSize(window.innerWidth, window.innerHeight)
            }

            function o() {
                h.position.set(0, 355, 122);
                for (var t = 0, e = 0; e < s; e++)
                    for (var i = 0; i < l; i++) f = p[t++], f.position.y = 50 * Math.sin(.3 * (e + m)) + 50 * Math.sin(.5 * (i + m)), f.scale.x = f.scale.y = 4 * (Math.sin(.3 * (e + m)) + 1) + 3 * (Math.sin(.5 * (i + m)) + 1);
                d.render(u, h), m += .05
            }
            var a = 100,
                s = 30,
                l = 30,
                c = null,
                h = null,
                u = null,
                d = null,
                p = 0,
                f = 0,
                m = 0;
            e(), o(), t.animateDots = function() {
                r = requestAnimationFrame(t.animateDots), o()
            }, t.animateDotsStop = function() {
                cancelAnimationFrame(r)
            }
        };
        e.default = {
            prepare: o
        }
    }).call(e, function() {
        return this
    }())
}, function(t, e, i) {
    ! function(t, i) {
        i(e)
    }(this, function(t) {
        function e() {}

        function i(t, e) {
            this.x = t || 0, this.y = e || 0
        }

        function n(t, e, r, o, a, s, l, c, h, u) {
            Object.defineProperty(this, "id", {
                value: _r++
            }), this.uuid = yr.generateUUID(), this.name = "", this.image = void 0 !== t ? t : n.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : n.DEFAULT_MAPPING, this.wrapS = void 0 !== r ? r : 1001, this.wrapT = void 0 !== o ? o : 1001, this.magFilter = void 0 !== a ? a : 1006, this.minFilter = void 0 !== s ? s : 1008, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== l ? l : 1023, this.type = void 0 !== c ? c : 1009, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== u ? u : 3e3, this.version = 0, this.onUpdate = null
        }

        function r(t, e, i, n) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
        }

        function o(t, e, i) {
            this.uuid = yr.generateUUID(), this.width = t, this.height = e, this.scissor = new r(0, 0, t, e), this.scissorTest = !1, this.viewport = new r(0, 0, t, e), i = i || {}, void 0 === i.minFilter && (i.minFilter = 1006), this.texture = new n(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
        }

        function a(t, e, i) {
            o.call(this, t, e, i), this.activeMipMapLevel = this.activeCubeFace = 0
        }

        function s(t, e, i, n) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
        }

        function l(t, e, i) {
            this.x = t || 0, this.y = e || 0, this.z = i || 0
        }

        function c() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }

        function h(t, e, i, r, o, a, s, l, c, h, u, d) {
            n.call(this, null, a, s, l, c, h, r, o, u, d), this.image = {
                data: t,
                width: e,
                height: i
            }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== h ? h : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1
        }

        function u(t, e, i, r, o, a, s, l, c, h) {
            t = void 0 !== t ? t : [], n.call(this, t, void 0 !== e ? e : 301, i, r, o, a, s, l, c, h), this.flipY = !1
        }

        function d(t, e, i) {
            var n = t[0];
            if (0 >= n || 0 < n) return t;
            var r = e * i,
                o = wr[r];
            if (void 0 === o && (o = new Float32Array(r), wr[r] = o), 0 !== e)
                for (n.toArray(o, 0), n = 1, r = 0; n !== e; ++n) r += i, t[n].toArray(o, r);
            return o
        }

        function p(t, e) {
            var i = Tr[e];
            void 0 === i && (i = new Int32Array(e), Tr[e] = i);
            for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
            return i
        }

        function f(t, e) {
            t.uniform1f(this.addr, e)
        }

        function m(t, e) {
            t.uniform1i(this.addr, e)
        }

        function g(t, e) {
            void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
        }

        function v(t, e) {
            void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
        }

        function y(t, e) {
            void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
        }

        function _(t, e) {
            t.uniformMatrix2fv(this.addr, !1, e.elements || e)
        }

        function x(t, e) {
            void 0 === e.elements ? t.uniformMatrix3fv(this.addr, !1, e) : (Mr.set(e.elements), t.uniformMatrix3fv(this.addr, !1, Mr))
        }

        function b(t, e) {
            void 0 === e.elements ? t.uniformMatrix4fv(this.addr, !1, e) : (Sr.set(e.elements), t.uniformMatrix4fv(this.addr, !1, Sr))
        }

        function w(t, e, i) {
            var n = i.allocTextureUnit();
            t.uniform1i(this.addr, n), i.setTexture2D(e || xr, n)
        }

        function T(t, e, i) {
            var n = i.allocTextureUnit();
            t.uniform1i(this.addr, n), i.setTextureCube(e || br, n)
        }

        function S(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function M(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function E(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function A(t) {
            switch (t) {
                case 5126:
                    return f;
                case 35664:
                    return g;
                case 35665:
                    return v;
                case 35666:
                    return y;
                case 35674:
                    return _;
                case 35675:
                    return x;
                case 35676:
                    return b;
                case 35678:
                    return w;
                case 35680:
                    return T;
                case 5124:
                case 35670:
                    return m;
                case 35667:
                case 35671:
                    return S;
                case 35668:
                case 35672:
                    return M;
                case 35669:
                case 35673:
                    return E
            }
        }

        function C(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function P(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function R(t, e) {
            t.uniform2fv(this.addr, d(e, this.size, 2))
        }

        function L(t, e) {
            t.uniform3fv(this.addr, d(e, this.size, 3))
        }

        function k(t, e) {
            t.uniform4fv(this.addr, d(e, this.size, 4))
        }

        function O(t, e) {
            t.uniformMatrix2fv(this.addr, !1, d(e, this.size, 4))
        }

        function D(t, e) {
            t.uniformMatrix3fv(this.addr, !1, d(e, this.size, 9))
        }

        function I(t, e) {
            t.uniformMatrix4fv(this.addr, !1, d(e, this.size, 16))
        }

        function N(t, e, i) {
            var n = e.length,
                r = p(i, n);
            for (t.uniform1iv(this.addr, r), t = 0; t !== n; ++t) i.setTexture2D(e[t] || xr, r[t]);
        }

        function B(t, e, i) {
            var n = e.length,
                r = p(i, n);
            for (t.uniform1iv(this.addr, r), t = 0; t !== n; ++t) i.setTextureCube(e[t] || br, r[t])
        }

        function U(t) {
            switch (t) {
                case 5126:
                    return C;
                case 35664:
                    return R;
                case 35665:
                    return L;
                case 35666:
                    return k;
                case 35674:
                    return O;
                case 35675:
                    return D;
                case 35676:
                    return I;
                case 35678:
                    return N;
                case 35680:
                    return B;
                case 5124:
                case 35670:
                    return P;
                case 35667:
                case 35671:
                    return S;
                case 35668:
                case 35672:
                    return M;
                case 35669:
                case 35673:
                    return E
            }
        }

        function F(t, e, i) {
            this.id = t, this.addr = i, this.setValue = A(e.type)
        }

        function z(t, e, i) {
            this.id = t, this.addr = i, this.size = e.size, this.setValue = U(e.type)
        }

        function H(t) {
            this.id = t, this.seq = [], this.map = {}
        }

        function j(t, e, i) {
            this.seq = [], this.map = {}, this.renderer = i, i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
            for (var n = 0; n < i; ++n) {
                var r = t.getActiveUniform(e, n),
                    o = t.getUniformLocation(e, r.name),
                    a = this,
                    s = r.name,
                    l = s.length;
                for (Er.lastIndex = 0;;) {
                    var c = Er.exec(s),
                        h = Er.lastIndex,
                        u = c[1],
                        d = c[3];
                    if ("]" === c[2] && (u |= 0), void 0 === d || "[" === d && h + 2 === l) {
                        s = a, r = void 0 === d ? new F(u, r, o) : new z(u, r, o), s.seq.push(r), s.map[r.id] = r;
                        break
                    }
                    d = a.map[u], void 0 === d && (d = new H(u), u = a, a = d, u.seq.push(a), u.map[a.id] = a), a = d
                }
            }
        }

        function G(t, e, i) {
            return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
        }

        function V(t, e) {
            this.min = void 0 !== t ? t : new i(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new i(-(1 / 0), -(1 / 0))
        }

        function W(t, e) {
            var n, r, o, a, s, c, h, u, d, p, f, m, g, v, y, _, x = t.context,
                b = t.state;
            this.render = function(w, T, S) {
                if (0 !== e.length) {
                    w = new l;
                    var M = S.w / S.z,
                        E = .5 * S.z,
                        A = .5 * S.w,
                        C = 16 / S.w,
                        P = new i(C * M, C),
                        R = new l(1, 1, 0),
                        L = new i(1, 1),
                        k = new V;
                    if (k.min.set(S.x, S.y), k.max.set(S.x + (S.z - 16), S.y + (S.w - 16)), void 0 === v) {
                        var C = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                            O = new Uint16Array([0, 1, 2, 0, 2, 3]);
                        f = x.createBuffer(), m = x.createBuffer(), x.bindBuffer(x.ARRAY_BUFFER, f), x.bufferData(x.ARRAY_BUFFER, C, x.STATIC_DRAW), x.bindBuffer(x.ELEMENT_ARRAY_BUFFER, m), x.bufferData(x.ELEMENT_ARRAY_BUFFER, O, x.STATIC_DRAW), y = x.createTexture(), _ = x.createTexture(), b.bindTexture(x.TEXTURE_2D, y), x.texImage2D(x.TEXTURE_2D, 0, x.RGB, 16, 16, 0, x.RGB, x.UNSIGNED_BYTE, null), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, x.NEAREST), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.NEAREST), b.bindTexture(x.TEXTURE_2D, _), x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, 16, 16, 0, x.RGBA, x.UNSIGNED_BYTE, null), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, x.NEAREST), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.NEAREST);
                        var C = g = {
                                vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                                fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                            },
                            O = x.createProgram(),
                            D = x.createShader(x.FRAGMENT_SHADER),
                            I = x.createShader(x.VERTEX_SHADER),
                            N = "precision " + t.getPrecision() + " float;\n";
                        x.shaderSource(D, N + C.fragmentShader), x.shaderSource(I, N + C.vertexShader), x.compileShader(D), x.compileShader(I), x.attachShader(O, D), x.attachShader(O, I), x.linkProgram(O), v = O, d = x.getAttribLocation(v, "position"), p = x.getAttribLocation(v, "uv"), n = x.getUniformLocation(v, "renderType"), r = x.getUniformLocation(v, "map"), o = x.getUniformLocation(v, "occlusionMap"), a = x.getUniformLocation(v, "opacity"), s = x.getUniformLocation(v, "color"), c = x.getUniformLocation(v, "scale"), h = x.getUniformLocation(v, "rotation"), u = x.getUniformLocation(v, "screenPosition")
                    }
                    for (x.useProgram(v), b.initAttributes(), b.enableAttribute(d), b.enableAttribute(p), b.disableUnusedAttributes(), x.uniform1i(o, 0), x.uniform1i(r, 1), x.bindBuffer(x.ARRAY_BUFFER, f), x.vertexAttribPointer(d, 2, x.FLOAT, !1, 16, 0), x.vertexAttribPointer(p, 2, x.FLOAT, !1, 16, 8), x.bindBuffer(x.ELEMENT_ARRAY_BUFFER, m), b.disable(x.CULL_FACE), b.buffers.depth.setMask(!1), O = 0, D = e.length; O < D; O++)
                        if (C = 16 / S.w, P.set(C * M, C), I = e[O], w.set(I.matrixWorld.elements[12], I.matrixWorld.elements[13], I.matrixWorld.elements[14]), w.applyMatrix4(T.matrixWorldInverse), w.applyMatrix4(T.projectionMatrix), R.copy(w), L.x = S.x + R.x * E + E - 8, L.y = S.y + R.y * A + A - 8, !0 === k.containsPoint(L)) {
                            b.activeTexture(x.TEXTURE0), b.bindTexture(x.TEXTURE_2D, null), b.activeTexture(x.TEXTURE1), b.bindTexture(x.TEXTURE_2D, y), x.copyTexImage2D(x.TEXTURE_2D, 0, x.RGB, L.x, L.y, 16, 16, 0), x.uniform1i(n, 0), x.uniform2f(c, P.x, P.y), x.uniform3f(u, R.x, R.y, R.z), b.disable(x.BLEND), b.enable(x.DEPTH_TEST), x.drawElements(x.TRIANGLES, 6, x.UNSIGNED_SHORT, 0), b.activeTexture(x.TEXTURE0), b.bindTexture(x.TEXTURE_2D, _), x.copyTexImage2D(x.TEXTURE_2D, 0, x.RGBA, L.x, L.y, 16, 16, 0), x.uniform1i(n, 1), b.disable(x.DEPTH_TEST), b.activeTexture(x.TEXTURE1), b.bindTexture(x.TEXTURE_2D, y), x.drawElements(x.TRIANGLES, 6, x.UNSIGNED_SHORT, 0), I.positionScreen.copy(R), I.customUpdateCallback ? I.customUpdateCallback(I) : I.updateLensFlares(), x.uniform1i(n, 2), b.enable(x.BLEND);
                            for (var N = 0, B = I.lensFlares.length; N < B; N++) {
                                var U = I.lensFlares[N];
                                .001 < U.opacity && .001 < U.scale && (R.x = U.x, R.y = U.y, R.z = U.z, C = U.size * U.scale / S.w, P.x = C * M, P.y = C, x.uniform3f(u, R.x, R.y, R.z), x.uniform2f(c, P.x, P.y), x.uniform1f(h, U.rotation), x.uniform1f(a, U.opacity), x.uniform3f(s, U.color.r, U.color.g, U.color.b), b.setBlending(U.blending, U.blendEquation, U.blendSrc, U.blendDst), t.setTexture2D(U.texture, 1), x.drawElements(x.TRIANGLES, 6, x.UNSIGNED_SHORT, 0))
                            }
                        }
                    b.enable(x.CULL_FACE), b.enable(x.DEPTH_TEST), b.buffers.depth.setMask(!0), t.resetGLState()
                }
            }
        }

        function X(t, e) {
            function i(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
            }
            var r, o, a, c, h, u, d, p, f, m, g, v, y, _, x, b, w, T, S, M, E, A = t.context,
                C = t.state,
                P = new l,
                R = new s,
                L = new l;
            this.render = function(s, l) {
                if (0 !== e.length) {
                    if (void 0 === M) {
                        var k = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                            O = new Uint16Array([0, 1, 2, 0, 2, 3]);
                        T = A.createBuffer(), S = A.createBuffer(), A.bindBuffer(A.ARRAY_BUFFER, T), A.bufferData(A.ARRAY_BUFFER, k, A.STATIC_DRAW), A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, S), A.bufferData(A.ELEMENT_ARRAY_BUFFER, O, A.STATIC_DRAW);
                        var k = A.createProgram(),
                            O = A.createShader(A.VERTEX_SHADER),
                            D = A.createShader(A.FRAGMENT_SHADER);
                        A.shaderSource(O, ["precision " + t.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), A.shaderSource(D, ["precision " + t.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), A.compileShader(O), A.compileShader(D), A.attachShader(k, O), A.attachShader(k, D), A.linkProgram(k), M = k, b = A.getAttribLocation(M, "position"), w = A.getAttribLocation(M, "uv"), r = A.getUniformLocation(M, "uvOffset"), o = A.getUniformLocation(M, "uvScale"), a = A.getUniformLocation(M, "rotation"), c = A.getUniformLocation(M, "scale"), h = A.getUniformLocation(M, "color"), u = A.getUniformLocation(M, "map"), d = A.getUniformLocation(M, "opacity"), p = A.getUniformLocation(M, "modelViewMatrix"), f = A.getUniformLocation(M, "projectionMatrix"), m = A.getUniformLocation(M, "fogType"), g = A.getUniformLocation(M, "fogDensity"), v = A.getUniformLocation(M, "fogNear"), y = A.getUniformLocation(M, "fogFar"), _ = A.getUniformLocation(M, "fogColor"), x = A.getUniformLocation(M, "alphaTest"), k = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), k.width = 8, k.height = 8, O = k.getContext("2d"), O.fillStyle = "white", O.fillRect(0, 0, 8, 8), E = new n(k), E.needsUpdate = !0
                    }
                    A.useProgram(M), C.initAttributes(), C.enableAttribute(b), C.enableAttribute(w), C.disableUnusedAttributes(), C.disable(A.CULL_FACE), C.enable(A.BLEND), A.bindBuffer(A.ARRAY_BUFFER, T), A.vertexAttribPointer(b, 2, A.FLOAT, !1, 16, 0), A.vertexAttribPointer(w, 2, A.FLOAT, !1, 16, 8), A.bindBuffer(A.ELEMENT_ARRAY_BUFFER, S), A.uniformMatrix4fv(f, !1, l.projectionMatrix.elements), C.activeTexture(A.TEXTURE0), A.uniform1i(u, 0), O = k = 0, (D = s.fog) ? (A.uniform3f(_, D.color.r, D.color.g, D.color.b), D.isFog ? (A.uniform1f(v, D.near), A.uniform1f(y, D.far), A.uniform1i(m, 1), O = k = 1) : D.isFogExp2 && (A.uniform1f(g, D.density), A.uniform1i(m, 2), O = k = 2)) : (A.uniform1i(m, 0), O = k = 0);
                    for (var D = 0, I = e.length; D < I; D++) {
                        var N = e[D];
                        N.modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, N.matrixWorld), N.z = -N.modelViewMatrix.elements[14]
                    }
                    e.sort(i);
                    for (var B = [], D = 0, I = e.length; D < I; D++) {
                        var N = e[D],
                            U = N.material;
                        !1 !== U.visible && (A.uniform1f(x, U.alphaTest), A.uniformMatrix4fv(p, !1, N.modelViewMatrix.elements), N.matrixWorld.decompose(P, R, L), B[0] = L.x, B[1] = L.y, N = 0, s.fog && U.fog && (N = O), k !== N && (A.uniform1i(m, N), k = N), null !== U.map ? (A.uniform2f(r, U.map.offset.x, U.map.offset.y), A.uniform2f(o, U.map.repeat.x, U.map.repeat.y)) : (A.uniform2f(r, 0, 0), A.uniform2f(o, 1, 1)), A.uniform1f(d, U.opacity), A.uniform3f(h, U.color.r, U.color.g, U.color.b), A.uniform1f(a, U.rotation), A.uniform2fv(c, B), C.setBlending(U.blending, U.blendEquation, U.blendSrc, U.blendDst), C.buffers.depth.setTest(U.depthTest), C.buffers.depth.setMask(U.depthWrite), U.map ? t.setTexture2D(U.map, 0) : t.setTexture2D(E, 0), A.drawElements(A.TRIANGLES, 6, A.UNSIGNED_SHORT, 0))
                    }
                    C.enable(A.CULL_FACE), t.resetGLState()
                }
            }
        }

        function q() {
            Object.defineProperty(this, "id", {
                value: kr++
            }), this.uuid = yr.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.shading = 2, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.needsUpdate = this.visible = !0
        }

        function $(t) {
            q.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
        }

        function Y(t) {
            q.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(t)
        }

        function Z(t, e) {
            this.min = void 0 !== t ? t : new l(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new l(-(1 / 0), -(1 / 0), -(1 / 0))
        }

        function Q(t, e) {
            this.center = void 0 !== t ? t : new l, this.radius = void 0 !== e ? e : 0
        }

        function J() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }

        function K(t, e) {
            this.normal = void 0 !== t ? t : new l(1, 0, 0), this.constant = void 0 !== e ? e : 0
        }

        function tt(t, e, i, n, r, o) {
            this.planes = [void 0 !== t ? t : new K, void 0 !== e ? e : new K, void 0 !== i ? i : new K, void 0 !== n ? n : new K, void 0 !== r ? r : new K, void 0 !== o ? o : new K]
        }

        function et(t, e, n, a) {
            function s(e, i, n, r) {
                var o, a = e.geometry;
                o = x;
                var s = e.customDepthMaterial;
                return n && (o = b, s = e.customDistanceMaterial), s ? o = s : (s = !1, i.morphTargets && (a && a.isBufferGeometry ? s = a.morphAttributes && a.morphAttributes.position && 0 < a.morphAttributes.position.length : a && a.isGeometry && (s = a.morphTargets && 0 < a.morphTargets.length)), e.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e), e = e.isSkinnedMesh && i.skinning, a = 0, s && (a |= 1), e && (a |= 2), o = o[a]), t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (a = o.uuid, s = i.uuid, e = w[a], void 0 === e && (e = {}, w[a] = e), a = e[s], void 0 === a && (a = o.clone(), e[s] = a), o = a), o.visible = i.visible, o.wireframe = i.wireframe, s = i.side, L.renderSingleSided && 2 == s && (s = 0), L.renderReverseSided && (0 === s ? s = 1 : 1 === s && (s = 0)), o.side = s, o.clipShadows = i.clipShadows, o.clippingPlanes = i.clippingPlanes, o.wireframeLinewidth = i.wireframeLinewidth, o.linewidth = i.linewidth, n && void 0 !== o.uniforms.lightPos && o.uniforms.lightPos.value.copy(r), o
            }

            function h(e, i, r, o) {
                if (!1 !== e.visible) {
                    if (e.layers.test(i.layers) && (e.isMesh || e.isLine || e.isPoints) && e.castShadow && (!e.frustumCulled || p.intersectsObject(e))) {
                        e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld);
                        var a = n.update(e),
                            l = e.material;
                        if (Array.isArray(l))
                            for (var c = a.groups, u = 0, d = c.length; u < d; u++) {
                                var f = c[u],
                                    m = l[f.materialIndex];
                                m && m.visible && (m = s(e, m, o, _), t.renderBufferDirect(r, null, a, m, e, f))
                            } else l.visible && (m = s(e, l, o, _), t.renderBufferDirect(r, null, a, m, e, null))
                    }
                    for (e = e.children, a = 0, l = e.length; a < l; a++) h(e[a], i, r, o)
                }
            }
            var u = t.context,
                d = t.state,
                p = new tt,
                f = new c,
                m = e.shadows,
                g = new i,
                v = new i(a.maxTextureSize, a.maxTextureSize),
                y = new l,
                _ = new l,
                x = Array(4),
                b = Array(4),
                w = {},
                T = [new l(1, 0, 0), new l(-1, 0, 0), new l(0, 0, 1), new l(0, 0, -1), new l(0, 1, 0), new l(0, -1, 0)],
                S = [new l(0, 1, 0), new l(0, 1, 0), new l(0, 1, 0), new l(0, 1, 0), new l(0, 0, 1), new l(0, 0, -1)],
                M = [new r, new r, new r, new r, new r, new r];
            e = new Y, e.depthPacking = 3201, e.clipping = !0, a = Lr.distanceRGBA;
            for (var E = Pr.clone(a.uniforms), A = 0; 4 !== A; ++A) {
                var C = 0 !== (1 & A),
                    P = 0 !== (2 & A),
                    R = e.clone();
                R.morphTargets = C, R.skinning = P, x[A] = R, C = new $({
                    defines: {
                        USE_SHADOWMAP: ""
                    },
                    uniforms: E,
                    vertexShader: a.vertexShader,
                    fragmentShader: a.fragmentShader,
                    morphTargets: C,
                    skinning: P,
                    clipping: !0
                }), b[A] = C
            }
            var L = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.renderSingleSided = this.renderReverseSided = !0, this.render = function(e, i) {
                if (!1 !== L.enabled && (!1 !== L.autoUpdate || !1 !== L.needsUpdate) && 0 !== m.length) {
                    d.disable(u.BLEND), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                    for (var n, r, a = 0, s = m.length; a < s; a++) {
                        var l = m[a],
                            c = l.shadow;
                        if (void 0 === c) console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                        else {
                            var x = c.camera,
                                b = c.matrix;
                            if (_.setFromMatrixPosition(l.matrixWorld), x.position.copy(_), g.copy(c.mapSize), g.min(v), l && l.isPointLight) {
                                n = 6, r = !0;
                                var w = g.x,
                                    E = g.y;
                                M[0].set(2 * w, E, w, E), M[1].set(0, E, w, E), M[2].set(3 * w, E, w, E), M[3].set(w, E, w, E), M[4].set(3 * w, 0, w, E), M[5].set(w, 0, w, E), g.x *= 4, g.y *= 2, b.makeTranslation(-_.x, -_.y, -_.z)
                            } else n = 1, r = !1, y.setFromMatrixPosition(l.target.matrixWorld), x.lookAt(y), x.updateMatrixWorld(), x.matrixWorldInverse.getInverse(x.matrixWorld), b.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), b.multiply(x.projectionMatrix), b.multiply(x.matrixWorldInverse);
                            for (null === c.map && (c.map = new o(g.x, g.y, {
                                    minFilter: 1003,
                                    magFilter: 1003,
                                    format: 1023
                                }), c.map.texture.name = l.name + ".shadowMap", x.updateProjectionMatrix()), c.isSpotLightShadow && c.update(l), t.setRenderTarget(c.map), t.clear(), l = 0; l < n; l++) r && (y.copy(x.position), y.add(T[l]), x.up.copy(S[l]), x.lookAt(y), x.updateMatrixWorld(), x.matrixWorldInverse.getInverse(x.matrixWorld), d.viewport(M[l])), f.multiplyMatrices(x.projectionMatrix, x.matrixWorldInverse), p.setFromMatrix(f), h(e, i, x, r)
                        }
                    }
                    n = t.getClearColor(), r = t.getClearAlpha(), t.setClearColor(n, r), L.needsUpdate = !1
                }
            }
        }

        function it(t, e) {
            this.origin = void 0 !== t ? t : new l, this.direction = void 0 !== e ? e : new l
        }

        function nt(t, e, i, n) {
            this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || nt.DefaultOrder
        }

        function rt() {
            this.mask = 1
        }

        function ot() {
            Object.defineProperty(this, "id", {
                value: Or++
            }), this.uuid = yr.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ot.DefaultUp.clone();
            var t = new l,
                e = new nt,
                i = new s,
                n = new l(1, 1, 1);
            e.onChange(function() {
                i.setFromEuler(e, !1)
            }), i.onChange(function() {
                e.setFromQuaternion(i, void 0, !1)
            }), Object.defineProperties(this, {
                position: {
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    enumerable: !0,
                    value: i
                },
                scale: {
                    enumerable: !0,
                    value: n
                },
                modelViewMatrix: {
                    value: new c
                },
                normalMatrix: {
                    value: new J
                }
            }), this.matrix = new c, this.matrixWorld = new c, this.matrixAutoUpdate = ot.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new rt, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}, this.onBeforeRender = function() {}, this.onAfterRender = function() {}
        }

        function at(t, e) {
            this.start = void 0 !== t ? t : new l, this.end = void 0 !== e ? e : new l
        }

        function st(t, e, i) {
            this.a = void 0 !== t ? t : new l, this.b = void 0 !== e ? e : new l, this.c = void 0 !== i ? i : new l
        }

        function lt(t, e, i, n, r, o) {
            this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new l, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new G, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
        }

        function ct(t) {
            q.call(this), this.type = "MeshBasicMaterial", this.color = new G(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function ht(t, e, i) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.uuid = yr.generateUUID(), this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.onUploadCallback = function() {}, this.version = 0
        }

        function ut(t, e) {
            ht.call(this, new Int8Array(t), e)
        }

        function dt(t, e) {
            ht.call(this, new Uint8Array(t), e)
        }

        function pt(t, e) {
            ht.call(this, new Uint8ClampedArray(t), e)
        }

        function ft(t, e) {
            ht.call(this, new Int16Array(t), e)
        }

        function mt(t, e) {
            ht.call(this, new Uint16Array(t), e)
        }

        function gt(t, e) {
            ht.call(this, new Int32Array(t), e)
        }

        function vt(t, e) {
            ht.call(this, new Uint32Array(t), e)
        }

        function yt(t, e) {
            ht.call(this, new Float32Array(t), e)
        }

        function _t(t, e) {
            ht.call(this, new Float64Array(t), e)
        }

        function xt() {
            this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
        }

        function bt(t) {
            if (0 === t.length) return -(1 / 0);
            for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
            return e
        }

        function wt() {
            Object.defineProperty(this, "id", {
                value: Dr++
            }), this.uuid = yr.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
        }

        function Tt() {
            Object.defineProperty(this, "id", {
                value: Dr++
            }), this.uuid = yr.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }
        }

        function St(t, e) {
            ot.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Tt, this.material = void 0 !== e ? e : new ct({
                color: 16777215 * Math.random()
            }), this.drawMode = 0, this.updateMorphTargets()
        }

        function Mt(t, e, i, n, r, o) {
            wt.call(this), this.type = "BoxGeometry", this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: n,
                heightSegments: r,
                depthSegments: o
            }, this.fromBufferGeometry(new Et(t, e, i, n, r, o)), this.mergeVertices()
        }

        function Et(t, e, i, n, r, o) {
            function a(t, e, i, n, r, o, a, m, g, v, y) {
                var _ = o / g,
                    x = a / v,
                    b = o / 2,
                    w = a / 2,
                    T = m / 2;
                a = g + 1;
                var S, M, E = v + 1,
                    A = o = 0,
                    C = new l;
                for (M = 0; M < E; M++) {
                    var P = M * x - w;
                    for (S = 0; S < a; S++) C[t] = (S * _ - b) * n, C[e] = P * r, C[i] = T, h.push(C.x, C.y, C.z), C[t] = 0, C[e] = 0, C[i] = 0 < m ? 1 : -1, u.push(C.x, C.y, C.z), d.push(S / g), d.push(1 - M / v), o += 1
                }
                for (M = 0; M < v; M++)
                    for (S = 0; S < g; S++) t = p + S + a * (M + 1), e = p + (S + 1) + a * (M + 1), i = p + (S + 1) + a * M, c.push(p + S + a * M, t, i), c.push(t, e, i), A += 6;
                s.addGroup(f, A, y), f += A, p += o
            }
            Tt.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                width: t,
                height: e,
                depth: i,
                widthSegments: n,
                heightSegments: r,
                depthSegments: o
            };
            var s = this;
            n = Math.floor(n) || 1, r = Math.floor(r) || 1, o = Math.floor(o) || 1;
            var c = [],
                h = [],
                u = [],
                d = [],
                p = 0,
                f = 0;
            a("z", "y", "x", -1, -1, i, e, t, o, r, 0), a("z", "y", "x", 1, -1, i, e, -t, o, r, 1), a("x", "z", "y", 1, 1, t, i, e, n, o, 2), a("x", "z", "y", 1, -1, t, i, -e, n, o, 3), a("x", "y", "z", 1, -1, t, e, i, n, r, 4), a("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(c), this.addAttribute("position", new yt(h, 3)), this.addAttribute("normal", new yt(u, 3)), this.addAttribute("uv", new yt(d, 2))
        }

        function At(t, e, i, n) {
            wt.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            }, this.fromBufferGeometry(new Ct(t, e, i, n)), this.mergeVertices()
        }

        function Ct(t, e, i, n) {
            Tt.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: i,
                heightSegments: n
            };
            var r = t / 2,
                o = e / 2;
            i = Math.floor(i) || 1, n = Math.floor(n) || 1;
            var a = i + 1,
                s = n + 1,
                l = t / i,
                c = e / n,
                h = [],
                u = [],
                d = [],
                p = [];
            for (t = 0; t < s; t++) {
                var f = t * c - o;
                for (e = 0; e < a; e++) u.push(e * l - r, -f, 0), d.push(0, 0, 1), p.push(e / i), p.push(1 - t / n)
            }
            for (t = 0; t < n; t++)
                for (e = 0; e < i; e++) r = e + a * (t + 1), o = e + 1 + a * (t + 1), s = e + 1 + a * t, h.push(e + a * t, r, s), h.push(r, o, s);
            this.setIndex(h), this.addAttribute("position", new yt(u, 3)), this.addAttribute("normal", new yt(d, 3)), this.addAttribute("uv", new yt(p, 2))
        }

        function Pt() {
            ot.call(this), this.type = "Camera", this.matrixWorldInverse = new c, this.projectionMatrix = new c
        }

        function Rt(t, e, i, n) {
            Pt.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }

        function Lt(t, e, i, n, r, o) {
            Pt.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = i, this.bottom = n, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
        }

        function kt(t) {
            var e = {};
            return {
                get: function(t) {
                    return t.isInterleavedBufferAttribute && (t = t.data), e[t.uuid]
                },
                remove: function(i) {
                    var n = e[i.uuid];
                    n && (t.deleteBuffer(n.buffer), delete e[i.uuid])
                },
                update: function(i, n) {
                    i.isInterleavedBufferAttribute && (i = i.data);
                    var r = e[i.uuid];
                    if (void 0 === r) {
                        var r = i.uuid,
                            o = i,
                            a = o.array,
                            s = o.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW,
                            l = t.createBuffer();
                        t.bindBuffer(n, l), t.bufferData(n, a, s), o.onUploadCallback(), s = t.FLOAT, a instanceof Float32Array ? s = t.FLOAT : a instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : a instanceof Uint16Array ? s = t.UNSIGNED_SHORT : a instanceof Int16Array ? s = t.SHORT : a instanceof Uint32Array ? s = t.UNSIGNED_INT : a instanceof Int32Array ? s = t.INT : a instanceof Int8Array ? s = t.BYTE : a instanceof Uint8Array && (s = t.UNSIGNED_BYTE), e[r] = {
                            buffer: l,
                            type: s,
                            bytesPerElement: a.BYTES_PER_ELEMENT,
                            version: o.version
                        }
                    } else r.version < i.version && (o = i, a = o.array, l = o.updateRange, t.bindBuffer(n, r.buffer), !1 === o.dynamic ? t.bufferData(n, a, t.STATIC_DRAW) : -1 === l.count ? t.bufferSubData(n, 0, a) : 0 === l.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, l.offset * a.BYTES_PER_ELEMENT, a.subarray(l.offset, l.offset + l.count)), l.count = 0), r.version = i.version)
                }
            }
        }

        function Ot(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
        }

        function Dt(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
        }

        function It() {
            var t = [],
                e = -1,
                i = [],
                n = -1;
            return {
                opaque: t,
                transparent: i,
                init: function() {
                    n = e = -1
                },
                push: function(r, o, a, s, l) {
                    var c, h;
                    a.transparent ? (c = i, h = ++n) : (c = t, h = ++e), (h = c[h]) ? (h.id = r.id, h.object = r, h.geometry = o, h.material = a, h.program = a.program, h.renderOrder = r.renderOrder, h.z = s, h.group = l) : (h = {
                        id: r.id,
                        object: r,
                        geometry: o,
                        material: a,
                        program: a.program,
                        renderOrder: r.renderOrder,
                        z: s,
                        group: l
                    }, c.push(h))
                },
                finish: function() {
                    t.length = e + 1, i.length = n + 1
                },
                sort: function() {
                    t.sort(Ot), i.sort(Dt)
                }
            }
        }

        function Nt() {
            var t = {};
            return {
                get: function(e, i) {
                    var n = e.id + "," + i.id,
                        r = t[n];
                    return void 0 === r && (r = new It, t[n] = r), r
                },
                dispose: function() {
                    t = {}
                }
            }
        }

        function Bt(t, e, i) {
            var n, r, o;
            this.setMode = function(t) {
                n = t
            }, this.setIndex = function(i) {
                i.array instanceof Uint32Array && e.get("OES_element_index_uint") ? (r = t.UNSIGNED_INT, o = 4) : i.array instanceof Uint16Array ? (r = t.UNSIGNED_SHORT, o = 2) : (r = t.UNSIGNED_BYTE, o = 1)
            }, this.render = function(e, a) {
                t.drawElements(n, a, r, e * o), i.calls++, i.vertices += a, n === t.TRIANGLES && (i.faces += a / 3)
            }, this.renderInstances = function(a, s, l) {
                var c = e.get("ANGLE_instanced_arrays");
                null === c ? console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (c.drawElementsInstancedANGLE(n, l, r, s * o, a.maxInstancedCount), i.calls++, i.vertices += l * a.maxInstancedCount, n === t.TRIANGLES && (i.faces += a.maxInstancedCount * l / 3))
            }
        }

        function Ut(t, e, i) {
            var n;
            this.setMode = function(t) {
                n = t
            }, this.render = function(e, r) {
                t.drawArrays(n, e, r), i.calls++, i.vertices += r, n === t.TRIANGLES && (i.faces += r / 3)
            }, this.renderInstances = function(r, o, a) {
                var s = e.get("ANGLE_instanced_arrays");
                if (null === s) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    var l = r.attributes.position;
                    l.isInterleavedBufferAttribute ? (a = l.data.count, s.drawArraysInstancedANGLE(n, 0, a, r.maxInstancedCount)) : s.drawArraysInstancedANGLE(n, o, a, r.maxInstancedCount), i.calls++, i.vertices += a * r.maxInstancedCount, n === t.TRIANGLES && (i.faces += r.maxInstancedCount * a / 3)
                }
            }
        }

        function Ft(t, e, i) {
            function n(t) {
                t = t.target;
                var a = r[t.id];
                null !== a.index && e.remove(a.index);
                for (var s in a.attributes) e.remove(a.attributes[s]);
                t.removeEventListener("dispose", n), delete r[t.id], (s = o[t.id]) && (e.remove(s), delete o[t.id]), (s = o[a.id]) && (e.remove(s), delete o[a.id]), i.geometries--
            }
            var r = {},
                o = {};
            return {
                get: function(t, e) {
                    var o = r[e.id];
                    return o ? o : (e.addEventListener("dispose", n), e.isBufferGeometry ? o = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Tt).setFromObject(t)), o = e._bufferGeometry), r[e.id] = o, i.geometries++, o)
                },
                update: function(i) {
                    var n = i.index,
                        r = i.attributes;
                    null !== n && e.update(n, t.ELEMENT_ARRAY_BUFFER);
                    for (var o in r) e.update(r[o], t.ARRAY_BUFFER);
                    i = i.morphAttributes;
                    for (o in i)
                        for (var n = i[o], r = 0, a = n.length; r < a; r++) e.update(n[r], t.ARRAY_BUFFER)
                },
                getWireframeAttribute: function(i) {
                    var n = o[i.id];
                    if (n) return n;
                    var n = [],
                        r = i.index,
                        a = i.attributes;
                    if (null !== r)
                        for (var r = r.array, a = 0, s = r.length; a < s; a += 3) {
                            var l = r[a + 0],
                                c = r[a + 1],
                                h = r[a + 2];
                            n.push(l, c, c, h, h, l)
                        } else
                            for (r = a.position.array, a = 0, s = r.length / 3 - 1; a < s; a += 3) l = a + 0, c = a + 1, h = a + 2, n.push(l, c, c, h, h, l);
                    return n = new(65535 < bt(n) ? vt : mt)(n, 1), e.update(n, t.ELEMENT_ARRAY_BUFFER), o[i.id] = n
                }
            }
        }

        function zt() {
            var t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id]) return t[e.id];
                    var n;
                    switch (e.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new l,
                                color: new G,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new l,
                                direction: new l,
                                color: new G,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new l,
                                color: new G,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new i
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new l,
                                skyColor: new G,
                                groundColor: new G
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new G,
                                position: new l,
                                halfWidth: new l,
                                halfHeight: new l
                            }
                    }
                    return t[e.id] = n
                }
            }
        }

        function Ht(t, e, i) {
            var n = {};
            return {
                update: function(t) {
                    var r = i.frame,
                        o = t.geometry,
                        a = e.get(t, o);
                    return n[a.id] !== r && (o.isGeometry && a.updateFromObject(t), e.update(a), n[a.id] = r), a
                },
                clear: function() {
                    n = {}
                }
            }
        }

        function jt(t) {
            t = t.split("\n");
            for (var e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
            return t.join("\n")
        }

        function Gt(t, e, i) {
            var n = t.createShader(e);
            return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(n), jt(i)), n
        }

        function Vt(t) {
            switch (t) {
                case 3e3:
                    return ["Linear", "( value )"];
                case 3001:
                    return ["sRGB", "( value )"];
                case 3002:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case 3007:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    throw Error("unsupported encoding: " + t)
            }
        }

        function Wt(t, e) {
            var i = Vt(e);
            return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
        }

        function Xt(t, e) {
            var i = Vt(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
        }

        function qt(t, e) {
            var i;
            switch (e) {
                case 1:
                    i = "Linear";
                    break;
                case 2:
                    i = "Reinhard";
                    break;
                case 3:
                    i = "Uncharted2";
                    break;
                case 4:
                    i = "OptimizedCineon";
                    break;
                default:
                    throw Error("unsupported toneMapping: " + e)
            }
            return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
        }

        function $t(t, e, i) {
            return t = t || {}, [t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Zt).join("\n");
        }

        function Yt(t) {
            var e, i = [];
            for (e in t) {
                var n = t[e];
                !1 !== n && i.push("#define " + e + " " + n)
            }
            return i.join("\n")
        }

        function Zt(t) {
            return "" !== t
        }

        function Qt(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        }

        function Jt(t) {
            return t.replace(/^[ \t]*#include +<([\w\d.]+)>/gm, function(t, e) {
                var i = Rr[e];
                if (void 0 === i) throw Error("Can not resolve #include <" + e + ">");
                return Jt(i)
            })
        }

        function Kt(t) {
            return t.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, i, n) {
                for (t = "", e = parseInt(e); e < parseInt(i); e++) t += n.replace(/\[ i \]/g, "[ " + e + " ]");
                return t
            })
        }

        function te(t, e, i, n) {
            var r = t.context,
                o = i.extensions,
                a = i.defines,
                s = i.__webglShader.vertexShader,
                l = i.__webglShader.fragmentShader,
                c = "SHADOWMAP_TYPE_BASIC";
            1 === n.shadowMapType ? c = "SHADOWMAP_TYPE_PCF" : 2 === n.shadowMapType && (c = "SHADOWMAP_TYPE_PCF_SOFT");
            var h = "ENVMAP_TYPE_CUBE",
                u = "ENVMAP_MODE_REFLECTION",
                d = "ENVMAP_BLENDING_MULTIPLY";
            if (n.envMap) {
                switch (i.envMap.mapping) {
                    case 301:
                    case 302:
                        h = "ENVMAP_TYPE_CUBE";
                        break;
                    case 306:
                    case 307:
                        h = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case 303:
                    case 304:
                        h = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case 305:
                        h = "ENVMAP_TYPE_SPHERE"
                }
                switch (i.envMap.mapping) {
                    case 302:
                    case 304:
                        u = "ENVMAP_MODE_REFRACTION"
                }
                switch (i.combine) {
                    case 0:
                        d = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        d = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        d = "ENVMAP_BLENDING_ADD"
                }
            }
            var p = 0 < t.gammaFactor ? t.gammaFactor : 1,
                o = $t(o, n, t.extensions),
                f = Yt(a),
                m = r.createProgram();
            i.isRawShaderMaterial ? (a = [f, "\n"].filter(Zt).join("\n"), c = [o, f, "\n"].filter(Zt).join("\n")) : (a = ["precision " + n.precision + " float;", "precision " + n.precision + " int;", "#define SHADER_NAME " + i.__webglShader.name, f, n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + p, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + n.numClippingPlanes, n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Zt).join("\n"), c = [o, "precision " + n.precision + " float;", "precision " + n.precision + " int;", "#define SHADER_NAME " + i.__webglShader.name, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest : "", "#define GAMMA_FACTOR " + p, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + n.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (n.numClippingPlanes - n.numClipIntersection), n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", n.envMap && t.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Rr.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? qt("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.outputEncoding || n.mapEncoding || n.envMapEncoding || n.emissiveMapEncoding ? Rr.encodings_pars_fragment : "", n.mapEncoding ? Wt("mapTexelToLinear", n.mapEncoding) : "", n.envMapEncoding ? Wt("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? Wt("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.outputEncoding ? Xt("linearToOutputTexel", n.outputEncoding) : "", n.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Zt).join("\n")), s = Jt(s, n), s = Qt(s, n), l = Jt(l, n), l = Qt(l, n), i.isShaderMaterial || (s = Kt(s), l = Kt(l)), l = c + l, s = Gt(r, r.VERTEX_SHADER, a + s), l = Gt(r, r.FRAGMENT_SHADER, l), r.attachShader(m, s), r.attachShader(m, l), void 0 !== i.index0AttributeName ? r.bindAttribLocation(m, 0, i.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), n = r.getProgramInfoLog(m), h = r.getShaderInfoLog(s), u = r.getShaderInfoLog(l), p = d = !0, !1 === r.getProgramParameter(m, r.LINK_STATUS) ? (d = !1, console.error("THREE.WebGLProgram: shader error: ", r.getError(), "gl.VALIDATE_STATUS", r.getProgramParameter(m, r.VALIDATE_STATUS), "gl.getProgramInfoLog", n, h, u)) : "" !== n ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", n) : "" !== h && "" !== u || (p = !1), p && (this.diagnostics = {
                runnable: d,
                material: i,
                programLog: n,
                vertexShader: {
                    log: h,
                    prefix: a
                },
                fragmentShader: {
                    log: u,
                    prefix: c
                }
            }), r.deleteShader(s), r.deleteShader(l);
            var g;
            this.getUniforms = function() {
                return void 0 === g && (g = new j(r, m, t)), g
            };
            var v;
            return this.getAttributes = function() {
                if (void 0 === v) {
                    for (var t = {}, e = r.getProgramParameter(m, r.ACTIVE_ATTRIBUTES), i = 0; i < e; i++) {
                        var n = r.getActiveAttrib(m, i).name;
                        t[n] = r.getAttribLocation(m, n)
                    }
                    v = t
                }
                return v
            }, this.destroy = function() {
                r.deleteProgram(m), this.program = void 0
            }, Object.defineProperties(this, {
                uniforms: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                    }
                },
                attributes: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                    }
                }
            }), this.id = Ir++, this.code = e, this.usedTimes = 1, this.program = m, this.vertexShader = s, this.fragmentShader = l, this
        }

        function ee(t, e) {
            function i(t, e) {
                var i;
                return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding) : i = 3e3, 3e3 === i && e && (i = 3007), i
            }
            var n = [],
                r = {
                    MeshDepthMaterial: "depth",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points"
                },
                o = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
            this.getParameters = function(n, o, a, s, l, c) {
                var h, u = r[n.type];
                if (c.isSkinnedMesh)
                    if (h = c.skeleton.bones, e.floatVertexTextures) h = 1024;
                    else {
                        var d = Math.min(Math.floor((e.maxVertexUniforms - 20) / 4), h.length);
                        d < h.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + h.length + " bones. This GPU supports " + d + "."), h = 0) : h = d
                    }
                else h = 0;
                d = t.getPrecision(), null !== n.precision && (d = e.getMaxPrecision(n.precision), d !== n.precision && console.warn("THREE.WebGLProgram.getParameters:", n.precision, "not supported, using", d, "instead."));
                var p = t.getRenderTarget();
                return {
                    shaderID: u,
                    precision: d,
                    supportsVertexTextures: e.vertexTextures,
                    outputEncoding: i(p ? p.texture : null, t.gammaOutput),
                    map: !!n.map,
                    mapEncoding: i(n.map, t.gammaInput),
                    envMap: !!n.envMap,
                    envMapMode: n.envMap && n.envMap.mapping,
                    envMapEncoding: i(n.envMap, t.gammaInput),
                    envMapCubeUV: !!n.envMap && (306 === n.envMap.mapping || 307 === n.envMap.mapping),
                    lightMap: !!n.lightMap,
                    aoMap: !!n.aoMap,
                    emissiveMap: !!n.emissiveMap,
                    emissiveMapEncoding: i(n.emissiveMap, t.gammaInput),
                    bumpMap: !!n.bumpMap,
                    normalMap: !!n.normalMap,
                    displacementMap: !!n.displacementMap,
                    roughnessMap: !!n.roughnessMap,
                    metalnessMap: !!n.metalnessMap,
                    specularMap: !!n.specularMap,
                    alphaMap: !!n.alphaMap,
                    gradientMap: !!n.gradientMap,
                    combine: n.combine,
                    vertexColors: n.vertexColors,
                    fog: !!a,
                    useFog: n.fog,
                    fogExp: a && a.isFogExp2,
                    flatShading: 1 === n.shading,
                    sizeAttenuation: n.sizeAttenuation,
                    logarithmicDepthBuffer: e.logarithmicDepthBuffer,
                    skinning: n.skinning && 0 < h,
                    maxBones: h,
                    useVertexTexture: e.floatVertexTextures,
                    morphTargets: n.morphTargets,
                    morphNormals: n.morphNormals,
                    maxMorphTargets: t.maxMorphTargets,
                    maxMorphNormals: t.maxMorphNormals,
                    numDirLights: o.directional.length,
                    numPointLights: o.point.length,
                    numSpotLights: o.spot.length,
                    numRectAreaLights: o.rectArea.length,
                    numHemiLights: o.hemi.length,
                    numClippingPlanes: s,
                    numClipIntersection: l,
                    dithering: n.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && c.receiveShadow && 0 < o.shadows.length,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: t.toneMapping,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: n.premultipliedAlpha,
                    alphaTest: n.alphaTest,
                    doubleSided: 2 === n.side,
                    flipSided: 1 === n.side,
                    depthPacking: void 0 !== n.depthPacking && n.depthPacking
                }
            }, this.getProgramCode = function(t, e) {
                var i = [];
                if (e.shaderID ? i.push(e.shaderID) : (i.push(t.fragmentShader), i.push(t.vertexShader)), void 0 !== t.defines)
                    for (var n in t.defines) i.push(n), i.push(t.defines[n]);
                for (n = 0; n < o.length; n++) i.push(e[o[n]]);
                return i.join()
            }, this.acquireProgram = function(e, i, r) {
                for (var o, a = 0, s = n.length; a < s; a++) {
                    var l = n[a];
                    if (l.code === r) {
                        o = l, ++o.usedTimes;
                        break
                    }
                }
                return void 0 === o && (o = new te(t, r, e, i), n.push(o)), o
            }, this.releaseProgram = function(t) {
                if (0 === --t.usedTimes) {
                    var e = n.indexOf(t);
                    n[e] = n[n.length - 1], n.pop(), t.destroy()
                }
            }, this.programs = n
        }

        function ie(t, e, i, n, r, o, a) {
            function s(t, e) {
                if (t.width > e || t.height > e) {
                    var i = e / Math.max(t.width, t.height),
                        n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    return n.width = Math.floor(t.width * i), n.height = Math.floor(t.height * i), n.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + n.width + "x" + n.height, t), n
                }
                return t
            }

            function l(t) {
                return yr.isPowerOfTwo(t.width) && yr.isPowerOfTwo(t.height)
            }

            function c(e) {
                return 1003 === e || 1004 === e || 1005 === e ? t.NEAREST : t.LINEAR
            }

            function h(e) {
                e = e.target, e.removeEventListener("dispose", h);
                t: {
                    var i = n.get(e);
                    if (e.image && i.__image__webglTextureCube) t.deleteTexture(i.__image__webglTextureCube);
                    else {
                        if (void 0 === i.__webglInit) break t;
                        t.deleteTexture(i.__webglTexture)
                    }
                    n.remove(e)
                }
                a.textures--
            }

            function u(e) {
                e = e.target, e.removeEventListener("dispose", u);
                var i = n.get(e),
                    r = n.get(e.texture);
                if (e) {
                    if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube)
                        for (r = 0; 6 > r; r++) t.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[r]);
                    else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                    n.remove(e.texture), n.remove(e)
                }
                a.textures--
            }

            function d(e, c) {
                var u = n.get(e);
                if (0 < e.version && u.__version !== e.version) {
                    var d = e.image;
                    if (void 0 === d) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
                    else {
                        if (!1 !== d.complete) {
                            void 0 === u.__webglInit && (u.__webglInit = !0, e.addEventListener("dispose", h), u.__webglTexture = t.createTexture(), a.textures++), i.activeTexture(t.TEXTURE0 + c), i.bindTexture(t.TEXTURE_2D, u.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, e.unpackAlignment);
                            var f = s(e.image, r.maxTextureSize);
                            if ((1001 !== e.wrapS || 1001 !== e.wrapT || 1003 !== e.minFilter && 1006 !== e.minFilter) && !1 === l(f))
                                if (d = f, d instanceof HTMLImageElement || d instanceof HTMLCanvasElement) {
                                    var m = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                                    m.width = yr.nearestPowerOfTwo(d.width), m.height = yr.nearestPowerOfTwo(d.height), m.getContext("2d").drawImage(d, 0, 0, m.width, m.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + d.width + "x" + d.height + "). Resized to " + m.width + "x" + m.height, d), f = m
                                } else f = d;
                            var d = l(f),
                                m = o(e.format),
                                v = o(e.type);
                            p(t.TEXTURE_2D, e, d);
                            var y = e.mipmaps;
                            if (e.isDepthTexture) {
                                if (y = t.DEPTH_COMPONENT, 1015 === e.type) {
                                    if (!g) throw Error("Float Depth Texture only supported in WebGL2.0");
                                    y = t.DEPTH_COMPONENT32F
                                } else g && (y = t.DEPTH_COMPONENT16);
                                1026 === e.format && y === t.DEPTH_COMPONENT && 1012 !== e.type && 1014 !== e.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), e.type = 1012, v = o(e.type)), 1027 === e.format && (y = t.DEPTH_STENCIL, 1020 !== e.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), e.type = 1020, v = o(e.type))), i.texImage2D(t.TEXTURE_2D, 0, y, f.width, f.height, 0, m, v, null)
                            } else if (e.isDataTexture)
                                if (0 < y.length && d) {
                                    for (var _ = 0, x = y.length; _ < x; _++) f = y[_], i.texImage2D(t.TEXTURE_2D, _, m, f.width, f.height, 0, m, v, f.data);
                                    e.generateMipmaps = !1
                                } else i.texImage2D(t.TEXTURE_2D, 0, m, f.width, f.height, 0, m, v, f.data);
                            else if (e.isCompressedTexture)
                                for (_ = 0, x = y.length; _ < x; _++) f = y[_], 1023 !== e.format && 1022 !== e.format ? -1 < i.getCompressedTextureFormats().indexOf(m) ? i.compressedTexImage2D(t.TEXTURE_2D, _, m, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(t.TEXTURE_2D, _, m, f.width, f.height, 0, m, v, f.data);
                            else if (0 < y.length && d) {
                                for (_ = 0, x = y.length; _ < x; _++) f = y[_], i.texImage2D(t.TEXTURE_2D, _, m, m, v, f);
                                e.generateMipmaps = !1
                            } else i.texImage2D(t.TEXTURE_2D, 0, m, m, v, f);
                            return e.generateMipmaps && d && t.generateMipmap(t.TEXTURE_2D), u.__version = e.version, void(e.onUpdate && e.onUpdate(e))
                        }
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
                    }
                }
                i.activeTexture(t.TEXTURE0 + c), i.bindTexture(t.TEXTURE_2D, u.__webglTexture)
            }

            function p(i, a, s) {
                s ? (t.texParameteri(i, t.TEXTURE_WRAP_S, o(a.wrapS)), t.texParameteri(i, t.TEXTURE_WRAP_T, o(a.wrapT)), t.texParameteri(i, t.TEXTURE_MAG_FILTER, o(a.magFilter)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, o(a.minFilter))) : (t.texParameteri(i, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(i, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), 1001 === a.wrapS && 1001 === a.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", a), t.texParameteri(i, t.TEXTURE_MAG_FILTER, c(a.magFilter)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, c(a.minFilter)), 1003 !== a.minFilter && 1006 !== a.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", a)), !(s = e.get("EXT_texture_filter_anisotropic")) || 1015 === a.type && null === e.get("OES_texture_float_linear") || 1016 === a.type && null === e.get("OES_texture_half_float_linear") || !(1 < a.anisotropy || n.get(a).__currentAnisotropy) || (t.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy)
            }

            function f(e, r, a, s) {
                var l = o(r.texture.format),
                    c = o(r.texture.type);
                i.texImage2D(s, 0, l, r.width, r.height, 0, l, c, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, a, s, n.get(r.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function m(e, i) {
                t.bindRenderbuffer(t.RENDERBUFFER, e), i.depthBuffer && !i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : i.depthBuffer && i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, i.width, i.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, i.width, i.height), t.bindRenderbuffer(t.RENDERBUFFER, null)
            }
            var g = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext;
            this.setTexture2D = d, this.setTextureCube = function(e, c) {
                var u = n.get(e);
                if (6 === e.image.length)
                    if (0 < e.version && u.__version !== e.version) {
                        u.__image__webglTextureCube || (e.addEventListener("dispose", h), u.__image__webglTextureCube = t.createTexture(), a.textures++), i.activeTexture(t.TEXTURE0 + c), i.bindTexture(t.TEXTURE_CUBE_MAP, u.__image__webglTextureCube), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                        for (var d = e && e.isCompressedTexture, f = e.image[0] && e.image[0].isDataTexture, m = [], g = 0; 6 > g; g++) m[g] = d || f ? f ? e.image[g].image : e.image[g] : s(e.image[g], r.maxCubemapSize);
                        var v = l(m[0]),
                            y = o(e.format),
                            _ = o(e.type);
                        for (p(t.TEXTURE_CUBE_MAP, e, v), g = 0; 6 > g; g++)
                            if (d)
                                for (var x, b = m[g].mipmaps, w = 0, T = b.length; w < T; w++) x = b[w], 1023 !== e.format && 1022 !== e.format ? -1 < i.getCompressedTextureFormats().indexOf(y) ? i.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, w, y, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, w, y, x.width, x.height, 0, y, _, x.data);
                            else f ? i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, y, m[g].width, m[g].height, 0, y, _, m[g].data) : i.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, y, y, _, m[g]);
                        e.generateMipmaps && v && t.generateMipmap(t.TEXTURE_CUBE_MAP), u.__version = e.version, e.onUpdate && e.onUpdate(e)
                    } else i.activeTexture(t.TEXTURE0 + c), i.bindTexture(t.TEXTURE_CUBE_MAP, u.__image__webglTextureCube)
            }, this.setTextureCubeDynamic = function(e, r) {
                i.activeTexture(t.TEXTURE0 + r), i.bindTexture(t.TEXTURE_CUBE_MAP, n.get(e).__webglTexture)
            }, this.setupRenderTarget = function(e) {
                var r = n.get(e),
                    o = n.get(e.texture);
                e.addEventListener("dispose", u), o.__webglTexture = t.createTexture(), a.textures++;
                var s = !0 === e.isWebGLRenderTargetCube,
                    c = l(e);
                if (s) {
                    r.__webglFramebuffer = [];
                    for (var h = 0; 6 > h; h++) r.__webglFramebuffer[h] = t.createFramebuffer()
                } else r.__webglFramebuffer = t.createFramebuffer();
                if (s) {
                    for (i.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture), p(t.TEXTURE_CUBE_MAP, e.texture, c), h = 0; 6 > h; h++) f(r.__webglFramebuffer[h], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + h);
                    e.texture.generateMipmaps && c && t.generateMipmap(t.TEXTURE_CUBE_MAP), i.bindTexture(t.TEXTURE_CUBE_MAP, null)
                } else i.bindTexture(t.TEXTURE_2D, o.__webglTexture), p(t.TEXTURE_2D, e.texture, c), f(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), e.texture.generateMipmaps && c && t.generateMipmap(t.TEXTURE_2D), i.bindTexture(t.TEXTURE_2D, null);
                if (e.depthBuffer) {
                    if (r = n.get(e), o = !0 === e.isWebGLRenderTargetCube, e.depthTexture) {
                        if (o) throw Error("target.depthTexture not supported in Cube render targets");
                        if (e && e.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported!");
                        if (t.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), !e.depthTexture || !e.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        if (n.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), d(e.depthTexture, 0), r = n.get(e.depthTexture).__webglTexture, 1026 === e.depthTexture.format) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0);
                        else {
                            if (1027 !== e.depthTexture.format) throw Error("Unknown depthTexture format");
                            t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0)
                        }
                    } else if (o)
                        for (r.__webglDepthbuffer = [], o = 0; 6 > o; o++) t.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[o]), r.__webglDepthbuffer[o] = t.createRenderbuffer(), m(r.__webglDepthbuffer[o], e);
                    else t.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), m(r.__webglDepthbuffer, e);
                    t.bindFramebuffer(t.FRAMEBUFFER, null)
                }
            }, this.updateRenderTargetMipmap = function(e) {
                var r = e.texture;
                r.generateMipmaps && l(e) && 1003 !== r.minFilter && 1006 !== r.minFilter && (e = e && e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D, r = n.get(r).__webglTexture, i.bindTexture(e, r), t.generateMipmap(e), i.bindTexture(e, null))
            }
        }

        function ne() {
            var t = {};
            return {
                get: function(e) {
                    e = e.uuid;
                    var i = t[e];
                    return void 0 === i && (i = {}, t[e] = i), i
                },
                remove: function(e) {
                    delete t[e.uuid]
                },
                clear: function() {
                    t = {}
                }
            }
        }

        function re(t, e, i) {
            function n(e, i, n) {
                var r = new Uint8Array(4),
                    o = t.createTexture();
                for (t.bindTexture(e, o), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST), e = 0; e < n; e++) t.texImage2D(i + e, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
                return o
            }

            function o(e) {
                !0 !== _[e] && (t.enable(e), _[e] = !0)
            }

            function a(e) {
                !1 !== _[e] && (t.disable(e), _[e] = !1)
            }

            function s(e, n, r, s, l, c, h, u) {
                0 !== e ? o(t.BLEND) : a(t.BLEND), e === b && u === C || (2 === e ? u ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE)) : 3 === e ? u ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : 4 === e ? u ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR)) : u ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)), b = e, C = u), 5 === e ? (l = l || n, c = c || r, h = h || s, n === w && l === M || (t.blendEquationSeparate(i(n), i(l)), w = n, M = l), r === T && s === S && c === E && h === A || (t.blendFuncSeparate(i(r), i(s), i(c), i(h)), T = r, S = s, E = c, A = h)) : A = E = M = S = T = w = null
            }

            function l(e) {
                P !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), P = e)
            }

            function c(e) {
                0 !== e ? (o(t.CULL_FACE), e !== R && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : a(t.CULL_FACE), R = e
            }

            function h(e, i, n) {
                e ? (o(t.POLYGON_OFFSET_FILL), (k !== i || O !== n) && (t.polygonOffset(i, n), k = i, O = n)) : a(t.POLYGON_OFFSET_FILL)
            }

            function u(e) {
                void 0 === e && (e = t.TEXTURE0 + I - 1), B !== e && (t.activeTexture(e), B = e)
            }
            var d = new function() {
                    var e = !1,
                        i = new r,
                        n = null,
                        o = new r;
                    return {
                        setMask: function(i) {
                            n === i || e || (t.colorMask(i, i, i, i), n = i)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e, n, r, a, s) {
                            !0 === s && (e *= a, n *= a, r *= a), i.set(e, n, r, a), !1 === o.equals(i) && (t.clearColor(e, n, r, a), o.copy(i))
                        },
                        reset: function() {
                            e = !1, n = null, o.set(0, 0, 0, 1)
                        }
                    }
                },
                p = new function() {
                    var e = !1,
                        i = null,
                        n = null,
                        r = null;
                    return {
                        setTest: function(e) {
                            e ? o(t.DEPTH_TEST) : a(t.DEPTH_TEST)
                        },
                        setMask: function(n) {
                            i === n || e || (t.depthMask(n), i = n)
                        },
                        setFunc: function(e) {
                            if (n !== e) {
                                if (e) switch (e) {
                                    case 0:
                                        t.depthFunc(t.NEVER);
                                        break;
                                    case 1:
                                        t.depthFunc(t.ALWAYS);
                                        break;
                                    case 2:
                                        t.depthFunc(t.LESS);
                                        break;
                                    case 3:
                                        t.depthFunc(t.LEQUAL);
                                        break;
                                    case 4:
                                        t.depthFunc(t.EQUAL);
                                        break;
                                    case 5:
                                        t.depthFunc(t.GEQUAL);
                                        break;
                                    case 6:
                                        t.depthFunc(t.GREATER);
                                        break;
                                    case 7:
                                        t.depthFunc(t.NOTEQUAL);
                                        break;
                                    default:
                                        t.depthFunc(t.LEQUAL)
                                } else t.depthFunc(t.LEQUAL);
                                n = e
                            }
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            r !== e && (t.clearDepth(e), r = e)
                        },
                        reset: function() {
                            e = !1, r = n = i = null
                        }
                    }
                },
                f = new function() {
                    var e = !1,
                        i = null,
                        n = null,
                        r = null,
                        s = null,
                        l = null,
                        c = null,
                        h = null,
                        u = null;
                    return {
                        setTest: function(e) {
                            e ? o(t.STENCIL_TEST) : a(t.STENCIL_TEST)
                        },
                        setMask: function(n) {
                            i === n || e || (t.stencilMask(n), i = n)
                        },
                        setFunc: function(e, i, o) {
                            n === e && r === i && s === o || (t.stencilFunc(e, i, o), n = e, r = i, s = o)
                        },
                        setOp: function(e, i, n) {
                            l === e && c === i && h === n || (t.stencilOp(e, i, n), l = e, c = i, h = n)
                        },
                        setLocked: function(t) {
                            e = t
                        },
                        setClear: function(e) {
                            u !== e && (t.clearStencil(e), u = e)
                        },
                        reset: function() {
                            e = !1, u = h = c = l = s = r = n = i = null
                        }
                    }
                },
                m = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                g = new Uint8Array(m),
                v = new Uint8Array(m),
                y = new Uint8Array(m),
                _ = {},
                x = null,
                b = null,
                w = null,
                T = null,
                S = null,
                M = null,
                E = null,
                A = null,
                C = !1,
                P = null,
                R = null,
                L = null,
                k = null,
                O = null,
                D = null,
                I = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                m = parseFloat(/^WebGL\ ([0-9])/.exec(t.getParameter(t.VERSION))[1]),
                N = 1 <= parseFloat(m),
                B = null,
                U = {},
                F = new r,
                z = new r,
                H = {};
            return H[t.TEXTURE_2D] = n(t.TEXTURE_2D, t.TEXTURE_2D, 1), H[t.TEXTURE_CUBE_MAP] = n(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), {
                buffers: {
                    color: d,
                    depth: p,
                    stencil: f
                },
                init: function() {
                    d.setClear(0, 0, 0, 1), p.setClear(1), f.setClear(0), o(t.DEPTH_TEST), p.setFunc(3), l(!1), c(1), o(t.CULL_FACE), o(t.BLEND), s(1)
                },
                initAttributes: function() {
                    for (var t = 0, e = g.length; t < e; t++) g[t] = 0
                },
                enableAttribute: function(i) {
                    g[i] = 1, 0 === v[i] && (t.enableVertexAttribArray(i), v[i] = 1), 0 !== y[i] && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, 0), y[i] = 0)
                },
                enableAttributeAndDivisor: function(i, n) {
                    g[i] = 1, 0 === v[i] && (t.enableVertexAttribArray(i), v[i] = 1), y[i] !== n && (e.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(i, n), y[i] = n)
                },
                disableUnusedAttributes: function() {
                    for (var e = 0, i = v.length; e !== i; ++e) v[e] !== g[e] && (t.disableVertexAttribArray(e), v[e] = 0)
                },
                enable: o,
                disable: a,
                getCompressedTextureFormats: function() {
                    if (null === x && (x = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1")))
                        for (var i = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), n = 0; n < i.length; n++) x.push(i[n]);
                    return x
                },
                setBlending: s,
                setMaterial: function(e) {
                    2 === e.side ? a(t.CULL_FACE) : o(t.CULL_FACE), l(1 === e.side), !0 === e.transparent ? s(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : s(0), p.setFunc(e.depthFunc), p.setTest(e.depthTest), p.setMask(e.depthWrite), d.setMask(e.colorWrite), h(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                },
                setFlipSided: l,
                setCullFace: c,
                setLineWidth: function(e) {
                    e !== L && (N && t.lineWidth(e), L = e)
                },
                setPolygonOffset: h,
                getScissorTest: function() {
                    return D
                },
                setScissorTest: function(e) {
                    (D = e) ? o(t.SCISSOR_TEST): a(t.SCISSOR_TEST)
                },
                activeTexture: u,
                bindTexture: function(e, i) {
                    null === B && u();
                    var n = U[B];
                    void 0 === n && (n = {
                        type: void 0,
                        texture: void 0
                    }, U[B] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || H[e]), n.type = e, n.texture = i)
                },
                compressedTexImage2D: function() {
                    try {
                        t.compressedTexImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error(t)
                    }
                },
                texImage2D: function() {
                    try {
                        t.texImage2D.apply(t, arguments)
                    } catch (t) {
                        console.error(t)
                    }
                },
                scissor: function(e) {
                    !1 === F.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), F.copy(e))
                },
                viewport: function(e) {
                    !1 === z.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), z.copy(e))
                },
                reset: function() {
                    for (var e = 0; e < v.length; e++) 1 === v[e] && (t.disableVertexAttribArray(e), v[e] = 0);
                    _ = {}, B = x = null, U = {}, R = P = b = null, d.reset(), p.reset(), f.reset()
                }
            }
        }

        function oe(t, e, i) {
            function n(e) {
                if ("highp" === e) {
                    if (0 < t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision && 0 < t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && 0 < t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision && 0 < t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
            }
            var r, o = void 0 !== i.precision ? i.precision : "highp",
                a = n(o);
            a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a), i = !0 === i.logarithmicDepthBuffer && !!e.get("EXT_frag_depth");
            var a = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                s = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                l = t.getParameter(t.MAX_TEXTURE_SIZE),
                c = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
                h = t.getParameter(t.MAX_VERTEX_ATTRIBS),
                u = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
                d = t.getParameter(t.MAX_VARYING_VECTORS),
                p = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
                f = 0 < s,
                m = !!e.get("OES_texture_float");
            return {
                getMaxAnisotropy: function() {
                    if (void 0 !== r) return r;
                    var i = e.get("EXT_texture_filter_anisotropic");
                    return r = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                },
                getMaxPrecision: n,
                precision: o,
                logarithmicDepthBuffer: i,
                maxTextures: a,
                maxVertexTextures: s,
                maxTextureSize: l,
                maxCubemapSize: c,
                maxAttributes: h,
                maxVertexUniforms: u,
                maxVaryings: d,
                maxFragmentUniforms: p,
                vertexTextures: f,
                floatFragmentTextures: m,
                floatVertexTextures: f && m
            }
        }

        function ae(t) {
            var e = {};
            return {
                get: function(i) {
                    if (void 0 !== e[i]) return e[i];
                    var n;
                    switch (i) {
                        case "WEBGL_depth_texture":
                            n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        case "WEBGL_compressed_texture_etc1":
                            n = t.getExtension("WEBGL_compressed_texture_etc1");
                            break;
                        default:
                            n = t.getExtension(i)
                    }
                    return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), e[i] = n
                }
            }
        }

        function se() {
            function t() {
                c.value !== n && (c.value = n, c.needsUpdate = 0 < r), i.numPlanes = r, i.numIntersection = 0
            }

            function e(t, e, n, r) {
                var o = null !== t ? t.length : 0,
                    a = null;
                if (0 !== o) {
                    if (a = c.value, !0 !== r || null === a)
                        for (r = n + 4 * o, e = e.matrixWorldInverse, l.getNormalMatrix(e), (null === a || a.length < r) && (a = new Float32Array(r)), r = 0; r !== o; ++r, n += 4) s.copy(t[r]).applyMatrix4(e, l), s.normal.toArray(a, n), a[n + 3] = s.constant;
                    c.value = a, c.needsUpdate = !0
                }
                return i.numPlanes = o, a
            }
            var i = this,
                n = null,
                r = 0,
                o = !1,
                a = !1,
                s = new K,
                l = new J,
                c = {
                    value: null,
                    needsUpdate: !1
                };
            this.uniform = c, this.numIntersection = this.numPlanes = 0, this.init = function(t, i, a) {
                var s = 0 !== t.length || i || 0 !== r || o;
                return o = i, n = e(t, a, 0), r = t.length, s
            }, this.beginShadows = function() {
                a = !0, e(null)
            }, this.endShadows = function() {
                a = !1, t()
            }, this.setState = function(i, s, l, h, u, d) {
                if (!o || null === i || 0 === i.length || a && !l) a ? e(null) : t();
                else {
                    l = a ? 0 : r;
                    var p = 4 * l,
                        f = u.clippingState || null;
                    for (c.value = f, f = e(i, h, p, d), i = 0; i !== p; ++i) f[i] = n[i];
                    u.clippingState = f, this.numIntersection = s ? this.numPlanes : 0, this.numPlanes += l
                }
            }
        }

        function le(t) {
            function e() {
                bt.init(), bt.scissor(H.copy(nt).multiplyScalar(it)),
                    bt.viewport(q.copy(ot).multiplyScalar(it)), bt.buffers.color.setClear(Z.r, Z.g, Z.b, Q, A)
            }

            function i() {
                z = I = null, F = "", U = -1, bt.reset()
            }

            function n(t) {
                t.preventDefault(), i(), e(), wt.clear(), Ot.clear()
            }

            function o(t) {
                t = t.target, t.removeEventListener("dispose", o), a(t), wt.remove(t)
            }

            function a(t) {
                var e = wt.get(t).program;
                t.program = void 0, void 0 !== e && Dt.releaseProgram(e)
            }

            function s(t, e, i) {
                t.render(function(t) {
                    D.renderBufferImmediate(t, e, i)
                })
            }

            function u(t, e) {
                return Math.abs(e[0]) - Math.abs(t[0])
            }

            function d(t, e, i) {
                if (t.visible) {
                    if (t.layers.test(e.layers))
                        if (t.isLight) P.push(t);
                        else if (t.isSprite) t.frustumCulled && !at.intersectsSprite(t) || k.push(t);
                    else if (t.isLensFlare) O.push(t);
                    else if (t.isImmediateRenderObject) i && dt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ut), R.push(t, null, t.material, dt.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || at.intersectsObject(t))) {
                        i && dt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(ut);
                        var n = Ot.update(t),
                            r = t.material;
                        if (Array.isArray(r))
                            for (var o = n.groups, a = 0, s = o.length; a < s; a++) {
                                var l = o[a],
                                    c = r[l.materialIndex];
                                c && c.visible && R.push(t, n, c, dt.z, l)
                            } else r.visible && R.push(t, n, r, dt.z, null)
                    }
                    for (t = t.children, a = 0, s = t.length; a < s; a++) d(t[a], e, i)
                }
            }

            function p(t, e, i, n) {
                for (var r = 0, o = t.length; r < o; r++) {
                    var a = t[r],
                        s = a.object,
                        l = a.geometry,
                        c = void 0 === n ? a.material : n,
                        a = a.group;
                    if (s.onBeforeRender(D, e, i, l, c, a), i.isArrayCamera && i.enabled)
                        for (var h = i.cameras, u = 0, d = h.length; u < d; u++) {
                            var p = h[u],
                                m = p.bounds;
                            D.setViewport(m.x * J * it, m.y * K * it, m.z * J * it, m.w * K * it), D.setScissor(m.x * J * it, m.y * K * it, m.z * J * it, m.w * K * it), D.setScissorTest(!0), f(s, e, p, l, c, a)
                        } else f(s, e, i, l, c, a);
                    s.onAfterRender(D, e, i, l, c, a)
                }
            }

            function f(t, e, i, n, r, o) {
                t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject ? (bt.setMaterial(r), e = g(i, e.fog, r, t), F = "", s(t, e, r)) : D.renderBufferDirect(i, e.fog, n, r, t, o)
            }

            function m(t, e, i) {
                var n = wt.get(t);
                i = Dt.getParameters(t, mt, e, st.numPlanes, st.numIntersection, i);
                var r = Dt.getProgramCode(t, i),
                    s = n.program,
                    l = !0;
                if (void 0 === s) t.addEventListener("dispose", o);
                else if (s.code !== r) a(t);
                else {
                    if (void 0 !== i.shaderID) return;
                    l = !1
                }
                if (l && (i.shaderID ? (s = Lr[i.shaderID], n.__webglShader = {
                        name: t.type,
                        uniforms: Pr.clone(s.uniforms),
                        vertexShader: s.vertexShader,
                        fragmentShader: s.fragmentShader
                    }) : n.__webglShader = {
                        name: t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    }, t.__webglShader = n.__webglShader, s = Dt.acquireProgram(t, i, r), n.program = s, t.program = s), i = s.getAttributes(), t.morphTargets)
                    for (r = t.numSupportedMorphTargets = 0; r < D.maxMorphTargets; r++) 0 <= i["morphTarget" + r] && t.numSupportedMorphTargets++;
                if (t.morphNormals)
                    for (r = t.numSupportedMorphNormals = 0; r < D.maxMorphNormals; r++) 0 <= i["morphNormal" + r] && t.numSupportedMorphNormals++;
                i = n.__webglShader.uniforms, (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = st.numPlanes, n.numIntersection = st.numIntersection, i.clippingPlanes = st.uniform), n.fog = e, n.lightsHash = mt.hash, t.lights && (i.ambientLightColor.value = mt.ambient, i.directionalLights.value = mt.directional, i.spotLights.value = mt.spot, i.rectAreaLights.value = mt.rectArea, i.pointLights.value = mt.point, i.hemisphereLights.value = mt.hemi, i.directionalShadowMap.value = mt.directionalShadowMap, i.directionalShadowMatrix.value = mt.directionalShadowMatrix, i.spotShadowMap.value = mt.spotShadowMap, i.spotShadowMatrix.value = mt.spotShadowMatrix, i.pointShadowMap.value = mt.pointShadowMap, i.pointShadowMatrix.value = mt.pointShadowMatrix), t = n.program.getUniforms(), t = j.seqWithValue(t.seq, i), n.uniformsList = t
            }

            function g(t, e, i, n) {
                Y = 0;
                var r = wt.get(i);
                lt && (ht || t !== z) && st.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, t === z && i.id === U), !1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i.needsUpdate = !0 : i.lights && r.lightsHash !== mt.hash ? i.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === st.numPlanes && r.numIntersection === st.numIntersection || (i.needsUpdate = !0)), i.needsUpdate && (m(i, e, n), i.needsUpdate = !1);
                var o = !1,
                    a = !1,
                    s = !1,
                    l = r.program,
                    c = l.getUniforms(),
                    u = r.__webglShader.uniforms;
                if (l.id !== I && (yt.useProgram(l.program), I = l.id, s = a = o = !0), i.id !== U && (U = i.id, a = !0), (o || t !== z) && (c.setValue(yt, "projectionMatrix", t.projectionMatrix), xt.logarithmicDepthBuffer && c.setValue(yt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), t !== z && (z = t, s = a = !0), (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && (o = c.map.cameraPosition, void 0 !== o && o.setValue(yt, dt.setFromMatrixPosition(t.matrixWorld))), (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && c.setValue(yt, "viewMatrix", t.matrixWorldInverse), c.setValue(yt, "toneMappingExposure", D.toneMappingExposure), c.setValue(yt, "toneMappingWhitePoint", D.toneMappingWhitePoint)), i.skinning && (c.setOptional(yt, n, "bindMatrix"), c.setOptional(yt, n, "bindMatrixInverse"), t = n.skeleton))
                    if (o = t.bones, xt.floatVertexTextures) {
                        if (void 0 === t.boneTexture) {
                            var o = Math.sqrt(4 * o.length),
                                o = yr.nextPowerOfTwo(Math.ceil(o)),
                                o = Math.max(o, 4),
                                d = new Float32Array(o * o * 4);
                            d.set(t.boneMatrices);
                            var p = new h(d, o, o, 1023, 1015);
                            t.boneMatrices = d, t.boneTexture = p, t.boneTextureSize = o
                        }
                        c.setValue(yt, "boneTexture", t.boneTexture), c.setValue(yt, "boneTextureSize", t.boneTextureSize)
                    } else c.setOptional(yt, t, "boneMatrices");
                if (a) {
                    if (i.lights && (a = s, u.ambientLightColor.needsUpdate = a, u.directionalLights.needsUpdate = a, u.pointLights.needsUpdate = a, u.spotLights.needsUpdate = a, u.rectAreaLights.needsUpdate = a, u.hemisphereLights.needsUpdate = a), e && i.fog && (u.fogColor.value = e.color, e.isFog ? (u.fogNear.value = e.near, u.fogFar.value = e.far) : e.isFogExp2 && (u.fogDensity.value = e.density)), i.isMeshBasicMaterial || i.isMeshLambertMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.isMeshNormalMaterial || i.isMeshDepthMaterial) {
                        u.opacity.value = i.opacity, u.diffuse.value = i.color, i.emissive && u.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), u.map.value = i.map, u.specularMap.value = i.specularMap, u.alphaMap.value = i.alphaMap, i.lightMap && (u.lightMap.value = i.lightMap, u.lightMapIntensity.value = i.lightMapIntensity), i.aoMap && (u.aoMap.value = i.aoMap, u.aoMapIntensity.value = i.aoMapIntensity);
                        var f;
                        i.map ? f = i.map : i.specularMap ? f = i.specularMap : i.displacementMap ? f = i.displacementMap : i.normalMap ? f = i.normalMap : i.bumpMap ? f = i.bumpMap : i.roughnessMap ? f = i.roughnessMap : i.metalnessMap ? f = i.metalnessMap : i.alphaMap ? f = i.alphaMap : i.emissiveMap && (f = i.emissiveMap), void 0 !== f && (f.isWebGLRenderTarget && (f = f.texture), e = f.offset, f = f.repeat, u.offsetRepeat.value.set(e.x, e.y, f.x, f.y)), u.envMap.value = i.envMap, u.flipEnvMap.value = i.envMap && i.envMap.isCubeTexture ? -1 : 1, u.reflectivity.value = i.reflectivity, u.refractionRatio.value = i.refractionRatio
                    }
                    i.isLineBasicMaterial ? (u.diffuse.value = i.color, u.opacity.value = i.opacity) : i.isLineDashedMaterial ? (u.diffuse.value = i.color, u.opacity.value = i.opacity, u.dashSize.value = i.dashSize, u.totalSize.value = i.dashSize + i.gapSize, u.scale.value = i.scale) : i.isPointsMaterial ? (u.diffuse.value = i.color, u.opacity.value = i.opacity, u.size.value = i.size * it, u.scale.value = .5 * K, u.map.value = i.map, null !== i.map && (f = i.map.offset, i = i.map.repeat, u.offsetRepeat.value.set(f.x, f.y, i.x, i.y))) : i.isMeshLambertMaterial ? i.emissiveMap && (u.emissiveMap.value = i.emissiveMap) : i.isMeshToonMaterial ? (v(u, i), i.gradientMap && (u.gradientMap.value = i.gradientMap)) : i.isMeshPhongMaterial ? v(u, i) : i.isMeshPhysicalMaterial ? (u.clearCoat.value = i.clearCoat, u.clearCoatRoughness.value = i.clearCoatRoughness, y(u, i)) : i.isMeshStandardMaterial ? y(u, i) : i.isMeshDepthMaterial ? i.displacementMap && (u.displacementMap.value = i.displacementMap, u.displacementScale.value = i.displacementScale, u.displacementBias.value = i.displacementBias) : i.isMeshNormalMaterial && (i.bumpMap && (u.bumpMap.value = i.bumpMap, u.bumpScale.value = i.bumpScale), i.normalMap && (u.normalMap.value = i.normalMap, u.normalScale.value.copy(i.normalScale)), i.displacementMap && (u.displacementMap.value = i.displacementMap, u.displacementScale.value = i.displacementScale, u.displacementBias.value = i.displacementBias)), void 0 !== u.ltcMat && (u.ltcMat.value = Cr.LTC_MAT_TEXTURE), void 0 !== u.ltcMag && (u.ltcMag.value = Cr.LTC_MAG_TEXTURE), j.upload(yt, r.uniformsList, u, D)
                }
                return c.setValue(yt, "modelViewMatrix", n.modelViewMatrix), c.setValue(yt, "normalMatrix", n.normalMatrix), c.setValue(yt, "modelMatrix", n.matrixWorld), l
            }

            function v(t, e) {
                t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function y(t, e) {
                t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
            }

            function _(t, e) {
                var i, n, r, o, a, s, l, c = 0,
                    h = 0,
                    u = 0,
                    d = e.matrixWorldInverse,
                    p = 0,
                    f = 0,
                    m = 0,
                    g = 0,
                    v = 0;
                for (i = 0, n = t.length; i < n; i++)
                    if (r = t[i], o = r.color, a = r.intensity, s = r.distance, l = r.shadow && r.shadow.map ? r.shadow.map.texture : null, r.isAmbientLight) c += o.r * a, h += o.g * a, u += o.b * a;
                    else if (r.isDirectionalLight) {
                    var y = It.get(r);
                    y.color.copy(r.color).multiplyScalar(r.intensity), y.direction.setFromMatrixPosition(r.matrixWorld), dt.setFromMatrixPosition(r.target.matrixWorld), y.direction.sub(dt), y.direction.transformDirection(d), (y.shadow = r.castShadow) && (o = r.shadow, y.shadowBias = o.bias, y.shadowRadius = o.radius, y.shadowMapSize = o.mapSize), mt.directionalShadowMap[p] = l, mt.directionalShadowMatrix[p] = r.shadow.matrix, mt.directional[p] = y, p++
                } else r.isSpotLight ? (y = It.get(r), y.position.setFromMatrixPosition(r.matrixWorld), y.position.applyMatrix4(d), y.color.copy(o).multiplyScalar(a), y.distance = s, y.direction.setFromMatrixPosition(r.matrixWorld), dt.setFromMatrixPosition(r.target.matrixWorld), y.direction.sub(dt), y.direction.transformDirection(d), y.coneCos = Math.cos(r.angle), y.penumbraCos = Math.cos(r.angle * (1 - r.penumbra)), y.decay = 0 === r.distance ? 0 : r.decay, (y.shadow = r.castShadow) && (o = r.shadow, y.shadowBias = o.bias, y.shadowRadius = o.radius, y.shadowMapSize = o.mapSize), mt.spotShadowMap[m] = l, mt.spotShadowMatrix[m] = r.shadow.matrix, mt.spot[m] = y, m++) : r.isRectAreaLight ? (y = It.get(r), y.color.copy(o).multiplyScalar(a / (r.width * r.height)), y.position.setFromMatrixPosition(r.matrixWorld), y.position.applyMatrix4(d), ft.identity(), pt.copy(r.matrixWorld), pt.premultiply(d), ft.extractRotation(pt), y.halfWidth.set(.5 * r.width, 0, 0), y.halfHeight.set(0, .5 * r.height, 0), y.halfWidth.applyMatrix4(ft), y.halfHeight.applyMatrix4(ft), mt.rectArea[g] = y, g++) : r.isPointLight ? (y = It.get(r), y.position.setFromMatrixPosition(r.matrixWorld), y.position.applyMatrix4(d), y.color.copy(r.color).multiplyScalar(r.intensity), y.distance = r.distance, y.decay = 0 === r.distance ? 0 : r.decay, (y.shadow = r.castShadow) && (o = r.shadow, y.shadowBias = o.bias, y.shadowRadius = o.radius, y.shadowMapSize = o.mapSize), mt.pointShadowMap[f] = l, mt.pointShadowMatrix[f] = r.shadow.matrix, mt.point[f] = y, f++) : r.isHemisphereLight && (y = It.get(r), y.direction.setFromMatrixPosition(r.matrixWorld), y.direction.transformDirection(d), y.direction.normalize(), y.skyColor.copy(r.color).multiplyScalar(a), y.groundColor.copy(r.groundColor).multiplyScalar(a), mt.hemi[v] = y, v++);
                mt.ambient[0] = c, mt.ambient[1] = h, mt.ambient[2] = u, mt.directional.length = p, mt.spot.length = m, mt.rectArea.length = g, mt.point.length = f, mt.hemi.length = v, mt.hash = p + "," + f + "," + m + "," + g + "," + v + "," + mt.shadows.length
            }

            function x(t) {
                var e;
                if (1e3 === t) return yt.REPEAT;
                if (1001 === t) return yt.CLAMP_TO_EDGE;
                if (1002 === t) return yt.MIRRORED_REPEAT;
                if (1003 === t) return yt.NEAREST;
                if (1004 === t) return yt.NEAREST_MIPMAP_NEAREST;
                if (1005 === t) return yt.NEAREST_MIPMAP_LINEAR;
                if (1006 === t) return yt.LINEAR;
                if (1007 === t) return yt.LINEAR_MIPMAP_NEAREST;
                if (1008 === t) return yt.LINEAR_MIPMAP_LINEAR;
                if (1009 === t) return yt.UNSIGNED_BYTE;
                if (1017 === t) return yt.UNSIGNED_SHORT_4_4_4_4;
                if (1018 === t) return yt.UNSIGNED_SHORT_5_5_5_1;
                if (1019 === t) return yt.UNSIGNED_SHORT_5_6_5;
                if (1010 === t) return yt.BYTE;
                if (1011 === t) return yt.SHORT;
                if (1012 === t) return yt.UNSIGNED_SHORT;
                if (1013 === t) return yt.INT;
                if (1014 === t) return yt.UNSIGNED_INT;
                if (1015 === t) return yt.FLOAT;
                if (1016 === t && (e = _t.get("OES_texture_half_float"), null !== e)) return e.HALF_FLOAT_OES;
                if (1021 === t) return yt.ALPHA;
                if (1022 === t) return yt.RGB;
                if (1023 === t) return yt.RGBA;
                if (1024 === t) return yt.LUMINANCE;
                if (1025 === t) return yt.LUMINANCE_ALPHA;
                if (1026 === t) return yt.DEPTH_COMPONENT;
                if (1027 === t) return yt.DEPTH_STENCIL;
                if (100 === t) return yt.FUNC_ADD;
                if (101 === t) return yt.FUNC_SUBTRACT;
                if (102 === t) return yt.FUNC_REVERSE_SUBTRACT;
                if (200 === t) return yt.ZERO;
                if (201 === t) return yt.ONE;
                if (202 === t) return yt.SRC_COLOR;
                if (203 === t) return yt.ONE_MINUS_SRC_COLOR;
                if (204 === t) return yt.SRC_ALPHA;
                if (205 === t) return yt.ONE_MINUS_SRC_ALPHA;
                if (206 === t) return yt.DST_ALPHA;
                if (207 === t) return yt.ONE_MINUS_DST_ALPHA;
                if (208 === t) return yt.DST_COLOR;
                if (209 === t) return yt.ONE_MINUS_DST_COLOR;
                if (210 === t) return yt.SRC_ALPHA_SATURATE;
                if ((2001 === t || 2002 === t || 2003 === t || 2004 === t) && (e = _t.get("WEBGL_compressed_texture_s3tc"), null !== e)) {
                    if (2001 === t) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (2002 === t) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (2003 === t) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (2004 === t) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((2100 === t || 2101 === t || 2102 === t || 2103 === t) && (e = _t.get("WEBGL_compressed_texture_pvrtc"), null !== e)) {
                    if (2100 === t) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (2101 === t) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (2102 === t) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (2103 === t) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (2151 === t && (e = _t.get("WEBGL_compressed_texture_etc1"), null !== e)) return e.COMPRESSED_RGB_ETC1_WEBGL;
                if ((103 === t || 104 === t) && (e = _t.get("EXT_blend_minmax"), null !== e)) {
                    if (103 === t) return e.MIN_EXT;
                    if (104 === t) return e.MAX_EXT
                }
                return 1020 === t && (e = _t.get("WEBGL_depth_texture"), null !== e) ? e.UNSIGNED_INT_24_8_WEBGL : 0
            }
            console.log("THREE.WebGLRenderer", "85"), t = t || {};
            var b = void 0 !== t.canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                w = void 0 !== t.context ? t.context : null,
                T = void 0 !== t.alpha && t.alpha,
                S = void 0 === t.depth || t.depth,
                M = void 0 === t.stencil || t.stencil,
                E = void 0 !== t.antialias && t.antialias,
                A = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                C = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                P = [],
                R = null,
                L = new Float32Array(8),
                k = [],
                O = [];
            this.domElement = b, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var D = this,
                I = null,
                N = null,
                B = null,
                U = -1,
                F = "",
                z = null,
                H = new r,
                V = null,
                q = new r,
                Y = 0,
                Z = new G(0),
                Q = 0,
                J = b.width,
                K = b.height,
                it = 1,
                nt = new r(0, 0, J, K),
                rt = !1,
                ot = new r(0, 0, J, K),
                at = new tt,
                st = new se,
                lt = !1,
                ht = !1,
                ut = new c,
                dt = new l,
                pt = new c,
                ft = new c,
                mt = {
                    hash: "",
                    ambient: [0, 0, 0],
                    directional: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    rectArea: [],
                    point: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    shadows: []
                },
                gt = {
                    geometries: 0,
                    textures: 0
                },
                vt = {
                    frame: 0,
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0
                };
            this.info = {
                render: vt,
                memory: gt,
                programs: null
            };
            var yt;
            try {
                if (T = {
                        alpha: T,
                        depth: S,
                        stencil: M,
                        antialias: E,
                        premultipliedAlpha: A,
                        preserveDrawingBuffer: C
                    }, yt = w || b.getContext("webgl", T) || b.getContext("experimental-webgl", T), null === yt) {
                    if (null !== b.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
                    throw "Error creating WebGL context."
                }
                void 0 === yt.getShaderPrecisionFormat && (yt.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                }), b.addEventListener("webglcontextlost", n, !1)
            } catch (t) {
                console.error("THREE.WebGLRenderer: " + t)
            }
            var _t = new ae(yt);
            _t.get("WEBGL_depth_texture"), _t.get("OES_texture_float"), _t.get("OES_texture_float_linear"), _t.get("OES_texture_half_float"), _t.get("OES_texture_half_float_linear"), _t.get("OES_standard_derivatives"), _t.get("ANGLE_instanced_arrays"), _t.get("OES_element_index_uint") && (Tt.MaxIndex = 4294967296);
            var xt = new oe(yt, _t, t),
                bt = new re(yt, _t, x),
                wt = new ne,
                Mt = new ie(yt, _t, bt, wt, xt, x, gt),
                At = new kt(yt),
                Pt = new Ft(yt, At, gt),
                Ot = new Ht(yt, Pt, vt),
                Dt = new ee(this, xt),
                It = new zt,
                jt = new Nt;
            this.info.programs = Dt.programs;
            var Gt, Vt, Wt, Xt, qt = new Ut(yt, _t, vt),
                $t = new Bt(yt, _t, vt);
            e(), this.context = yt, this.capabilities = xt, this.extensions = _t, this.properties = wt, this.state = bt;
            var Yt = new et(this, mt, Ot, xt);
            this.shadowMap = Yt;
            var Zt = new X(this, k),
                Qt = new W(this, O);
            this.getContext = function() {
                return yt
            }, this.getContextAttributes = function() {
                return yt.getContextAttributes()
            }, this.forceContextLoss = function() {
                var t = _t.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.getMaxAnisotropy = function() {
                return xt.getMaxAnisotropy()
            }, this.getPrecision = function() {
                return xt.precision
            }, this.getPixelRatio = function() {
                return it
            }, this.setPixelRatio = function(t) {
                void 0 !== t && (it = t, this.setSize(ot.z, ot.w, !1))
            }, this.getSize = function() {
                return {
                    width: J,
                    height: K
                }
            }, this.setSize = function(t, e, i) {
                J = t, K = e, b.width = t * it, b.height = e * it, !1 !== i && (b.style.width = t + "px", b.style.height = e + "px"), this.setViewport(0, 0, t, e)
            }, this.setViewport = function(t, e, i, n) {
                bt.viewport(ot.set(t, e, i, n))
            }, this.setScissor = function(t, e, i, n) {
                bt.scissor(nt.set(t, e, i, n))
            }, this.setScissorTest = function(t) {
                bt.setScissorTest(rt = t)
            }, this.getClearColor = function() {
                return Z
            }, this.setClearColor = function(t, e) {
                Z.set(t), Q = void 0 !== e ? e : 1, bt.buffers.color.setClear(Z.r, Z.g, Z.b, Q, A)
            }, this.getClearAlpha = function() {
                return Q
            }, this.setClearAlpha = function(t) {
                Q = t, bt.buffers.color.setClear(Z.r, Z.g, Z.b, Q, A)
            }, this.clear = function(t, e, i) {
                var n = 0;
                (void 0 === t || t) && (n |= yt.COLOR_BUFFER_BIT), (void 0 === e || e) && (n |= yt.DEPTH_BUFFER_BIT), (void 0 === i || i) && (n |= yt.STENCIL_BUFFER_BIT), yt.clear(n)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.clearTarget = function(t, e, i, n) {
                this.setRenderTarget(t), this.clear(e, i, n)
            }, this.resetGLState = i, this.dispose = function() {
                b.removeEventListener("webglcontextlost", n, !1), jt.dispose()
            }, this.renderBufferImmediate = function(t, e, i) {
                bt.initAttributes();
                var n = wt.get(t);
                if (t.hasPositions && !n.position && (n.position = yt.createBuffer()), t.hasNormals && !n.normal && (n.normal = yt.createBuffer()), t.hasUvs && !n.uv && (n.uv = yt.createBuffer()), t.hasColors && !n.color && (n.color = yt.createBuffer()), e = e.getAttributes(), t.hasPositions && (yt.bindBuffer(yt.ARRAY_BUFFER, n.position), yt.bufferData(yt.ARRAY_BUFFER, t.positionArray, yt.DYNAMIC_DRAW), bt.enableAttribute(e.position), yt.vertexAttribPointer(e.position, 3, yt.FLOAT, !1, 0, 0)), t.hasNormals) {
                    if (yt.bindBuffer(yt.ARRAY_BUFFER, n.normal), !i.isMeshPhongMaterial && !i.isMeshStandardMaterial && !i.isMeshNormalMaterial && 1 === i.shading)
                        for (var r = 0, o = 3 * t.count; r < o; r += 9) {
                            var a = t.normalArray,
                                s = (a[r + 0] + a[r + 3] + a[r + 6]) / 3,
                                l = (a[r + 1] + a[r + 4] + a[r + 7]) / 3,
                                c = (a[r + 2] + a[r + 5] + a[r + 8]) / 3;
                            a[r + 0] = s, a[r + 1] = l, a[r + 2] = c, a[r + 3] = s, a[r + 4] = l, a[r + 5] = c, a[r + 6] = s, a[r + 7] = l, a[r + 8] = c
                        }
                    yt.bufferData(yt.ARRAY_BUFFER, t.normalArray, yt.DYNAMIC_DRAW), bt.enableAttribute(e.normal), yt.vertexAttribPointer(e.normal, 3, yt.FLOAT, !1, 0, 0)
                }
                t.hasUvs && i.map && (yt.bindBuffer(yt.ARRAY_BUFFER, n.uv), yt.bufferData(yt.ARRAY_BUFFER, t.uvArray, yt.DYNAMIC_DRAW), bt.enableAttribute(e.uv), yt.vertexAttribPointer(At.uv, 2, yt.FLOAT, !1, 0, 0)), t.hasColors && 0 !== i.vertexColors && (yt.bindBuffer(yt.ARRAY_BUFFER, n.color), yt.bufferData(yt.ARRAY_BUFFER, t.colorArray, yt.DYNAMIC_DRAW), bt.enableAttribute(e.color), yt.vertexAttribPointer(e.color, 3, yt.FLOAT, !1, 0, 0)), bt.disableUnusedAttributes(), yt.drawArrays(yt.TRIANGLES, 0, t.count), t.count = 0
            }, this.renderBufferDirect = function(t, e, i, n, r, o) {
                bt.setMaterial(n);
                var a = g(t, e, n, r);
                t = i.id + "_" + a.id + "_" + (!0 === n.wireframe);
                var s = !1;
                if (t !== F && (F = t, s = !0), e = r.morphTargetInfluences, void 0 !== e) {
                    var l = [];
                    t = 0;
                    for (var c = e.length; t < c; t++) s = e[t], l.push([s, t]);
                    l.sort(u), 8 < l.length && (l.length = 8);
                    var h = i.morphAttributes;
                    for (t = 0, c = l.length; t < c; t++) s = l[t], L[t] = s[0], 0 !== s[0] ? (e = s[1], !0 === n.morphTargets && h.position && i.addAttribute("morphTarget" + t, h.position[e]), !0 === n.morphNormals && h.normal && i.addAttribute("morphNormal" + t, h.normal[e])) : (!0 === n.morphTargets && i.removeAttribute("morphTarget" + t), !0 === n.morphNormals && i.removeAttribute("morphNormal" + t));
                    for (t = l.length, e = L.length; t < e; t++) L[t] = 0;
                    a.getUniforms().setValue(yt, "morphTargetInfluences", L), s = !0
                }
                if (e = i.index, c = i.attributes.position, l = 1, !0 === n.wireframe && (e = Pt.getWireframeAttribute(i), l = 2), t = qt, null !== e && (t = $t, t.setIndex(e)), s) {
                    if (s = void 0, i && i.isInstancedBufferGeometry && null === _t.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    else {
                        void 0 === s && (s = 0), bt.initAttributes();
                        var d, h = i.attributes,
                            a = a.getAttributes(),
                            p = n.defaultAttributeValues;
                        for (d in a) {
                            var f = a[d];
                            if (0 <= f) {
                                var m = h[d];
                                if (void 0 !== m) {
                                    var v = m.normalized,
                                        y = m.itemSize,
                                        _ = At.get(m),
                                        x = _.buffer,
                                        b = _.type,
                                        _ = _.bytesPerElement;
                                    if (m.isInterleavedBufferAttribute) {
                                        var w = m.data,
                                            T = w.stride,
                                            m = m.offset;
                                        w && w.isInstancedInterleavedBuffer ? (bt.enableAttributeAndDivisor(f, w.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = w.meshPerAttribute * w.count)) : bt.enableAttribute(f), yt.bindBuffer(yt.ARRAY_BUFFER, x), yt.vertexAttribPointer(f, y, b, v, T * _, (s * T + m) * _)
                                    } else m.isInstancedBufferAttribute ? (bt.enableAttributeAndDivisor(f, m.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = m.meshPerAttribute * m.count)) : bt.enableAttribute(f), yt.bindBuffer(yt.ARRAY_BUFFER, x), yt.vertexAttribPointer(f, y, b, v, 0, s * y * _)
                                } else if (void 0 !== p && (v = p[d], void 0 !== v)) switch (v.length) {
                                    case 2:
                                        yt.vertexAttrib2fv(f, v);
                                        break;
                                    case 3:
                                        yt.vertexAttrib3fv(f, v);
                                        break;
                                    case 4:
                                        yt.vertexAttrib4fv(f, v);
                                        break;
                                    default:
                                        yt.vertexAttrib1fv(f, v)
                                }
                            }
                        }
                        bt.disableUnusedAttributes()
                    }
                    null !== e && yt.bindBuffer(yt.ELEMENT_ARRAY_BUFFER, At.get(e).buffer)
                }
                if (d = 0, null !== e ? d = e.count : void 0 !== c && (d = c.count), c = i.drawRange.start * l, s = null !== o ? o.start * l : 0, e = Math.max(c, s), o = Math.max(0, Math.min(d, c + i.drawRange.count * l, s + (null !== o ? o.count * l : 1 / 0)) - 1 - e + 1), 0 !== o) {
                    if (r.isMesh)
                        if (!0 === n.wireframe) bt.setLineWidth(n.wireframeLinewidth * (null === N ? it : 1)), t.setMode(yt.LINES);
                        else switch (r.drawMode) {
                            case 0:
                                t.setMode(yt.TRIANGLES);
                                break;
                            case 1:
                                t.setMode(yt.TRIANGLE_STRIP);
                                break;
                            case 2:
                                t.setMode(yt.TRIANGLE_FAN)
                        } else r.isLine ? (n = n.linewidth, void 0 === n && (n = 1), bt.setLineWidth(n * (null === N ? it : 1)), r.isLineSegments ? t.setMode(yt.LINES) : r.isLineLoop ? t.setMode(yt.LINE_LOOP) : t.setMode(yt.LINE_STRIP)) : r.isPoints && t.setMode(yt.POINTS);
                    i && i.isInstancedBufferGeometry ? 0 < i.maxInstancedCount && t.renderInstances(i, e, o) : t.render(e, o)
                }
            }, this.compile = function(t, e) {
                P = [], t.traverse(function(t) {
                    t.isLight && P.push(t)
                }), _(P, e), t.traverse(function(e) {
                    if (e.material)
                        if (Array.isArray(e.material))
                            for (var i = 0; i < e.material.length; i++) m(e.material[i], t.fog, e);
                        else m(e.material, t.fog, e)
                })
            }, this.render = function(t, e, i, n) {
                if (void 0 !== e && !0 !== e.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                else {
                    F = "", U = -1, z = null, !0 === t.autoUpdate && t.updateMatrixWorld(), e.onBeforeRender(D), null === e.parent && e.updateMatrixWorld(), e.matrixWorldInverse.getInverse(e.matrixWorld), ut.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), at.setFromMatrix(ut), P.length = 0, k.length = 0, O.length = 0, ht = this.localClippingEnabled, lt = st.init(this.clippingPlanes, ht, e), R = jt.get(t, e), R.init(), d(t, e, D.sortObjects), R.finish(), !0 === D.sortObjects && R.sort(), lt && st.beginShadows();
                    for (var r = P, o = 0, a = 0, s = r.length; a < s; a++) {
                        var l = r[a];
                        l.castShadow && (mt.shadows[o] = l, o++)
                    }
                    mt.shadows.length = o, Yt.render(t, e), _(P, e), lt && st.endShadows(), vt.frame++, vt.calls = 0, vt.vertices = 0, vt.faces = 0, vt.points = 0, void 0 === i && (i = null), this.setRenderTarget(i), r = t.background, null === r ? bt.buffers.color.setClear(Z.r, Z.g, Z.b, Q, A) : r && r.isColor && (bt.buffers.color.setClear(r.r, r.g, r.b, 1, A), n = !0), (this.autoClear || n) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), r && r.isCubeTexture ? (void 0 === Wt && (Wt = new Rt, Xt = new St(new Et(5, 5, 5), new $({
                        uniforms: Lr.cube.uniforms,
                        vertexShader: Lr.cube.vertexShader,
                        fragmentShader: Lr.cube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))), Wt.projectionMatrix.copy(e.projectionMatrix), Wt.matrixWorld.extractRotation(e.matrixWorld), Wt.matrixWorldInverse.getInverse(Wt.matrixWorld), Xt.material.uniforms.tCube.value = r, Xt.modelViewMatrix.multiplyMatrices(Wt.matrixWorldInverse, Xt.matrixWorld), Ot.update(Xt), D.renderBufferDirect(Wt, null, Xt.geometry, Xt.material, Xt, null)) : r && r.isTexture && (void 0 === Gt && (Gt = new Lt(-1, 1, 1, -1, 0, 1), Vt = new St(new Ct(2, 2), new ct({
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))), Vt.material.map = r, Ot.update(Vt), D.renderBufferDirect(Gt, null, Vt.geometry, Vt.material, Vt, null)), n = R.opaque, r = R.transparent, t.overrideMaterial ? (o = t.overrideMaterial, n.length && p(n, t, e, o), r.length && p(r, t, e, o)) : (n.length && p(n, t, e), r.length && p(r, t, e)), Zt.render(t, e), Qt.render(t, e, q), i && Mt.updateRenderTargetMipmap(i), bt.buffers.depth.setTest(!0), bt.buffers.depth.setMask(!0), bt.buffers.color.setMask(!0), e.isArrayCamera && e.enabled && D.setScissorTest(!1), e.onAfterRender(D)
                }
            }, this.setFaceCulling = function(t, e) {
                bt.setCullFace(t), bt.setFlipSided(0 === e)
            }, this.allocTextureUnit = function() {
                var t = Y;
                return t >= xt.maxTextures && console.warn("WebGLRenderer: trying to use " + t + " texture units while this GPU supports only " + xt.maxTextures), Y += 1, t
            }, this.setTexture2D = function() {
                var t = !1;
                return function(e, i) {
                    e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), Mt.setTexture2D(e, i)
                }
            }(), this.setTexture = function() {
                var t = !1;
                return function(e, i) {
                    t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), Mt.setTexture2D(e, i)
                }
            }(), this.setTextureCube = function() {
                var t = !1;
                return function(e, i) {
                    e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? Mt.setTextureCube(e, i) : Mt.setTextureCubeDynamic(e, i)
                }
            }(), this.getRenderTarget = function() {
                return N
            }, this.setRenderTarget = function(t) {
                (N = t) && void 0 === wt.get(t).__webglFramebuffer && Mt.setupRenderTarget(t);
                var e, i = t && t.isWebGLRenderTargetCube;
                t ? (e = wt.get(t), e = i ? e.__webglFramebuffer[t.activeCubeFace] : e.__webglFramebuffer, H.copy(t.scissor), V = t.scissorTest, q.copy(t.viewport)) : (e = null, H.copy(nt).multiplyScalar(it), V = rt, q.copy(ot).multiplyScalar(it)), B !== e && (yt.bindFramebuffer(yt.FRAMEBUFFER, e), B = e), bt.scissor(H), bt.setScissorTest(V), bt.viewport(q), i && (i = wt.get(t.texture), yt.framebufferTexture2D(yt.FRAMEBUFFER, yt.COLOR_ATTACHMENT0, yt.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, i.__webglTexture, t.activeMipMapLevel))
            }, this.readRenderTargetPixels = function(t, e, i, n, r, o) {
                if (!1 === (t && t.isWebGLRenderTarget)) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                else {
                    var a = wt.get(t).__webglFramebuffer;
                    if (a) {
                        var s = !1;
                        a !== B && (yt.bindFramebuffer(yt.FRAMEBUFFER, a), s = !0);
                        try {
                            var l = t.texture,
                                c = l.format,
                                h = l.type;
                            1023 !== c && x(c) !== yt.getParameter(yt.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h || x(h) === yt.getParameter(yt.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === h && (_t.get("OES_texture_float") || _t.get("WEBGL_color_buffer_float")) || 1016 === h && _t.get("EXT_color_buffer_half_float") ? yt.checkFramebufferStatus(yt.FRAMEBUFFER) === yt.FRAMEBUFFER_COMPLETE ? 0 <= e && e <= t.width - n && 0 <= i && i <= t.height - r && yt.readPixels(e, i, n, r, x(c), x(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                        } finally {
                            s && yt.bindFramebuffer(yt.FRAMEBUFFER, B)
                        }
                    }
                }
            }
        }

        function ce(t, e) {
            this.name = "", this.color = new G(t), this.density = void 0 !== e ? e : 25e-5
        }

        function he(t, e, i) {
            this.name = "", this.color = new G(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
        }

        function ue() {
            ot.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0
        }

        function de(t, e, i, n, r) {
            ot.call(this), this.lensFlares = [], this.positionScreen = new l, this.customUpdateCallback = void 0, void 0 !== t && this.add(t, e, i, n, r)
        }

        function pe(t) {
            q.call(this), this.type = "SpriteMaterial", this.color = new G(16777215), this.map = null, this.rotation = 0, this.lights = this.fog = !1, this.setValues(t)
        }

        function fe(t) {
            ot.call(this), this.type = "Sprite", this.material = void 0 !== t ? t : new pe
        }

        function me() {
            ot.call(this), this.type = "LOD", Object.defineProperties(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            })
        }

        function ge(t, e) {
            if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
            else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
            else {
                console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new c)
            }
        }

        function ve() {
            ot.call(this), this.type = "Bone"
        }

        function ye(t, e) {
            St.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new c, this.bindMatrixInverse = new c;
            var i = this.initBones(),
                i = new ge(i);
            this.bind(i, this.matrixWorld), this.normalizeSkinWeights()
        }

        function _e(t) {
            q.call(this), this.type = "LineBasicMaterial", this.color = new G(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(t)
        }

        function xe(t, e, i) {
            return 1 === i ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new be(t, e)) : (ot.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Tt, void(this.material = void 0 !== e ? e : new _e({
                color: 16777215 * Math.random()
            })))
        }

        function be(t, e) {
            xe.call(this, t, e), this.type = "LineSegments"
        }

        function we(t, e) {
            xe.call(this, t, e), this.type = "LineLoop"
        }

        function Te(t) {
            q.call(this), this.type = "PointsMaterial", this.color = new G(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(t)
        }

        function Se(t, e) {
            ot.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Tt, this.material = void 0 !== e ? e : new Te({
                color: 16777215 * Math.random()
            })
        }

        function Me() {
            ot.call(this), this.type = "Group"
        }

        function Ee(t, e, i, r, o, a, s, l, c) {
            function h() {
                requestAnimationFrame(h), t.readyState >= t.HAVE_CURRENT_DATA && (u.needsUpdate = !0)
            }
            n.call(this, t, e, i, r, o, a, s, l, c), this.generateMipmaps = !1;
            var u = this;
            h()
        }

        function Ae(t, e, i, r, o, a, s, l, c, h, u, d) {
            n.call(this, null, a, s, l, c, h, r, o, u, d), this.image = {
                width: e,
                height: i
            }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1
        }

        function Ce(t, e, i, r, o, a, s, l, c) {
            n.call(this, t, e, i, r, o, a, s, l, c), this.needsUpdate = !0
        }

        function Pe(t, e, i, r, o, a, s, l, c, h) {
            if (h = void 0 !== h ? h : 1026, 1026 !== h && 1027 !== h) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === i && 1026 === h && (i = 1012), void 0 === i && 1027 === h && (i = 1020), n.call(this, null, r, o, a, s, l, h, i, c), this.image = {
                width: t,
                height: e
            }, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== l ? l : 1003, this.generateMipmaps = this.flipY = !1
        }

        function Re(t) {
            Tt.call(this), this.type = "WireframeGeometry";
            var e, i, n, r, o, a, s = [],
                c = [0, 0],
                h = {},
                u = ["a", "b", "c"];
            if (t && t.isGeometry) {
                var d = t.faces;
                for (e = 0, n = d.length; e < n; e++) {
                    var p = d[e];
                    for (i = 0; 3 > i; i++) o = p[u[i]], a = p[u[(i + 1) % 3]], c[0] = Math.min(o, a), c[1] = Math.max(o, a), o = c[0] + "," + c[1],
                        void 0 === h[o] && (h[o] = {
                            index1: c[0],
                            index2: c[1]
                        })
                }
                for (o in h) e = h[o], u = t.vertices[e.index1], s.push(u.x, u.y, u.z), u = t.vertices[e.index2], s.push(u.x, u.y, u.z)
            } else if (t && t.isBufferGeometry) {
                var f, u = new l;
                if (null !== t.index) {
                    for (d = t.attributes.position, p = t.index, f = t.groups, 0 === f.length && (f = [{
                            start: 0,
                            count: p.count,
                            materialIndex: 0
                        }]), t = 0, r = f.length; t < r; ++t)
                        for (e = f[t], i = e.start, n = e.count, e = i, n = i + n; e < n; e += 3)
                            for (i = 0; 3 > i; i++) o = p.getX(e + i), a = p.getX(e + (i + 1) % 3), c[0] = Math.min(o, a), c[1] = Math.max(o, a), o = c[0] + "," + c[1], void 0 === h[o] && (h[o] = {
                                index1: c[0],
                                index2: c[1]
                            });
                    for (o in h) e = h[o], u.fromBufferAttribute(d, e.index1), s.push(u.x, u.y, u.z), u.fromBufferAttribute(d, e.index2), s.push(u.x, u.y, u.z)
                } else
                    for (d = t.attributes.position, e = 0, n = d.count / 3; e < n; e++)
                        for (i = 0; 3 > i; i++) h = 3 * e + i, u.fromBufferAttribute(d, h), s.push(u.x, u.y, u.z), h = 3 * e + (i + 1) % 3, u.fromBufferAttribute(d, h), s.push(u.x, u.y, u.z)
            }
            this.addAttribute("position", new yt(s, 3))
        }

        function Le(t, e, i) {
            wt.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            }, this.fromBufferGeometry(new ke(t, e, i)), this.mergeVertices()
        }

        function ke(t, e, i) {
            Tt.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: i
            };
            var n, r, o = [],
                a = [],
                s = [],
                c = [],
                h = new l,
                u = new l,
                d = new l,
                p = new l,
                f = new l,
                m = e + 1;
            for (n = 0; n <= i; n++) {
                var g = n / i;
                for (r = 0; r <= e; r++) {
                    var v = r / e,
                        u = t(v, g, u);
                    a.push(u.x, u.y, u.z), 0 <= v - 1e-5 ? (d = t(v - 1e-5, g, d), p.subVectors(u, d)) : (d = t(v + 1e-5, g, d), p.subVectors(d, u)), 0 <= g - 1e-5 ? (d = t(v, g - 1e-5, d), f.subVectors(u, d)) : (d = t(v, g + 1e-5, d), f.subVectors(d, u)), h.crossVectors(p, f).normalize(), s.push(h.x, h.y, h.z), c.push(v, g)
                }
            }
            for (n = 0; n < i; n++)
                for (r = 0; r < e; r++) t = n * m + r + 1, h = (n + 1) * m + r + 1, u = (n + 1) * m + r, o.push(n * m + r, t, u), o.push(t, h, u);
            this.setIndex(o), this.addAttribute("position", new yt(a, 3)), this.addAttribute("normal", new yt(s, 3)), this.addAttribute("uv", new yt(c, 2))
        }

        function Oe(t, e, i, n) {
            wt.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: i,
                detail: n
            }, this.fromBufferGeometry(new De(t, e, i, n)), this.mergeVertices()
        }

        function De(t, e, n, r) {
            function o(t) {
                c.push(t.x, t.y, t.z)
            }

            function a(e, i) {
                var n = 3 * e;
                i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
            }

            function s(t, e, i, n) {
                0 > n && 1 === t.x && (h[e] = t.x - 1), 0 === i.x && 0 === i.z && (h[e] = n / 2 / Math.PI + .5)
            }
            Tt.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: n,
                detail: r
            }, n = n || 1;
            var c = [],
                h = [];
            ! function(t) {
                for (var i = new l, n = new l, r = new l, s = 0; s < e.length; s += 3) {
                    a(e[s + 0], i), a(e[s + 1], n), a(e[s + 2], r);
                    var c, h, u = i,
                        d = n,
                        p = r,
                        f = Math.pow(2, t),
                        m = [];
                    for (c = 0; c <= f; c++) {
                        m[c] = [];
                        var g = u.clone().lerp(p, c / f),
                            v = d.clone().lerp(p, c / f),
                            y = f - c;
                        for (h = 0; h <= y; h++) m[c][h] = 0 === h && c === f ? g : g.clone().lerp(v, h / y)
                    }
                    for (c = 0; c < f; c++)
                        for (h = 0; h < 2 * (f - c) - 1; h++) u = Math.floor(h / 2), 0 === h % 2 ? (o(m[c][u + 1]), o(m[c + 1][u]), o(m[c][u])) : (o(m[c][u + 1]), o(m[c + 1][u + 1]), o(m[c + 1][u]))
                }
            }(r || 0),
            function(t) {
                for (var e = new l, i = 0; i < c.length; i += 3) e.x = c[i + 0], e.y = c[i + 1], e.z = c[i + 2], e.normalize().multiplyScalar(t), c[i + 0] = e.x, c[i + 1] = e.y, c[i + 2] = e.z
            }(n),
            function() {
                for (var t = new l, e = 0; e < c.length; e += 3) t.x = c[e + 0], t.y = c[e + 1], t.z = c[e + 2], h.push(Math.atan2(t.z, -t.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5));
                for (var t = new l, e = new l, n = new l, r = new l, o = new i, a = new i, u = new i, d = 0, p = 0; d < c.length; d += 9, p += 6) {
                    t.set(c[d + 0], c[d + 1], c[d + 2]), e.set(c[d + 3], c[d + 4], c[d + 5]), n.set(c[d + 6], c[d + 7], c[d + 8]), o.set(h[p + 0], h[p + 1]), a.set(h[p + 2], h[p + 3]), u.set(h[p + 4], h[p + 5]), r.copy(t).add(e).add(n).divideScalar(3);
                    var f = Math.atan2(r.z, -r.x);
                    s(o, p + 0, t, f), s(a, p + 2, e, f), s(u, p + 4, n, f)
                }
                for (t = 0; t < h.length; t += 6) e = h[t + 0], n = h[t + 2], r = h[t + 4], o = Math.min(e, n, r), .9 < Math.max(e, n, r) && .1 > o && (.2 > e && (h[t + 0] += 1), .2 > n && (h[t + 2] += 1), .2 > r && (h[t + 4] += 1))
            }(), this.addAttribute("position", new yt(c, 3)), this.addAttribute("normal", new yt(c.slice(), 3)), this.addAttribute("uv", new yt(h, 2)), this.normalizeNormals()
        }

        function Ie(t, e) {
            wt.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Ne(t, e)), this.mergeVertices()
        }

        function Ne(t, e) {
            De.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Be(t, e) {
            wt.call(this), this.type = "OctahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Ue(t, e)), this.mergeVertices()
        }

        function Ue(t, e) {
            De.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Fe(t, e) {
            wt.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new ze(t, e)), this.mergeVertices()
        }

        function ze(t, e) {
            var i = (1 + Math.sqrt(5)) / 2;
            De.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function He(t, e) {
            wt.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new je(t, e)), this.mergeVertices()
        }

        function je(t, e) {
            var i = (1 + Math.sqrt(5)) / 2,
                n = 1 / i;
            De.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Ge(t, e, i, n, r, o) {
            wt.call(this), this.type = "TubeGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: i,
                radialSegments: n,
                closed: r
            }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."), t = new Ve(t, e, i, n, r), this.tangents = t.tangents, this.normals = t.normals, this.binormals = t.binormals, this.fromBufferGeometry(t), this.mergeVertices()
        }

        function Ve(t, e, n, r, o) {
            function a(i) {
                var o = t.getPointAt(i / e),
                    a = s.normals[i];
                for (i = s.binormals[i], h = 0; h <= r; h++) {
                    var l = h / r * Math.PI * 2,
                        c = Math.sin(l),
                        l = -Math.cos(l);
                    d.x = l * a.x + c * i.x, d.y = l * a.y + c * i.y, d.z = l * a.z + c * i.z, d.normalize(), m.push(d.x, d.y, d.z), u.x = o.x + n * d.x, u.y = o.y + n * d.y, u.z = o.z + n * d.z, f.push(u.x, u.y, u.z)
                }
            }
            Tt.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: r,
                closed: o
            }, e = e || 64, n = n || 1, r = r || 8, o = o || !1;
            var s = t.computeFrenetFrames(e, o);
            this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
            var c, h, u = new l,
                d = new l,
                p = new i,
                f = [],
                m = [],
                g = [],
                v = [];
            for (c = 0; c < e; c++) a(c);
            for (a(!1 === o ? e : 0), c = 0; c <= e; c++)
                for (h = 0; h <= r; h++) p.x = c / e, p.y = h / r, g.push(p.x, p.y);
            ! function() {
                for (h = 1; h <= e; h++)
                    for (c = 1; c <= r; c++) {
                        var t = (r + 1) * h + (c - 1),
                            i = (r + 1) * h + c,
                            n = (r + 1) * (h - 1) + c;
                        v.push((r + 1) * (h - 1) + (c - 1), t, n), v.push(t, i, n)
                    }
            }(), this.setIndex(v), this.addAttribute("position", new yt(f, 3)), this.addAttribute("normal", new yt(m, 3)), this.addAttribute("uv", new yt(g, 2))
        }

        function We(t, e, i, n, r, o, a) {
            wt.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: n,
                p: r,
                q: o
            }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Xe(t, e, i, n, r, o)), this.mergeVertices()
        }

        function Xe(t, e, i, n, r, o) {
            function a(t, e, i, n, r) {
                var o = Math.sin(t);
                e = i / e * t, i = Math.cos(e), r.x = n * (2 + i) * .5 * Math.cos(t), r.y = n * (2 + i) * o * .5, r.z = n * Math.sin(e) * .5
            }
            Tt.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: n,
                p: r,
                q: o
            }, t = t || 100, e = e || 40, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, o = o || 3;
            var s, c, h = [],
                u = [],
                d = [],
                p = [],
                f = new l,
                m = new l,
                g = new l,
                v = new l,
                y = new l,
                _ = new l,
                x = new l;
            for (s = 0; s <= i; ++s)
                for (c = s / i * r * Math.PI * 2, a(c, r, o, t, g), a(c + .01, r, o, t, v), _.subVectors(v, g), x.addVectors(v, g), y.crossVectors(_, x), x.crossVectors(y, _), y.normalize(), x.normalize(), c = 0; c <= n; ++c) {
                    var b = c / n * Math.PI * 2,
                        w = -e * Math.cos(b),
                        b = e * Math.sin(b);
                    f.x = g.x + (w * x.x + b * y.x), f.y = g.y + (w * x.y + b * y.y), f.z = g.z + (w * x.z + b * y.z), u.push(f.x, f.y, f.z), m.subVectors(f, g).normalize(), d.push(m.x, m.y, m.z), p.push(s / i), p.push(c / n)
                }
            for (c = 1; c <= i; c++)
                for (s = 1; s <= n; s++) t = (n + 1) * c + (s - 1), e = (n + 1) * c + s, r = (n + 1) * (c - 1) + s, h.push((n + 1) * (c - 1) + (s - 1), t, r), h.push(t, e, r);
            this.setIndex(h), this.addAttribute("position", new yt(u, 3)), this.addAttribute("normal", new yt(d, 3)), this.addAttribute("uv", new yt(p, 2))
        }

        function qe(t, e, i, n, r) {
            wt.call(this), this.type = "TorusGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: n,
                arc: r
            }, this.fromBufferGeometry(new $e(t, e, i, n, r)), this.mergeVertices()
        }

        function $e(t, e, i, n, r) {
            Tt.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: i,
                tubularSegments: n,
                arc: r
            }, t = t || 100, e = e || 40, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
            var o, a, s = [],
                c = [],
                h = [],
                u = [],
                d = new l,
                p = new l,
                f = new l;
            for (o = 0; o <= i; o++)
                for (a = 0; a <= n; a++) {
                    var m = a / n * r,
                        g = o / i * Math.PI * 2;
                    p.x = (t + e * Math.cos(g)) * Math.cos(m), p.y = (t + e * Math.cos(g)) * Math.sin(m), p.z = e * Math.sin(g), c.push(p.x, p.y, p.z), d.x = t * Math.cos(m), d.y = t * Math.sin(m), f.subVectors(p, d).normalize(), h.push(f.x, f.y, f.z), u.push(a / n), u.push(o / i)
                }
            for (o = 1; o <= i; o++)
                for (a = 1; a <= n; a++) t = (n + 1) * (o - 1) + a - 1, e = (n + 1) * (o - 1) + a, r = (n + 1) * o + a, s.push((n + 1) * o + a - 1, t, r), s.push(t, e, r);
            this.setIndex(s), this.addAttribute("position", new yt(c, 3)), this.addAttribute("normal", new yt(h, 3)), this.addAttribute("uv", new yt(u, 2))
        }

        function Ye(t, e) {
            wt.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                shapes: t,
                options: e
            }, this.fromBufferGeometry(new Ze(t, e)), this.mergeVertices()
        }

        function Ze(t, e) {
            "undefined" != typeof t && (Tt.call(this), this.type = "ExtrudeBufferGeometry", t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), this.computeVertexNormals())
        }

        function Qe(t, e) {
            wt.call(this), this.type = "TextGeometry", this.parameters = {
                text: t,
                parameters: e
            }, this.fromBufferGeometry(new Je(t, e)), this.mergeVertices()
        }

        function Je(t, e) {
            e = e || {};
            var i = e.font;
            return !1 === (i && i.isFont) ? (console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new wt) : (i = i.generateShapes(t, e.size, e.curveSegments), e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Ze.call(this, i, e), void(this.type = "TextBufferGeometry"))
        }

        function Ke(t, e, i, n, r, o, a) {
            wt.call(this), this.type = "SphereGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: n,
                phiLength: r,
                thetaStart: o,
                thetaLength: a
            }, this.fromBufferGeometry(new ti(t, e, i, n, r, o, a)), this.mergeVertices()
        }

        function ti(t, e, i, n, r, o, a) {
            Tt.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: i,
                phiStart: n,
                phiLength: r,
                thetaStart: o,
                thetaLength: a
            }, t = t || 50, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
            var s, c, h = o + a,
                u = 0,
                d = [],
                p = new l,
                f = new l,
                m = [],
                g = [],
                v = [],
                y = [];
            for (c = 0; c <= i; c++) {
                var _ = [],
                    x = c / i;
                for (s = 0; s <= e; s++) {
                    var b = s / e;
                    p.x = -t * Math.cos(n + b * r) * Math.sin(o + x * a), p.y = t * Math.cos(o + x * a), p.z = t * Math.sin(n + b * r) * Math.sin(o + x * a), g.push(p.x, p.y, p.z), f.set(p.x, p.y, p.z).normalize(), v.push(f.x, f.y, f.z), y.push(b, 1 - x), _.push(u++)
                }
                d.push(_)
            }
            for (c = 0; c < i; c++)
                for (s = 0; s < e; s++) t = d[c][s + 1], n = d[c][s], r = d[c + 1][s], a = d[c + 1][s + 1], (0 !== c || 0 < o) && m.push(t, n, a), (c !== i - 1 || h < Math.PI) && m.push(n, r, a);
            this.setIndex(m), this.addAttribute("position", new yt(g, 3)), this.addAttribute("normal", new yt(v, 3)), this.addAttribute("uv", new yt(y, 2))
        }

        function ei(t, e, i, n, r, o) {
            wt.call(this), this.type = "RingGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: i,
                phiSegments: n,
                thetaStart: r,
                thetaLength: o
            }, this.fromBufferGeometry(new ii(t, e, i, n, r, o)), this.mergeVertices()
        }

        function ii(t, e, n, r, o, a) {
            Tt.call(this), this.type = "RingBufferGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: n,
                phiSegments: r,
                thetaStart: o,
                thetaLength: a
            }, t = t || 20, e = e || 50, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, r = void 0 !== r ? Math.max(1, r) : 1;
            var s, c, h = [],
                u = [],
                d = [],
                p = [],
                f = t,
                m = (e - t) / r,
                g = new l,
                v = new i;
            for (s = 0; s <= r; s++) {
                for (c = 0; c <= n; c++) t = o + c / n * a, g.x = f * Math.cos(t), g.y = f * Math.sin(t), u.push(g.x, g.y, g.z), d.push(0, 0, 1), v.x = (g.x / e + 1) / 2, v.y = (g.y / e + 1) / 2, p.push(v.x, v.y);
                f += m
            }
            for (s = 0; s < r; s++)
                for (e = s * (n + 1), c = 0; c < n; c++) t = c + e, o = t + n + 1, a = t + n + 2, f = t + 1, h.push(t, o, f), h.push(o, a, f);
            this.setIndex(h), this.addAttribute("position", new yt(u, 3)), this.addAttribute("normal", new yt(d, 3)), this.addAttribute("uv", new yt(p, 2))
        }

        function ni(t, e, i, n) {
            wt.call(this), this.type = "LatheGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: i,
                phiLength: n
            }, this.fromBufferGeometry(new ri(t, e, i, n)), this.mergeVertices()
        }

        function ri(t, e, n, r) {
            Tt.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: n,
                phiLength: r
            }, e = Math.floor(e) || 12, n = n || 0, r = r || 2 * Math.PI, r = yr.clamp(r, 0, 2 * Math.PI);
            var o, a, s = [],
                c = [],
                h = [],
                u = 1 / e,
                d = new l,
                p = new i;
            for (o = 0; o <= e; o++) {
                a = n + o * u * r;
                var f = Math.sin(a),
                    m = Math.cos(a);
                for (a = 0; a <= t.length - 1; a++) d.x = t[a].x * f, d.y = t[a].y, d.z = t[a].x * m, c.push(d.x, d.y, d.z), p.x = o / e, p.y = a / (t.length - 1), h.push(p.x, p.y)
            }
            for (o = 0; o < e; o++)
                for (a = 0; a < t.length - 1; a++) n = a + o * t.length, u = n + t.length, d = n + t.length + 1, p = n + 1, s.push(n, u, p), s.push(u, d, p);
            if (this.setIndex(s), this.addAttribute("position", new yt(c, 3)), this.addAttribute("uv", new yt(h, 2)), this.computeVertexNormals(), r === 2 * Math.PI)
                for (r = this.attributes.normal.array, s = new l, c = new l, h = new l, n = e * t.length * 3, a = o = 0; o < t.length; o++, a += 3) s.x = r[a + 0], s.y = r[a + 1], s.z = r[a + 2], c.x = r[n + a + 0], c.y = r[n + a + 1], c.z = r[n + a + 2], h.addVectors(s, c).normalize(), r[a + 0] = r[n + a + 0] = h.x, r[a + 1] = r[n + a + 1] = h.y, r[a + 2] = r[n + a + 2] = h.z
        }

        function oi(t, e) {
            wt.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                shapes: t,
                curveSegments: e
            }, this.fromBufferGeometry(new ai(t, e)), this.mergeVertices()
        }

        function ai(t, e) {
            function i(t) {
                var i, s, c = r.length / 3;
                t = t.extractPoints(e);
                var h = t.shape,
                    u = t.holes;
                if (!1 === Nr.isClockWise(h))
                    for (h = h.reverse(), t = 0, i = u.length; t < i; t++) s = u[t], !0 === Nr.isClockWise(s) && (u[t] = s.reverse());
                var d = Nr.triangulateShape(h, u);
                for (t = 0, i = u.length; t < i; t++) s = u[t], h = h.concat(s);
                for (t = 0, i = h.length; t < i; t++) s = h[t], r.push(s.x, s.y, 0), o.push(0, 0, 1), a.push(s.x, s.y);
                for (t = 0, i = d.length; t < i; t++) h = d[t], n.push(h[0] + c, h[1] + c, h[2] + c), l += 3
            }
            Tt.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                shapes: t,
                curveSegments: e
            }, e = e || 12;
            var n = [],
                r = [],
                o = [],
                a = [],
                s = 0,
                l = 0;
            if (!1 === Array.isArray(t)) i(t);
            else
                for (var c = 0; c < t.length; c++) i(t[c]), this.addGroup(s, l, c), s += l, l = 0;
            this.setIndex(n), this.addAttribute("position", new yt(r, 3)), this.addAttribute("normal", new yt(o, 3)), this.addAttribute("uv", new yt(a, 2))
        }

        function si(t, e) {
            Tt.call(this), this.type = "EdgesGeometry", this.parameters = {
                thresholdAngle: e
            };
            var i, n, r, o = [],
                a = Math.cos(yr.DEG2RAD * (void 0 !== e ? e : 1)),
                s = [0, 0],
                l = {},
                c = ["a", "b", "c"];
            t.isBufferGeometry ? (r = new wt, r.fromBufferGeometry(t)) : r = t.clone(), r.mergeVertices(), r.computeFaceNormals();
            var h = r.vertices;
            r = r.faces;
            for (var u = 0, d = r.length; u < d; u++)
                for (var p = r[u], f = 0; 3 > f; f++) i = p[c[f]], n = p[c[(f + 1) % 3]], s[0] = Math.min(i, n), s[1] = Math.max(i, n), i = s[0] + "," + s[1], void 0 === l[i] ? l[i] = {
                    index1: s[0],
                    index2: s[1],
                    face1: u,
                    face2: void 0
                } : l[i].face2 = u;
            for (i in l) s = l[i], (void 0 === s.face2 || r[s.face1].normal.dot(r[s.face2].normal) <= a) && (c = h[s.index1], o.push(c.x, c.y, c.z), c = h[s.index2], o.push(c.x, c.y, c.z));
            this.addAttribute("position", new yt(o, 3))
        }

        function li(t, e, i, n, r, o, a, s) {
            wt.call(this), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: i,
                radialSegments: n,
                heightSegments: r,
                openEnded: o,
                thetaStart: a,
                thetaLength: s
            }, this.fromBufferGeometry(new ci(t, e, i, n, r, o, a, s)), this.mergeVertices()
        }

        function ci(t, e, n, r, o, a, s, c) {
            function h(n) {
                var o, a, h, v = new i,
                    x = new l,
                    b = 0,
                    w = !0 === n ? t : e,
                    T = !0 === n ? 1 : -1;
                for (a = g, o = 1; o <= r; o++) p.push(0, y * T, 0), f.push(0, T, 0), m.push(.5, .5), g++;
                for (h = g, o = 0; o <= r; o++) {
                    var S = o / r * c + s,
                        M = Math.cos(S),
                        S = Math.sin(S);
                    x.x = w * S, x.y = y * T, x.z = w * M, p.push(x.x, x.y, x.z), f.push(0, T, 0), v.x = .5 * M + .5, v.y = .5 * S * T + .5, m.push(v.x, v.y), g++
                }
                for (o = 0; o < r; o++) v = a + o, x = h + o, !0 === n ? d.push(x, x + 1, v) : d.push(x + 1, x, v), b += 3;
                u.addGroup(_, b, !0 === n ? 1 : 2), _ += b
            }
            Tt.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: n,
                radialSegments: r,
                heightSegments: o,
                openEnded: a,
                thetaStart: s,
                thetaLength: c
            };
            var u = this;
            t = void 0 !== t ? t : 20, e = void 0 !== e ? e : 20, n = void 0 !== n ? n : 100, r = Math.floor(r) || 8, o = Math.floor(o) || 1, a = void 0 !== a && a, s = void 0 !== s ? s : 0, c = void 0 !== c ? c : 2 * Math.PI;
            var d = [],
                p = [],
                f = [],
                m = [],
                g = 0,
                v = [],
                y = n / 2,
                _ = 0;
            ! function() {
                var i, a, h = new l,
                    x = new l,
                    b = 0,
                    w = (e - t) / n;
                for (a = 0; a <= o; a++) {
                    var T = [],
                        S = a / o,
                        M = S * (e - t) + t;
                    for (i = 0; i <= r; i++) {
                        var E = i / r,
                            A = E * c + s,
                            C = Math.sin(A),
                            A = Math.cos(A);
                        x.x = M * C, x.y = -S * n + y, x.z = M * A, p.push(x.x, x.y, x.z), h.set(C, w, A).normalize(), f.push(h.x, h.y, h.z), m.push(E, 1 - S), T.push(g++)
                    }
                    v.push(T)
                }
                for (i = 0; i < r; i++)
                    for (a = 0; a < o; a++) h = v[a + 1][i], x = v[a + 1][i + 1], w = v[a][i + 1], d.push(v[a][i], h, w), d.push(h, x, w), b += 6;
                u.addGroup(_, b, 0), _ += b
            }(), !1 === a && (0 < t && h(!0), 0 < e && h(!1)), this.setIndex(d), this.addAttribute("position", new yt(p, 3)), this.addAttribute("normal", new yt(f, 3)), this.addAttribute("uv", new yt(m, 2))
        }

        function hi(t, e, i, n, r, o, a) {
            li.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: n,
                openEnded: r,
                thetaStart: o,
                thetaLength: a
            }
        }

        function ui(t, e, i, n, r, o, a) {
            ci.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: i,
                heightSegments: n,
                openEnded: r,
                thetaStart: o,
                thetaLength: a
            }
        }

        function di(t, e, i, n) {
            wt.call(this), this.type = "CircleGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: i,
                thetaLength: n
            }, this.fromBufferGeometry(new pi(t, e, i, n)), this.mergeVertices()
        }

        function pi(t, e, n, r) {
            Tt.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: n,
                thetaLength: r
            }, t = t || 50, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
            var o, a, s = [],
                c = [],
                h = [],
                u = [],
                d = new l,
                p = new i;
            for (c.push(0, 0, 0), h.push(0, 0, 1), u.push(.5, .5), a = 0, o = 3; a <= e; a++, o += 3) {
                var f = n + a / e * r;
                d.x = t * Math.cos(f), d.y = t * Math.sin(f), c.push(d.x, d.y, d.z), h.push(0, 0, 1), p.x = (c[o] / t + 1) / 2, p.y = (c[o + 1] / t + 1) / 2, u.push(p.x, p.y)
            }
            for (o = 1; o <= e; o++) s.push(o, o + 1, 0);
            this.setIndex(s), this.addAttribute("position", new yt(c, 3)), this.addAttribute("normal", new yt(h, 3)), this.addAttribute("uv", new yt(u, 2))
        }

        function fi(t) {
            $.call(this, {
                uniforms: Pr.merge([Cr.lights, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Rr.shadow_vert,
                fragmentShader: Rr.shadow_frag
            }), this.transparent = this.lights = !0, Object.defineProperties(this, {
                opacity: {
                    enumerable: !0,
                    get: function() {
                        return this.uniforms.opacity.value
                    },
                    set: function(t) {
                        this.uniforms.opacity.value = t
                    }
                }
            }), this.setValues(t)
        }

        function mi(t) {
            $.call(this, t), this.type = "RawShaderMaterial"
        }

        function gi(t) {
            q.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new G(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new G(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function vi(t) {
            gi.call(this), this.defines = {
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(t)
        }

        function yi(t) {
            q.call(this), this.type = "MeshPhongMaterial", this.color = new G(16777215), this.specular = new G(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new G(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function _i(t) {
            yi.call(this), this.defines = {
                TOON: ""
            }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
        }

        function xi(t) {
            q.call(this, t), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(t)
        }

        function bi(t) {
            q.call(this), this.type = "MeshLambertMaterial", this.color = new G(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new G(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
        }

        function wi(t) {
            q.call(this), this.type = "LineDashedMaterial", this.color = new G(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.lights = !1, this.setValues(t)
        }

        function Ti(t, e, i) {
            var n = this,
                r = !1,
                o = 0,
                a = 0;
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                a++, !1 === r && void 0 !== n.onStart && n.onStart(t, o, a), r = !0
            }, this.itemEnd = function(t) {
                o++, void 0 !== n.onProgress && n.onProgress(t, o, a), o === a && (r = !1, void 0 !== n.onLoad) && n.onLoad()
            }, this.itemError = function(t) {
                void 0 !== n.onError && n.onError(t)
            }
        }

        function Si(t) {
            this.manager = void 0 !== t ? t : zr
        }

        function Mi(t) {
            this.manager = void 0 !== t ? t : zr, this._parser = null
        }

        function Ei(t) {
            this.manager = void 0 !== t ? t : zr, this._parser = null
        }

        function Ai(t) {
            this.manager = void 0 !== t ? t : zr
        }

        function Ci(t) {
            this.manager = void 0 !== t ? t : zr
        }

        function Pi(t) {
            this.manager = void 0 !== t ? t : zr
        }

        function Ri(t, e) {
            ot.call(this), this.type = "Light", this.color = new G(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
        }

        function Li(t, e, i) {
            Ri.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(ot.DefaultUp), this.updateMatrix(), this.groundColor = new G(e)
        }

        function ki(t) {
            this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new c
        }

        function Oi() {
            ki.call(this, new Rt(50, 1, .5, 500))
        }

        function Di(t, e, i, n, r, o) {
            Ri.call(this, t, e), this.type = "SpotLight", this.position.copy(ot.DefaultUp), this.updateMatrix(), this.target = new ot, Object.defineProperty(this, "power", {
                get: function() {
                    return this.intensity * Math.PI
                },
                set: function(t) {
                    this.intensity = t / Math.PI
                }
            }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Oi
        }

        function Ii(t, e, i, n) {
            Ri.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function() {
                    return 4 * this.intensity * Math.PI
                },
                set: function(t) {
                    this.intensity = t / (4 * Math.PI)
                }
            }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new ki(new Rt(90, 1, .5, 500))
        }

        function Ni() {
            ki.call(this, new Lt(-5, 5, 5, -5, .5, 500))
        }

        function Bi(t, e) {
            Ri.call(this, t, e), this.type = "DirectionalLight", this.position.copy(ot.DefaultUp), this.updateMatrix(), this.target = new ot, this.shadow = new Ni
        }

        function Ui(t, e) {
            Ri.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
        }

        function Fi(t, e, i, n) {
            Ri.call(this, t, e), this.type = "RectAreaLight", this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
        }

        function zi(t, e, i, n) {
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
        }

        function Hi(t, e, i, n) {
            zi.call(this, t, e, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
        }

        function ji(t, e, i, n) {
            zi.call(this, t, e, i, n)
        }

        function Gi(t, e, i, n) {
            zi.call(this, t, e, i, n)
        }

        function Vi(t, e, i, n) {
            if (void 0 === t) throw Error("track name is undefined");
            if (void 0 === e || 0 === e.length) throw Error("no keyframes in track named " + t);
            this.name = t, this.times = Hr.convertArray(e, this.TimeBufferType), this.values = Hr.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation), this.validate(), this.optimize()
        }

        function Wi(t, e, i, n) {
            Vi.call(this, t, e, i, n)
        }

        function Xi(t, e, i, n) {
            zi.call(this, t, e, i, n)
        }

        function qi(t, e, i, n) {
            Vi.call(this, t, e, i, n)
        }

        function $i(t, e, i, n) {
            Vi.call(this, t, e, i, n)
        }

        function Yi(t, e, i, n) {
            Vi.call(this, t, e, i, n)
        }

        function Zi(t, e, i) {
            Vi.call(this, t, e, i)
        }

        function Qi(t, e, i, n) {
            Vi.call(this, t, e, i, n)
        }

        function Ji(t, e, i, n) {
            Vi.apply(this, arguments)
        }

        function Ki(t, e, i) {
            this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = yr.generateUUID(), 0 > this.duration && this.resetDuration(), this.optimize()
        }

        function tn(t) {
            this.manager = void 0 !== t ? t : zr, this.textures = {}
        }

        function en(t) {
            this.manager = void 0 !== t ? t : zr
        }

        function nn() {
            this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
        }

        function rn(t) {
            "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : zr, this.withCredentials = !1
        }

        function on(t) {
            this.manager = void 0 !== t ? t : zr, this.texturePath = ""
        }

        function an(t, e, i, n, r) {
            e = .5 * (n - e), r = .5 * (r - i);
            var o = t * t;
            return (2 * i - 2 * n + e + r) * t * o + (-3 * i + 3 * n - 2 * e - r) * o + e * t + i
        }

        function sn(t, e, i, n) {
            var r = 1 - t;
            return r * r * e + 2 * (1 - t) * t * i + t * t * n
        }

        function ln(t, e, i, n, r) {
            var o = 1 - t,
                a = 1 - t;
            return o * o * o * e + 3 * a * a * t * i + 3 * (1 - t) * t * t * n + t * t * t * r
        }

        function cn() {
            this.arcLengthDivisions = 200
        }

        function hn(t, e) {
            this.arcLengthDivisions = 200, this.v1 = t, this.v2 = e
        }

        function un() {
            this.arcLengthDivisions = 200, this.curves = [], this.autoClose = !1
        }

        function dn(t, e, i, n, r, o, a, s) {
            this.arcLengthDivisions = 200, this.aX = t, this.aY = e, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a, this.aRotation = s || 0
        }

        function pn(t) {
            this.arcLengthDivisions = 200, this.points = void 0 === t ? [] : t
        }

        function fn(t, e, i, n) {
            this.arcLengthDivisions = 200, this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
        }

        function mn(t, e, i) {
            this.arcLengthDivisions = 200, this.v0 = t, this.v1 = e, this.v2 = i
        }

        function gn(t) {
            un.call(this), this.currentPoint = new i, t && this.fromPoints(t)
        }

        function vn() {
            gn.apply(this, arguments), this.holes = []
        }

        function yn() {
            this.subPaths = [], this.currentPath = null
        }

        function _n(t) {
            this.data = t
        }

        function xn(t) {
            this.manager = void 0 !== t ? t : zr
        }

        function bn(t) {
            this.manager = void 0 !== t ? t : zr
        }

        function wn() {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Rt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Rt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
        }

        function Tn(t, e, i) {
            ot.call(this), this.type = "CubeCamera";
            var n = new Rt(90, 1, t, e);
            n.up.set(0, -1, 0), n.lookAt(new l(1, 0, 0)), this.add(n);
            var r = new Rt(90, 1, t, e);
            r.up.set(0, -1, 0), r.lookAt(new l(-1, 0, 0)), this.add(r);
            var o = new Rt(90, 1, t, e);
            o.up.set(0, 0, 1), o.lookAt(new l(0, 1, 0)), this.add(o);
            var s = new Rt(90, 1, t, e);
            s.up.set(0, 0, -1), s.lookAt(new l(0, -1, 0)), this.add(s);
            var c = new Rt(90, 1, t, e);
            c.up.set(0, -1, 0), c.lookAt(new l(0, 0, 1)), this.add(c);
            var h = new Rt(90, 1, t, e);
            h.up.set(0, -1, 0), h.lookAt(new l(0, 0, -1)), this.add(h), this.renderTarget = new a(i, i, {
                format: 1022,
                magFilter: 1006,
                minFilter: 1006
            }), this.renderTarget.texture.name = "CubeCamera", this.updateCubeMap = function(t, e) {
                null === this.parent && this.updateMatrixWorld();
                var i = this.renderTarget,
                    a = i.texture.generateMipmaps;
                i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, n, i), i.activeCubeFace = 1, t.render(e, r, i), i.activeCubeFace = 2, t.render(e, o, i), i.activeCubeFace = 3, t.render(e, s, i), i.activeCubeFace = 4, t.render(e, c, i), i.texture.generateMipmaps = a, i.activeCubeFace = 5, t.render(e, h, i), t.setRenderTarget(null)
            }
        }

        function Sn(t) {
            Rt.call(this), this.enabled = !1, this.cameras = t || []
        }

        function Mn() {
            ot.call(this), this.type = "AudioListener", this.context = Yr.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
        }

        function En(t) {
            ot.call(this), this.type = "Audio", this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
        }

        function An(t) {
            En.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
        }

        function Cn(t, e) {
            this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
        }

        function Pn(t, e, i) {
            switch (this.binding = t, this.valueSize = i, t = Float64Array, e) {
                case "quaternion":
                    e = this._slerp;
                    break;
                case "string":
                case "bool":
                    t = Array, e = this._select;
                    break;
                default:
                    e = this._lerp
            }
            this.buffer = new t(4 * i), this._mixBufferRegion = e, this.referenceCount = this.useCount = this.cumulativeWeight = 0
        }

        function Rn(t, e, i) {
            i = i || Ln.parseTrackName(e), this._targetGroup = t, this._bindings = t.subscribe_(e, i)
        }

        function Ln(t, e, i) {
            this.path = e, this.parsedPath = i || Ln.parseTrackName(e), this.node = Ln.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
        }

        function kn(t) {
            this.uuid = yr.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var e = {};
            this._indicesByUUID = e;
            for (var i = 0, n = arguments.length; i !== n; ++i) e[arguments[i].uuid] = i;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var r = this;
            this.stats = {
                objects: {
                    get total() {
                        return r._objects.length
                    },
                    get inUse() {
                        return this.total - r.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return r._bindings.length
                }
            }
        }

        function On(t, e, i) {
            this._mixer = t, this._clip = e, this._localRoot = i || null, t = e.tracks, e = t.length, i = Array(e);
            for (var n = {
                    endingStart: 2400,
                    endingEnd: 2400
                }, r = 0; r !== e; ++r) {
                var o = t[r].createInterpolant(null);
                i[r] = o, o.settings = n
            }
            this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(e), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
        }

        function Dn(t) {
            this._root = t, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
        }

        function In(t, e) {
            "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = e), this.value = t
        }

        function Nn() {
            Tt.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
        }

        function Bn(t, e, i, n) {
            this.uuid = yr.generateUUID(), this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
        }

        function Un(t, e) {
            this.uuid = yr.generateUUID(), this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.onUploadCallback = function() {}, this.version = 0
        }

        function Fn(t, e, i) {
            Un.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function zn(t, e, i) {
            ht.call(this, t, e), this.meshPerAttribute = i || 1
        }

        function Hn(t, e, i, n) {
            this.ray = new it(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function() {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }

        function jn(t, e) {
            return t.distance - e.distance
        }

        function Gn(t, e, i, n) {
            if (!1 !== t.visible && (t.raycast(e, i), !0 === n)) {
                t = t.children, n = 0;
                for (var r = t.length; n < r; n++) Gn(t[n], e, i, !0)
            }
        }

        function Vn(t) {
            this.autoStart = void 0 === t || t, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
        }

        function Wn(t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
        }

        function Xn(t, e, i) {
            return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
        }

        function qn(t, e) {
            St.call(this, t, e),
                this.animationsMap = {}, this.animationsList = [];
            var i = this.geometry.morphTargets.length;
            this.createAnimation("__default", 0, i - 1, i / 1), this.setAnimationWeight("__default", 1)
        }

        function $n(t) {
            ot.call(this), this.material = t, this.render = function(t) {}
        }

        function Yn(t, e, i, n) {
            this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = 3 * i.faces.length : i && i.isBufferGeometry && (e = i.attributes.normal.count), i = new Tt, e = new yt(6 * e, 3), i.addAttribute("position", e), be.call(this, i, new _e({
                color: t,
                linewidth: n
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function Zn(t) {
            ot.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, t = new Tt;
            for (var e = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, n = 1; 32 > i; i++, n++) {
                var r = i / 32 * Math.PI * 2,
                    o = n / 32 * Math.PI * 2;
                e.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1)
            }
            t.addAttribute("position", new yt(e, 3)), e = new _e({
                fog: !1
            }), this.cone = new be(t, e), this.add(this.cone), this.update()
        }

        function Qn(t) {
            this.bones = this.getBoneList(t);
            for (var e = new Tt, i = [], n = [], r = new G(0, 0, 1), o = new G(0, 1, 0), a = 0; a < this.bones.length; a++) {
                var s = this.bones[a];
                s.parent && s.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), n.push(r.r, r.g, r.b), n.push(o.r, o.g, o.b))
            }
            e.addAttribute("position", new yt(i, 3)), e.addAttribute("color", new yt(n, 3)), i = new _e({
                vertexColors: 2,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            }), be.call(this, e, i), this.root = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }

        function Jn(t, e) {
            this.light = t, this.light.updateMatrixWorld();
            var i = new ti(e, 4, 2),
                n = new ct({
                    wireframe: !0,
                    fog: !1
                });
            n.color.copy(this.light.color), St.call(this, i, n), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
        }

        function Kn(t) {
            ot.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, t = new _e({
                color: t.color
            });
            var e = new Tt;
            e.addAttribute("position", new ht(new Float32Array(15), 3)), this.add(new xe(e, t)), this.update()
        }

        function tr(t, e) {
            ot.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
            var i = new Ue(e);
            i.rotateY(.5 * Math.PI);
            var n = new ct({
                    vertexColors: 2,
                    wireframe: !0
                }),
                r = i.getAttribute("position"),
                r = new Float32Array(3 * r.count);
            i.addAttribute("color", new ht(r, 3)), this.add(new St(i, n)), this.update()
        }

        function er(t, e, i, n) {
            t = t || 10, e = e || 10, i = new G(void 0 !== i ? i : 4473924), n = new G(void 0 !== n ? n : 8947848);
            var r = e / 2,
                o = t / e,
                a = t / 2;
            t = [];
            for (var s = [], l = 0, c = 0, h = -a; l <= e; l++, h += o) {
                t.push(-a, 0, h, a, 0, h), t.push(h, 0, -a, h, 0, a);
                var u = l === r ? i : n;
                u.toArray(s, c), c += 3, u.toArray(s, c), c += 3, u.toArray(s, c), c += 3, u.toArray(s, c), c += 3
            }
            e = new Tt, e.addAttribute("position", new yt(t, 3)), e.addAttribute("color", new yt(s, 3)), i = new _e({
                vertexColors: 2
            }), be.call(this, e, i)
        }

        function ir(t, e, i, n, r, o) {
            t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new G(void 0 !== r ? r : 4473924), o = new G(void 0 !== o ? o : 8947848);
            var a, s, l, c, h, u = [],
                d = [];
            for (l = 0; l <= e; l++) s = l / e * 2 * Math.PI, a = Math.sin(s) * t, s = Math.cos(s) * t, u.push(0, 0, 0), u.push(a, 0, s), h = 1 & l ? r : o, d.push(h.r, h.g, h.b), d.push(h.r, h.g, h.b);
            for (l = 0; l <= i; l++)
                for (h = 1 & l ? r : o, c = t - t / i * l, e = 0; e < n; e++) s = e / n * 2 * Math.PI, a = Math.sin(s) * c, s = Math.cos(s) * c, u.push(a, 0, s), d.push(h.r, h.g, h.b), s = (e + 1) / n * 2 * Math.PI, a = Math.sin(s) * c, s = Math.cos(s) * c, u.push(a, 0, s), d.push(h.r, h.g, h.b);
            t = new Tt, t.addAttribute("position", new yt(u, 3)), t.addAttribute("color", new yt(d, 3)), u = new _e({
                vertexColors: 2
            }), be.call(this, t, u)
        }

        function nr(t, e, i, n) {
            this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), i = new Tt, e = new yt(6 * e, 3), i.addAttribute("position", e), be.call(this, i, new _e({
                color: t,
                linewidth: n
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function rr(t, e) {
            ot.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, void 0 === e && (e = 1);
            var i = new Tt;
            i.addAttribute("position", new yt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
            var n = new _e({
                fog: !1
            });
            this.add(new xe(i, n)), i = new Tt, i.addAttribute("position", new yt([0, 0, 0, 0, 0, 1], 3)), this.add(new xe(i, n)), this.update()
        }

        function or(t) {
            function e(t, e, n) {
                i(t, n), i(e, n)
            }

            function i(t, e) {
                o.push(0, 0, 0), a.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(o.length / 3 - 1)
            }
            var n = new Tt,
                r = new _e({
                    color: 16777215,
                    vertexColors: 1
                }),
                o = [],
                a = [],
                s = {},
                l = new G(16755200),
                c = new G(16711680),
                h = new G(43775),
                u = new G(16777215),
                d = new G(3355443);
            e("n1", "n2", l), e("n2", "n4", l), e("n4", "n3", l), e("n3", "n1", l), e("f1", "f2", l), e("f2", "f4", l), e("f4", "f3", l), e("f3", "f1", l), e("n1", "f1", l), e("n2", "f2", l), e("n3", "f3", l), e("n4", "f4", l), e("p", "n1", c), e("p", "n2", c), e("p", "n3", c), e("p", "n4", c), e("u1", "u2", h), e("u2", "u3", h), e("u3", "u1", h), e("c", "t", u), e("p", "c", d), e("cn1", "cn2", d), e("cn3", "cn4", d), e("cf1", "cf2", d), e("cf3", "cf4", d), n.addAttribute("position", new yt(o, 3)), n.addAttribute("color", new yt(a, 3)), be.call(this, n, r), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
        }

        function ar(t, e) {
            this.object = t, void 0 === e && (e = 16776960);
            var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                n = new Float32Array(24),
                r = new Tt;
            r.setIndex(new ht(i, 1)), r.addAttribute("position", new ht(n, 3)), be.call(this, r, new _e({
                color: e
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function sr(t, e, i, n, r, o) {
            ot.call(this), void 0 === n && (n = 16776960), void 0 === i && (i = 1), void 0 === r && (r = .2 * i), void 0 === o && (o = .2 * r), void 0 === Zr && (Zr = new Tt, Zr.addAttribute("position", new yt([0, 0, 0, 0, 1, 0], 3)), Qr = new ci(0, .5, 1, 5, 1), Qr.translate(0, -.5, 0)), this.position.copy(e), this.line = new xe(Zr, new _e({
                color: n
            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new St(Qr, new ct({
                color: n
            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, r, o)
        }

        function lr(t) {
            t = t || 1;
            var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t];
            t = new Tt, t.addAttribute("position", new yt(e, 3)), t.addAttribute("color", new yt([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), e = new _e({
                vertexColors: 2
            }), be.call(this, t, e)
        }

        function cr() {
            var t = 0,
                e = 0,
                i = 0,
                n = 0;
            return {
                initCatmullRom: function(r, o, a, s, l) {
                    r = l * (a - r), s = l * (s - o), t = o, e = r, i = -3 * o + 3 * a - 2 * r - s, n = 2 * o - 2 * a + r + s
                },
                initNonuniformCatmullRom: function(r, o, a, s, l, c, h) {
                    r = ((o - r) / l - (a - r) / (l + c) + (a - o) / c) * c, s = ((a - o) / c - (s - o) / (c + h) + (s - a) / h) * c, t = o, e = r, i = -3 * o + 3 * a - 2 * r - s, n = 2 * o - 2 * a + r + s
                },
                calc: function(r) {
                    var o = r * r;
                    return t + e * r + i * o + n * o * r
                }
            }
        }

        function hr(t) {
            this.arcLengthDivisions = 200, this.points = t || [], this.closed = !1
        }

        function ur(t, e, i, n) {
            this.arcLengthDivisions = 200, this.v0 = t, this.v1 = e, this.v2 = i, this.v3 = n
        }

        function dr(t, e, i) {
            this.arcLengthDivisions = 200, this.v0 = t, this.v1 = e, this.v2 = i
        }

        function pr(t, e) {
            this.arcLengthDivisions = 200, this.v1 = t, this.v2 = e
        }

        function fr(t, e, i, n, r, o) {
            dn.call(this, t, e, i, i, n, r, o)
        }

        function mr(t) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), hr.call(this, t), this.type = "catmullrom", this.closed = !0
        }

        function gr(t) {
            console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), hr.call(this, t), this.type = "catmullrom"
        }

        function vr(t) {
            console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), hr.call(this, t), this.type = "catmullrom"
        }
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
            return "number" == typeof t && isFinite(t) && Math.floor(t) === t
        }), void 0 === Math.sign && (Math.sign = function(t) {
            return 0 > t ? -1 : 0 < t ? 1 : +t
        }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
            get: function() {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
            }
        }), void 0 === Object.assign && function() {
            Object.assign = function(t) {
                if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), i = 1; i < arguments.length; i++) {
                    var n = arguments[i];
                    if (void 0 !== n && null !== n)
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }
        }(), Object.assign(e.prototype, {
            addEventListener: function(t, e) {
                void 0 === this._listeners && (this._listeners = {});
                var i = this._listeners;
                void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
            },
            hasEventListener: function(t, e) {
                if (void 0 === this._listeners) return !1;
                var i = this._listeners;
                return void 0 !== i[t] && -1 !== i[t].indexOf(e)
            },
            removeEventListener: function(t, e) {
                if (void 0 !== this._listeners) {
                    var i = this._listeners[t];
                    if (void 0 !== i) {
                        var n = i.indexOf(e); - 1 !== n && i.splice(n, 1)
                    }
                }
            },
            dispatchEvent: function(t) {
                if (void 0 !== this._listeners) {
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        var i, n = [],
                            r = e.length;
                        for (i = 0; i < r; i++) n[i] = e[i];
                        for (i = 0; i < r; i++) n[i].call(this, t)
                    }
                }
            }
        });
        var yr = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                    i = Array(36),
                    n = 0;
                return function() {
                    for (var r = 0; 36 > r; r++) 8 === r || 13 === r || 18 === r || 23 === r ? i[r] = "-" : 14 === r ? i[r] = "4" : (2 >= n && (n = 33554432 + 16777216 * Math.random() | 0), t = 15 & n, n >>= 4, i[r] = e[19 === r ? 3 & t | 8 : t]);
                    return i.join("")
                }
            }(),
            clamp: function(t, e, i) {
                return Math.max(e, Math.min(i, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, i, n, r) {
                return n + (t - e) * (r - n) / (i - e)
            },
            lerp: function(t, e, i) {
                return (1 - i) * t + i * e
            },
            smoothstep: function(t, e, i) {
                return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e), t * t * (3 - 2 * t))
            },
            smootherstep: function(t, e, i) {
                return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e), t * t * t * (t * (6 * t - 15) + 10))
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            degToRad: function(t) {
                return t * yr.DEG2RAD
            },
            radToDeg: function(t) {
                return t * yr.RAD2DEG
            },
            isPowerOfTwo: function(t) {
                return 0 === (t & t - 1) && 0 !== t
            },
            nearestPowerOfTwo: function(t) {
                return Math.pow(2, Math.round(Math.log(t) / Math.LN2))
            },
            nextPowerOfTwo: function(t) {
                return t--, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, t++, t
            }
        };
        Object.defineProperties(i.prototype, {
            width: {
                get: function() {
                    return this.x
                },
                set: function(t) {
                    this.x = t
                }
            },
            height: {
                get: function() {
                    return this.y
                },
                set: function(t) {
                    this.y = t
                }
            }
        }), Object.assign(i.prototype, {
            isVector2: !0,
            set: function(t, e) {
                return this.x = t, this.y = e, this
            },
            setScalar: function(t) {
                return this.y = this.x = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            },
            multiply: function(t) {
                return this.x *= t.x, this.y *= t.y, this
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this
            },
            divide: function(t) {
                return this.x /= t.x, this.y /= t.y, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            },
            clampScalar: function() {
                var t = new i,
                    e = new i;
                return function(i, n) {
                    return t.set(i, i), e.set(n, n), this.clamp(t, e)
                }
            }(),
            clampLength: function(t, e) {
                var i = this.length();
                return this.multiplyScalar(Math.max(t, Math.min(e, i)) / i)
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            },
            roundToZero: function() {
                return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            lengthManhattan: function() {
                return Math.abs(this.x) + Math.abs(this.y)
            },
            normalize: function() {
                return this.divideScalar(this.length())
            },
            angle: function() {
                var t = Math.atan2(this.y, this.x);
                return 0 > t && (t += 2 * Math.PI), t
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x;
                return t = this.y - t.y, e * e + t * t
            },
            distanceToManhattan: function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            },
            setLength: function(t) {
                return this.multiplyScalar(t / this.length())
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
            },
            rotateAround: function(t, e) {
                var i = Math.cos(e),
                    n = Math.sin(e),
                    r = this.x - t.x,
                    o = this.y - t.y;
                return this.x = r * i - o * n + t.x, this.y = r * n + o * i + t.y, this
            }
        });
        var _r = 0;
        n.DEFAULT_IMAGE = void 0, n.DEFAULT_MAPPING = 300, Object.defineProperty(n.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(n.prototype, e.prototype, {
            constructor: n,
            isTexture: !0,
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
            },
            toJSON: function(t) {
                if (void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                var e = {
                    metadata: {
                        version: 4.5,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    wrap: [this.wrapS, this.wrapT],
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY
                };
                if (void 0 !== this.image) {
                    var i = this.image;
                    if (void 0 === i.uuid && (i.uuid = yr.generateUUID()), void 0 === t.images[i.uuid]) {
                        var n, r = t.images,
                            o = i.uuid,
                            a = i.uuid;
                        void 0 !== i.toDataURL ? n = i : (n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), n.width = i.width, n.height = i.height, n.getContext("2d").drawImage(i, 0, 0, i.width, i.height)), n = 2048 < n.width || 2048 < n.height ? n.toDataURL("image/jpeg", .6) : n.toDataURL("image/png"), r[o] = {
                            uuid: a,
                            url: n
                        }
                    }
                    e.image = i.uuid
                }
                return t.textures[this.uuid] = e
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function(t) {
                if (300 === this.mapping) {
                    if (t.multiply(this.repeat), t.add(this.offset), 0 > t.x || 1 < t.x) switch (this.wrapS) {
                        case 1e3:
                            t.x -= Math.floor(t.x);
                            break;
                        case 1001:
                            t.x = 0 > t.x ? 0 : 1;
                            break;
                        case 1002:
                            t.x = 1 === Math.abs(Math.floor(t.x) % 2) ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x)
                    }
                    if (0 > t.y || 1 < t.y) switch (this.wrapT) {
                        case 1e3:
                            t.y -= Math.floor(t.y);
                            break;
                        case 1001:
                            t.y = 0 > t.y ? 0 : 1;
                            break;
                        case 1002:
                            t.y = 1 === Math.abs(Math.floor(t.y) % 2) ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y)
                    }
                    this.flipY && (t.y = 1 - t.y)
                }
            }
        }), Object.assign(r.prototype, {
            isVector4: !0,
            set: function(t, e, i, n) {
                return this.x = t, this.y = e, this.z = i, this.w = n, this
            },
            setScalar: function(t) {
                return this.w = this.z = this.y = this.x = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setZ: function(t) {
                return this.z = t, this
            },
            setW: function(t) {
                return this.w = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
            },
            applyMatrix4: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = this.w;
                return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n + t[12] * r, this.y = t[1] * e + t[5] * i + t[9] * n + t[13] * r, this.z = t[2] * e + t[6] * i + t[10] * n + t[14] * r, this.w = t[3] * e + t[7] * i + t[11] * n + t[15] * r, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            setAxisAngleFromQuaternion: function(t) {
                this.w = 2 * Math.acos(t.w);
                var e = Math.sqrt(1 - t.w * t.w);
                return 1e-4 > e ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            },
            setAxisAngleFromRotationMatrix: function(t) {
                var e, i, n;
                t = t.elements;
                var r = t[0];
                n = t[4];
                var o = t[8],
                    a = t[1],
                    s = t[5],
                    l = t[9];
                i = t[2], e = t[6];
                var c = t[10];
                return .01 > Math.abs(n - a) && .01 > Math.abs(o - i) && .01 > Math.abs(l - e) ? .1 > Math.abs(n + a) && .1 > Math.abs(o + i) && .1 > Math.abs(l + e) && .1 > Math.abs(r + s + c - 3) ? (this.set(1, 0, 0, 0), this) : (t = Math.PI, r = (r + 1) / 2, s = (s + 1) / 2, c = (c + 1) / 2, n = (n + a) / 4, o = (o + i) / 4, l = (l + e) / 4, r > s && r > c ? .01 > r ? (e = 0, n = i = .707106781) : (e = Math.sqrt(r), i = n / e, n = o / e) : s > c ? .01 > s ? (e = .707106781, i = 0, n = .707106781) : (i = Math.sqrt(s), e = n / i, n = l / i) : .01 > c ? (i = e = .707106781, n = 0) : (n = Math.sqrt(c), e = o / n, i = l / n), this.set(e, i, n, t), this) : (t = Math.sqrt((e - l) * (e - l) + (o - i) * (o - i) + (a - n) * (a - n)), .001 > Math.abs(t) && (t = 1), this.x = (e - l) / t, this.y = (o - i) / t, this.z = (a - n) / t, this.w = Math.acos((r + s + c - 1) / 2), this)
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            },
            clampScalar: function() {
                var t = new r,
                    e = new r;
                return function(i, n) {
                    return t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e)
                }
            }(),
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            },
            roundToZero: function() {
                return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            lengthManhattan: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function() {
                return this.divideScalar(this.length())
            },
            setLength: function(t) {
                return this.multiplyScalar(t / this.length())
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
        }), Object.assign(o.prototype, e.prototype, {
            isWebGLRenderTarget: !0,
            setSize: function(t, e) {
                this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), a.prototype = Object.create(o.prototype), a.prototype.constructor = a, a.prototype.isWebGLRenderTargetCube = !0, Object.assign(s, {
            slerp: function(t, e, i, n) {
                return i.copy(t).slerp(e, n)
            },
            slerpFlat: function(t, e, i, n, r, o, a) {
                var s = i[n + 0],
                    l = i[n + 1],
                    c = i[n + 2];
                i = i[n + 3], n = r[o + 0];
                var h = r[o + 1],
                    u = r[o + 2];
                if (r = r[o + 3], i !== r || s !== n || l !== h || c !== u) {
                    o = 1 - a;
                    var d = s * n + l * h + c * u + i * r,
                        p = 0 <= d ? 1 : -1,
                        f = 1 - d * d;
                    f > Number.EPSILON && (f = Math.sqrt(f), d = Math.atan2(f, d * p), o = Math.sin(o * d) / f, a = Math.sin(a * d) / f), p *= a, s = s * o + n * p, l = l * o + h * p, c = c * o + u * p, i = i * o + r * p, o === 1 - a && (a = 1 / Math.sqrt(s * s + l * l + c * c + i * i), s *= a, l *= a, c *= a, i *= a)
                }
                t[e] = s, t[e + 1] = l, t[e + 2] = c, t[e + 3] = i
            }
        }), Object.defineProperties(s.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this.onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this.onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this.onChangeCallback()
                }
            },
            w: {
                get: function() {
                    return this._w
                },
                set: function(t) {
                    this._w = t, this.onChangeCallback()
                }
            }
        }), Object.assign(s.prototype, {
            set: function(t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            },
            copy: function(t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
            },
            setFromEuler: function(t, e) {
                if (!1 === (t && t.isEuler)) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var i = t._x,
                    n = t._y,
                    r = t._z,
                    o = t.order,
                    a = Math.cos,
                    s = Math.sin,
                    l = a(i / 2),
                    c = a(n / 2),
                    a = a(r / 2),
                    i = s(i / 2),
                    n = s(n / 2),
                    r = s(r / 2);
                return "XYZ" === o ? (this._x = i * c * a + l * n * r, this._y = l * n * a - i * c * r, this._z = l * c * r + i * n * a, this._w = l * c * a - i * n * r) : "YXZ" === o ? (this._x = i * c * a + l * n * r, this._y = l * n * a - i * c * r, this._z = l * c * r - i * n * a, this._w = l * c * a + i * n * r) : "ZXY" === o ? (this._x = i * c * a - l * n * r, this._y = l * n * a + i * c * r, this._z = l * c * r + i * n * a, this._w = l * c * a - i * n * r) : "ZYX" === o ? (this._x = i * c * a - l * n * r, this._y = l * n * a + i * c * r, this._z = l * c * r - i * n * a, this._w = l * c * a + i * n * r) : "YZX" === o ? (this._x = i * c * a + l * n * r, this._y = l * n * a + i * c * r, this._z = l * c * r - i * n * a, this._w = l * c * a - i * n * r) : "XZY" === o && (this._x = i * c * a - l * n * r, this._y = l * n * a - i * c * r, this._z = l * c * r + i * n * a, this._w = l * c * a + i * n * r), !1 !== e && this.onChangeCallback(), this
            },
            setFromAxisAngle: function(t, e) {
                var i = e / 2,
                    n = Math.sin(i);
                return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this.onChangeCallback(), this
            },
            setFromRotationMatrix: function(t) {
                var e = t.elements,
                    i = e[0];
                t = e[4];
                var n = e[8],
                    r = e[1],
                    o = e[5],
                    a = e[9],
                    s = e[2],
                    l = e[6],
                    e = e[10],
                    c = i + o + e;
                return 0 < c ? (i = .5 / Math.sqrt(c + 1), this._w = .25 / i, this._x = (l - a) * i, this._y = (n - s) * i, this._z = (r - t) * i) : i > o && i > e ? (i = 2 * Math.sqrt(1 + i - o - e), this._w = (l - a) / i, this._x = .25 * i, this._y = (t + r) / i, this._z = (n + s) / i) : o > e ? (i = 2 * Math.sqrt(1 + o - i - e), this._w = (n - s) / i, this._x = (t + r) / i, this._y = .25 * i, this._z = (a + l) / i) : (i = 2 * Math.sqrt(1 + e - i - o), this._w = (r - t) / i, this._x = (n + s) / i, this._y = (a + l) / i, this._z = .25 * i), this.onChangeCallback(), this
            },
            setFromUnitVectors: function() {
                var t, e = new l;
                return function(i, n) {
                    return void 0 === e && (e = new l), t = i.dot(n) + 1, 1e-6 > t ? (t = 0, Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, n), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize()
                }
            }(),
            inverse: function() {
                return this.conjugate().normalize()
            },
            conjugate: function() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
            },
            dot: function(t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            },
            lengthSq: function() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function() {
                var t = this.length();
                return 0 === t ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this.onChangeCallback(), this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            },
            premultiply: function(t) {
                return this.multiplyQuaternions(t, this)
            },
            multiplyQuaternions: function(t, e) {
                var i = t._x,
                    n = t._y,
                    r = t._z,
                    o = t._w,
                    a = e._x,
                    s = e._y,
                    l = e._z,
                    c = e._w;
                return this._x = i * c + o * a + n * l - r * s, this._y = n * c + o * s + r * a - i * l, this._z = r * c + o * l + i * s - n * a, this._w = o * c - i * a - n * s - r * l, this.onChangeCallback(), this
            },
            slerp: function(t, e) {
                if (0 === e) return this;
                if (1 === e) return this.copy(t);
                var i = this._x,
                    n = this._y,
                    r = this._z,
                    o = this._w,
                    a = o * t._w + i * t._x + n * t._y + r * t._z;
                if (0 > a ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), 1 <= a) return this._w = o, this._x = i, this._y = n, this._z = r, this;
                var s = Math.sqrt(1 - a * a);
                if (.001 > Math.abs(s)) return this._w = .5 * (o + this._w), this._x = .5 * (i + this._x), this._y = .5 * (n + this._y), this._z = .5 * (r + this._z), this;
                var l = Math.atan2(s, a),
                    a = Math.sin((1 - e) * l) / s,
                    s = Math.sin(e * l) / s;
                return this._w = o * a + this._w * s, this._x = i * a + this._x * s, this._y = n * a + this._y * s, this._z = r * a + this._z * s, this.onChangeCallback(), this
            },
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            },
            onChange: function(t) {
                return this.onChangeCallback = t, this
            },
            onChangeCallback: function() {}
        }), Object.assign(l.prototype, {
            isVector3: !0,
            set: function(t, e, i) {
                return this.x = t, this.y = e, this.z = i, this
            },
            setScalar: function(t) {
                return this.z = this.y = this.x = t, this
            },
            setX: function(t) {
                return this.x = t, this
            },
            setY: function(t) {
                return this.y = t, this
            },
            setZ: function(t) {
                return this.z = t, this
            },
            setComponent: function(t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function(t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw Error("index is out of range: " + t)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z)
            },
            copy: function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            },
            add: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            },
            addScalar: function(t) {
                return this.x += t, this.y += t, this.z += t, this
            },
            addVectors: function(t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            },
            addScaledVector: function(t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            },
            sub: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            },
            subScalar: function(t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            },
            subVectors: function(t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            },
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            },
            multiplyScalar: function(t) {
                return this.x *= t, this.y *= t, this.z *= t, this
            },
            multiplyVectors: function(t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            },
            applyEuler: function() {
                var t = new s;
                return function(e) {
                    return !1 === (e && e.isEuler) && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(t.setFromEuler(e))
                }
            }(),
            applyAxisAngle: function() {
                var t = new s;
                return function(e, i) {
                    return this.applyQuaternion(t.setFromAxisAngle(e, i))
                }
            }(),
            applyMatrix3: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z;
                return t = t.elements, this.x = t[0] * e + t[3] * i + t[6] * n, this.y = t[1] * e + t[4] * i + t[7] * n, this.z = t[2] * e + t[5] * i + t[8] * n, this
            },
            applyMatrix4: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z;
                return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n + t[12], this.y = t[1] * e + t[5] * i + t[9] * n + t[13], this.z = t[2] * e + t[6] * i + t[10] * n + t[14], this.divideScalar(t[3] * e + t[7] * i + t[11] * n + t[15])
            },
            applyQuaternion: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z,
                    r = t.x,
                    o = t.y,
                    a = t.z;
                t = t.w;
                var s = t * e + o * n - a * i,
                    l = t * i + a * e - r * n,
                    c = t * n + r * i - o * e,
                    e = -r * e - o * i - a * n;
                return this.x = s * t + e * -r + l * -a - c * -o, this.y = l * t + e * -o + c * -r - s * -a, this.z = c * t + e * -a + s * -o - l * -r, this
            },
            project: function() {
                var t = new c;
                return function(e) {
                    return t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyMatrix4(t)
                }
            }(),
            unproject: function() {
                var t = new c;
                return function(e) {
                    return t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyMatrix4(t)
                }
            }(),
            transformDirection: function(t) {
                var e = this.x,
                    i = this.y,
                    n = this.z;
                return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n, this.y = t[1] * e + t[5] * i + t[9] * n, this.z = t[2] * e + t[6] * i + t[10] * n, this.normalize()
            },
            divide: function(t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            },
            divideScalar: function(t) {
                return this.multiplyScalar(1 / t)
            },
            min: function(t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            },
            max: function(t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            },
            clamp: function(t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            },
            clampScalar: function() {
                var t = new l,
                    e = new l;
                return function(i, n) {
                    return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e)
                }
            }(),
            clampLength: function(t, e) {
                var i = this.length();
                return this.multiplyScalar(Math.max(t, Math.min(e, i)) / i)
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            },
            roundToZero: function() {
                return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            },
            dot: function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            },
            lengthManhattan: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            },
            normalize: function() {
                return this.divideScalar(this.length())
            },
            setLength: function(t) {
                return this.multiplyScalar(t / this.length())
            },
            lerp: function(t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            },
            lerpVectors: function(t, e, i) {
                return this.subVectors(e, t).multiplyScalar(i).add(t)
            },
            cross: function(t, e) {
                if (void 0 !== e) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e);
                var i = this.x,
                    n = this.y,
                    r = this.z;
                return this.x = n * t.z - r * t.y, this.y = r * t.x - i * t.z, this.z = i * t.y - n * t.x, this
            },
            crossVectors: function(t, e) {
                var i = t.x,
                    n = t.y,
                    r = t.z,
                    o = e.x,
                    a = e.y,
                    s = e.z;
                return this.x = n * s - r * a, this.y = r * o - i * s, this.z = i * a - n * o, this
            },
            projectOnVector: function(t) {
                var e = t.dot(this) / t.lengthSq();
                return this.copy(t).multiplyScalar(e)
            },
            projectOnPlane: function() {
                var t = new l;
                return function(e) {
                    return t.copy(this).projectOnVector(e), this.sub(t)
                }
            }(),
            reflect: function() {
                var t = new l;
                return function(e) {
                    return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                }
            }(),
            angleTo: function(t) {
                return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()), Math.acos(yr.clamp(t, -1, 1))
            },
            distanceTo: function(t) {
                return Math.sqrt(this.distanceToSquared(t))
            },
            distanceToSquared: function(t) {
                var e = this.x - t.x,
                    i = this.y - t.y;
                return t = this.z - t.z, e * e + i * i + t * t
            },
            distanceToManhattan: function(t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            },
            setFromSpherical: function(t) {
                var e = Math.sin(t.phi) * t.radius;
                return this.x = e * Math.sin(t.theta), this.y = Math.cos(t.phi) * t.radius, this.z = e * Math.cos(t.theta), this
            },
            setFromCylindrical: function(t) {
                return this.x = t.radius * Math.sin(t.theta), this.y = t.y, this.z = t.radius * Math.cos(t.theta), this
            },
            setFromMatrixPosition: function(t) {
                return this.setFromMatrixColumn(t, 3)
            },
            setFromMatrixScale: function(t) {
                var e = this.setFromMatrixColumn(t, 0).length(),
                    i = this.setFromMatrixColumn(t, 1).length();
                return t = this.setFromMatrixColumn(t, 2).length(), this.x = e, this.y = i, this.z = t, this
            },
            setFromMatrixColumn: function(t, e) {
                return this.fromArray(t.elements, 4 * e)
            },
            equals: function(t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            },
            fromBufferAttribute: function(t, e, i) {
                return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
        }), Object.assign(c.prototype, {
            isMatrix4: !0,
            set: function(t, e, i, n, r, o, a, s, l, c, h, u, d, p, f, m) {
                var g = this.elements;
                return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new c).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements;
                return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this
            },
            copyPosition: function(t) {
                var e = this.elements;
                return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this
            },
            extractBasis: function(t, e, i) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
            },
            makeBasis: function(t, e, i) {
                return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
            },
            extractRotation: function() {
                var t = new l;
                return function(e) {
                    var i = this.elements,
                        n = e.elements,
                        r = 1 / t.setFromMatrixColumn(e, 0).length(),
                        o = 1 / t.setFromMatrixColumn(e, 1).length();
                    return e = 1 / t.setFromMatrixColumn(e, 2).length(), i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[4] = n[4] * o, i[5] = n[5] * o, i[6] = n[6] * o, i[8] = n[8] * e, i[9] = n[9] * e, i[10] = n[10] * e, this
                }
            }(),
            makeRotationFromEuler: function(t) {
                !1 === (t && t.isEuler) && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var e = this.elements,
                    i = t.x,
                    n = t.y,
                    r = t.z,
                    o = Math.cos(i),
                    i = Math.sin(i),
                    a = Math.cos(n),
                    n = Math.sin(n),
                    s = Math.cos(r),
                    r = Math.sin(r);
                if ("XYZ" === t.order) {
                    t = o * s;
                    var l = o * r,
                        c = i * s,
                        h = i * r;
                    e[0] = a * s, e[4] = -a * r, e[8] = n, e[1] = l + c * n, e[5] = t - h * n, e[9] = -i * a, e[2] = h - t * n, e[6] = c + l * n, e[10] = o * a
                } else "YXZ" === t.order ? (t = a * s, l = a * r, c = n * s, h = n * r, e[0] = t + h * i, e[4] = c * i - l, e[8] = o * n, e[1] = o * r, e[5] = o * s, e[9] = -i, e[2] = l * i - c, e[6] = h + t * i, e[10] = o * a) : "ZXY" === t.order ? (t = a * s, l = a * r, c = n * s, h = n * r, e[0] = t - h * i, e[4] = -o * r, e[8] = c + l * i, e[1] = l + c * i, e[5] = o * s, e[9] = h - t * i, e[2] = -o * n, e[6] = i, e[10] = o * a) : "ZYX" === t.order ? (t = o * s, l = o * r, c = i * s, h = i * r, e[0] = a * s, e[4] = c * n - l, e[8] = t * n + h, e[1] = a * r, e[5] = h * n + t, e[9] = l * n - c, e[2] = -n, e[6] = i * a, e[10] = o * a) : "YZX" === t.order ? (t = o * a, l = o * n, c = i * a, h = i * n, e[0] = a * s, e[4] = h - t * r, e[8] = c * r + l, e[1] = r, e[5] = o * s, e[9] = -i * s, e[2] = -n * s, e[6] = l * r + c, e[10] = t - h * r) : "XZY" === t.order && (t = o * a, l = o * n, c = i * a, h = i * n, e[0] = a * s, e[4] = -r, e[8] = n * s, e[1] = t * r + h, e[5] = o * s, e[9] = l * r - c, e[2] = c * r - l, e[6] = i * s, e[10] = h * r + t);
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            makeRotationFromQuaternion: function(t) {
                var e = this.elements,
                    i = t._x,
                    n = t._y,
                    r = t._z,
                    o = t._w,
                    a = i + i,
                    s = n + n,
                    l = r + r;
                t = i * a;
                var c = i * s,
                    i = i * l,
                    h = n * s,
                    n = n * l,
                    r = r * l,
                    a = o * a,
                    s = o * s,
                    o = o * l;
                return e[0] = 1 - (h + r), e[4] = c - o, e[8] = i + s, e[1] = c + o, e[5] = 1 - (t + r), e[9] = n - a, e[2] = i - s, e[6] = n + a, e[10] = 1 - (t + h), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            lookAt: function() {
                var t = new l,
                    e = new l,
                    i = new l;
                return function(n, r, o) {
                    var a = this.elements;
                    return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), t.crossVectors(o, i), 0 === t.lengthSq() && (i.z += 1e-4, t.crossVectors(o, i)), t.normalize(), e.crossVectors(i, t), a[0] = t.x, a[4] = e.x, a[8] = i.x, a[1] = t.y, a[5] = e.y, a[9] = i.y, a[2] = t.z, a[6] = e.z, a[10] = i.z, this
                }
            }(),
            multiply: function(t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var i = t.elements,
                    n = e.elements,
                    r = this.elements,
                    o = i[0],
                    a = i[4],
                    s = i[8],
                    l = i[12],
                    c = i[1],
                    h = i[5],
                    u = i[9],
                    d = i[13],
                    p = i[2],
                    f = i[6],
                    m = i[10],
                    g = i[14],
                    v = i[3],
                    y = i[7],
                    _ = i[11],
                    i = i[15],
                    x = n[0],
                    b = n[4],
                    w = n[8],
                    T = n[12],
                    S = n[1],
                    M = n[5],
                    E = n[9],
                    A = n[13],
                    C = n[2],
                    P = n[6],
                    R = n[10],
                    L = n[14],
                    k = n[3],
                    O = n[7],
                    D = n[11],
                    n = n[15];
                return r[0] = o * x + a * S + s * C + l * k, r[4] = o * b + a * M + s * P + l * O, r[8] = o * w + a * E + s * R + l * D, r[12] = o * T + a * A + s * L + l * n, r[1] = c * x + h * S + u * C + d * k, r[5] = c * b + h * M + u * P + d * O, r[9] = c * w + h * E + u * R + d * D, r[13] = c * T + h * A + u * L + d * n, r[2] = p * x + f * S + m * C + g * k, r[6] = p * b + f * M + m * P + g * O, r[10] = p * w + f * E + m * R + g * D, r[14] = p * T + f * A + m * L + g * n, r[3] = v * x + y * S + _ * C + i * k, r[7] = v * b + y * M + _ * P + i * O, r[11] = v * w + y * E + _ * R + i * D, r[15] = v * T + y * A + _ * L + i * n, this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            },
            applyToBufferAttribute: function() {
                var t = new l;
                return function(e) {
                    for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
                    return e
                }
            }(),
            determinant: function() {
                var t = this.elements,
                    e = t[0],
                    i = t[4],
                    n = t[8],
                    r = t[12],
                    o = t[1],
                    a = t[5],
                    s = t[9],
                    l = t[13],
                    c = t[2],
                    h = t[6],
                    u = t[10],
                    d = t[14];
                return t[3] * (+r * s * h - n * l * h - r * a * u + i * l * u + n * a * d - i * s * d) + t[7] * (+e * s * d - e * l * u + r * o * u - n * o * d + n * l * c - r * s * c) + t[11] * (+e * l * h - e * a * d - r * o * h + i * o * d + r * a * c - i * l * c) + t[15] * (-n * a * c - e * s * h + e * a * u + n * o * h - i * o * u + i * s * c)
            },
            transpose: function() {
                var t, e = this.elements;
                return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            },
            setPosition: function(t) {
                var e = this.elements;
                return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
            },
            getInverse: function(t, e) {
                var i = this.elements,
                    n = t.elements,
                    r = n[0],
                    o = n[1],
                    a = n[2],
                    s = n[3],
                    l = n[4],
                    c = n[5],
                    h = n[6],
                    u = n[7],
                    d = n[8],
                    p = n[9],
                    f = n[10],
                    m = n[11],
                    g = n[12],
                    v = n[13],
                    y = n[14],
                    n = n[15],
                    _ = p * y * u - v * f * u + v * h * m - c * y * m - p * h * n + c * f * n,
                    x = g * f * u - d * y * u - g * h * m + l * y * m + d * h * n - l * f * n,
                    b = d * v * u - g * p * u + g * c * m - l * v * m - d * c * n + l * p * n,
                    w = g * p * h - d * v * h - g * c * f + l * v * f + d * c * y - l * p * y,
                    T = r * _ + o * x + a * b + s * w;
                if (0 === T) {
                    if (!0 === e) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
                    return console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity()
                }
                return T = 1 / T, i[0] = _ * T, i[1] = (v * f * s - p * y * s - v * a * m + o * y * m + p * a * n - o * f * n) * T, i[2] = (c * y * s - v * h * s + v * a * u - o * y * u - c * a * n + o * h * n) * T, i[3] = (p * h * s - c * f * s - p * a * u + o * f * u + c * a * m - o * h * m) * T, i[4] = x * T, i[5] = (d * y * s - g * f * s + g * a * m - r * y * m - d * a * n + r * f * n) * T, i[6] = (g * h * s - l * y * s - g * a * u + r * y * u + l * a * n - r * h * n) * T, i[7] = (l * f * s - d * h * s + d * a * u - r * f * u - l * a * m + r * h * m) * T, i[8] = b * T, i[9] = (g * p * s - d * v * s - g * o * m + r * v * m + d * o * n - r * p * n) * T, i[10] = (l * v * s - g * c * s + g * o * u - r * v * u - l * o * n + r * c * n) * T, i[11] = (d * c * s - l * p * s - d * o * u + r * p * u + l * o * m - r * c * m) * T, i[12] = w * T, i[13] = (d * v * a - g * p * a + g * o * f - r * v * f - d * o * y + r * p * y) * T, i[14] = (g * c * a - l * v * a - g * o * h + r * v * h + l * o * y - r * c * y) * T, i[15] = (l * p * a - d * c * a + d * o * h - r * p * h - l * o * f + r * c * f) * T, this
            },
            scale: function(t) {
                var e = this.elements,
                    i = t.x,
                    n = t.y;
                return t = t.z, e[0] *= i, e[4] *= n, e[8] *= t, e[1] *= i, e[5] *= n, e[9] *= t, e[2] *= i, e[6] *= n, e[10] *= t, e[3] *= i, e[7] *= n, e[11] *= t, this
            },
            getMaxScaleOnAxis: function() {
                var t = this.elements;
                return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10]))
            },
            makeTranslation: function(t, e, i) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
            },
            makeRotationX: function(t) {
                var e = Math.cos(t);
                return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this
            },
            makeRotationY: function(t) {
                var e = Math.cos(t);
                return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this
            },
            makeRotationZ: function(t) {
                var e = Math.cos(t);
                return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            makeRotationAxis: function(t, e) {
                var i = Math.cos(e),
                    n = Math.sin(e),
                    r = 1 - i,
                    o = t.x,
                    a = t.y,
                    s = t.z,
                    l = r * o,
                    c = r * a;
                return this.set(l * o + i, l * a - n * s, l * s + n * a, 0, l * a + n * s, c * a + i, c * s - n * o, 0, l * s - n * a, c * s + n * o, r * s * s + i, 0, 0, 0, 0, 1), this
            },
            makeScale: function(t, e, i) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
            },
            makeShear: function(t, e, i) {
                return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
            },
            compose: function(t, e, i) {
                return this.makeRotationFromQuaternion(e), this.scale(i), this.setPosition(t), this
            },
            decompose: function() {
                var t = new l,
                    e = new c;
                return function(i, n, r) {
                    var o = this.elements,
                        a = t.set(o[0], o[1], o[2]).length(),
                        s = t.set(o[4], o[5], o[6]).length(),
                        l = t.set(o[8], o[9], o[10]).length();
                    0 > this.determinant() && (a = -a), i.x = o[12], i.y = o[13], i.z = o[14], e.copy(this), i = 1 / a;
                    var o = 1 / s,
                        c = 1 / l;
                    return e.elements[0] *= i, e.elements[1] *= i, e.elements[2] *= i, e.elements[4] *= o, e.elements[5] *= o, e.elements[6] *= o, e.elements[8] *= c, e.elements[9] *= c, e.elements[10] *= c, n.setFromRotationMatrix(e), r.x = a, r.y = s, r.z = l, this
                }
            }(),
            makePerspective: function(t, e, i, n, r, o) {
                void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                var a = this.elements;
                return a[0] = 2 * r / (e - t), a[4] = 0, a[8] = (e + t) / (e - t), a[12] = 0, a[1] = 0, a[5] = 2 * r / (i - n), a[9] = (i + n) / (i - n), a[13] = 0, a[2] = 0, a[6] = 0, a[10] = -(o + r) / (o - r), a[14] = -2 * o * r / (o - r), a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
            },
            makeOrthographic: function(t, e, i, n, r, o) {
                var a = this.elements,
                    s = 1 / (e - t),
                    l = 1 / (i - n),
                    c = 1 / (o - r);
                return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -((e + t) * s), a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -((i + n) * l), a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -((o + r) * c), a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
            },
            equals: function(t) {
                var e = this.elements;
                t = t.elements;
                for (var i = 0; 16 > i; i++)
                    if (e[i] !== t[i]) return !1;
                return !0
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; 16 > i; i++) this.elements[i] = t[i + e];
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
            }
        }), h.prototype = Object.create(n.prototype), h.prototype.constructor = h, h.prototype.isDataTexture = !0, u.prototype = Object.create(n.prototype), u.prototype.constructor = u, u.prototype.isCubeTexture = !0, Object.defineProperty(u.prototype, "images", {
            get: function() {
                return this.image
            },
            set: function(t) {
                this.image = t
            }
        });
        var xr = new n,
            br = new u,
            wr = [],
            Tr = [],
            Sr = new Float32Array(16),
            Mr = new Float32Array(9);
        H.prototype.setValue = function(t, e) {
            for (var i = this.seq, n = 0, r = i.length; n !== r; ++n) {
                var o = i[n];
                o.setValue(t, e[o.id])
            }
        };
        var Er = /([\w\d_]+)(\])?(\[|\.)?/g;
        j.prototype.setValue = function(t, e, i) {
            e = this.map[e], void 0 !== e && e.setValue(t, i, this.renderer)
        }, j.prototype.setOptional = function(t, e, i) {
            e = e[i], void 0 !== e && this.setValue(t, i, e)
        }, j.upload = function(t, e, i, n) {
            for (var r = 0, o = e.length; r !== o; ++r) {
                var a = e[r],
                    s = i[a.id];
                !1 !== s.needsUpdate && a.setValue(t, s.value, n)
            }
        }, j.seqWithValue = function(t, e) {
            for (var i = [], n = 0, r = t.length; n !== r; ++n) {
                var o = t[n];
                o.id in e && i.push(o)
            }
            return i
        };
        var Ar = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
        Object.assign(G.prototype, {
            isColor: !0,
            r: 1,
            g: 1,
            b: 1,
            set: function(t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            },
            setScalar: function(t) {
                return this.b = this.g = this.r = t, this
            },
            setHex: function(t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            },
            setRGB: function(t, e, i) {
                return this.r = t, this.g = e, this.b = i, this
            },
            setHSL: function() {
                function t(t, e, i) {
                    return 0 > i && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : .5 > i ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
                }
                return function(e, i, n) {
                    return e = yr.euclideanModulo(e, 1), i = yr.clamp(i, 0, 1), n = yr.clamp(n, 0, 1), 0 === i ? this.r = this.g = this.b = n : (i = .5 >= n ? n * (1 + i) : n + i - n * i, n = 2 * n - i, this.r = t(n, i, e + 1 / 3), this.g = t(n, i, e), this.b = t(n, i, e - 1 / 3)), this
                }
            }(),
            setStyle: function(t) {
                function e(e) {
                    void 0 !== e && 1 > parseFloat(e) && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }
                var i;
                if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var n = i[2];
                    switch (i[1]) {
                        case "rgb":
                        case "rgba":
                            if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                            if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) {
                                var n = parseFloat(i[1]) / 360,
                                    r = parseInt(i[2], 10) / 100,
                                    o = parseInt(i[3], 10) / 100;
                                return e(i[5]), this.setHSL(n, r, o)
                            }
                    }
                } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                    if (i = i[1], n = i.length, 3 === n) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
                    if (6 === n) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this
                }
                return t && 0 < t.length && (i = Ar[t], void 0 !== i ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + t)), this
            },
            clone: function() {
                return new this.constructor(this.r, this.g, this.b)
            },
            copy: function(t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            },
            copyGammaToLinear: function(t, e) {
                return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            },
            copyLinearToGamma: function(t, e) {
                void 0 === e && (e = 2);
                var i = 0 < e ? 1 / e : 1;
                return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
            },
            convertGammaToLinear: function() {
                var t = this.r,
                    e = this.g,
                    i = this.b;
                return this.r = t * t, this.g = e * e, this.b = i * i, this
            },
            convertLinearToGamma: function() {
                return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
            },
            getHex: function() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            },
            getHexString: function() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            },
            getHSL: function(t) {
                t = t || {
                    h: 0,
                    s: 0,
                    l: 0
                };
                var e, i = this.r,
                    n = this.g,
                    r = this.b,
                    o = Math.max(i, n, r),
                    a = Math.min(i, n, r),
                    s = (a + o) / 2;
                if (a === o) a = e = 0;
                else {
                    var l = o - a,
                        a = .5 >= s ? l / (o + a) : l / (2 - o - a);
                    switch (o) {
                        case i:
                            e = (n - r) / l + (n < r ? 6 : 0);
                            break;
                        case n:
                            e = (r - i) / l + 2;
                            break;
                        case r:
                            e = (i - n) / l + 4
                    }
                    e /= 6
                }
                return t.h = e, t.s = a, t.l = s, t
            },
            getStyle: function() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            },
            offsetHSL: function(t, e, i) {
                var n = this.getHSL();
                return n.h += t, n.s += e, n.l += i, this.setHSL(n.h, n.s, n.l), this
            },
            add: function(t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            },
            addColors: function(t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            },
            addScalar: function(t) {
                return this.r += t, this.g += t, this.b += t, this
            },
            sub: function(t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            },
            multiply: function(t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            },
            multiplyScalar: function(t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            },
            lerp: function(t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            },
            equals: function(t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            },
            fromArray: function(t, e) {
                return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            },
            toJSON: function() {
                return this.getHex()
            }
        });
        var Cr = {
                common: {
                    diffuse: {
                        value: new G(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    offsetRepeat: {
                        value: new r(0, 0, 1, 1)
                    },
                    specularMap: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new i(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new G(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    }
                },
                points: {
                    diffuse: {
                        value: new G(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    offsetRepeat: {
                        value: new r(0, 0, 1, 1)
                    }
                }
            },
            Pr = {
                merge: function(t) {
                    for (var e = {}, i = 0; i < t.length; i++) {
                        var n, r = this.clone(t[i]);
                        for (n in r) e[n] = r[n]
                    }
                    return e
                },
                clone: function(t) {
                    var e, i = {};
                    for (e in t) {
                        i[e] = {};
                        for (var n in t[e]) {
                            var r = t[e][n];
                            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? i[e][n] = r.clone() : Array.isArray(r) ? i[e][n] = r.slice() : i[e][n] = r
                        }
                    }
                    return i
                }
            },
            Rr = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "\nvec3 transformed = vec3( position );\n",
                beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
                bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
                color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
                defaultnormal_vertex: "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
                encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
                envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
                fog_vertex: "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
                gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
                lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
                lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
                logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
                map_particle_fragment: "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
                map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
                normal_flip: "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n",
                normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
                project_vertex: "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
                dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
                dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
                tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
                uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n",
                uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
                cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
                distanceRGBA_frag: "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
                distanceRGBA_vert: "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n",
                equirect_frag: "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
                equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                shadow_frag: "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n",
                shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
            },
            Lr = {
                basic: {
                    uniforms: Pr.merge([Cr.common, Cr.aomap, Cr.lightmap, Cr.fog]),
                    vertexShader: Rr.meshbasic_vert,
                    fragmentShader: Rr.meshbasic_frag
                },
                lambert: {
                    uniforms: Pr.merge([Cr.common, Cr.aomap, Cr.lightmap, Cr.emissivemap, Cr.fog, Cr.lights, {
                        emissive: {
                            value: new G(0)
                        }
                    }]),
                    vertexShader: Rr.meshlambert_vert,
                    fragmentShader: Rr.meshlambert_frag
                },
                phong: {
                    uniforms: Pr.merge([Cr.common, Cr.aomap, Cr.lightmap, Cr.emissivemap, Cr.bumpmap, Cr.normalmap, Cr.displacementmap, Cr.gradientmap, Cr.fog, Cr.lights, {
                        emissive: {
                            value: new G(0)
                        },
                        specular: {
                            value: new G(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: Rr.meshphong_vert,
                    fragmentShader: Rr.meshphong_frag
                },
                standard: {
                    uniforms: Pr.merge([Cr.common, Cr.aomap, Cr.lightmap, Cr.emissivemap, Cr.bumpmap, Cr.normalmap, Cr.displacementmap, Cr.roughnessmap, Cr.metalnessmap, Cr.fog, Cr.lights, {
                        emissive: {
                            value: new G(0)
                        },
                        roughness: {
                            value: .5
                        },
                        metalness: {
                            value: .5
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Rr.meshphysical_vert,
                    fragmentShader: Rr.meshphysical_frag
                },
                points: {
                    uniforms: Pr.merge([Cr.points, Cr.fog]),
                    vertexShader: Rr.points_vert,
                    fragmentShader: Rr.points_frag
                },
                dashed: {
                    uniforms: Pr.merge([Cr.common, Cr.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: Rr.linedashed_vert,
                    fragmentShader: Rr.linedashed_frag
                },
                depth: {
                    uniforms: Pr.merge([Cr.common, Cr.displacementmap]),
                    vertexShader: Rr.depth_vert,
                    fragmentShader: Rr.depth_frag
                },
                normal: {
                    uniforms: Pr.merge([Cr.common, Cr.bumpmap, Cr.normalmap, Cr.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Rr.normal_vert,
                    fragmentShader: Rr.normal_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: Rr.cube_vert,
                    fragmentShader: Rr.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        }
                    },
                    vertexShader: Rr.equirect_vert,
                    fragmentShader: Rr.equirect_frag
                },
                distanceRGBA: {
                    uniforms: {
                        lightPos: {
                            value: new l
                        }
                    },
                    vertexShader: Rr.distanceRGBA_vert,
                    fragmentShader: Rr.distanceRGBA_frag
                }
            };
        Lr.physical = {
            uniforms: Pr.merge([Lr.standard.uniforms, {
                clearCoat: {
                    value: 0
                },
                clearCoatRoughness: {
                    value: 0
                }
            }]),
            vertexShader: Rr.meshphysical_vert,
            fragmentShader: Rr.meshphysical_frag
        }, Object.assign(V.prototype, {
            set: function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function() {
                var t = new i;
                return function(e, i) {
                    var n = t.copy(i).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -(1 / 0), this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            getCenter: function(t) {
                return t = t || new i, this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                return t = t || new i, this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function(t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            },
            getParameter: function(t, e) {
                return (e || new i).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            },
            clampPoint: function(t, e) {
                return (e || new i).copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var t = new i;
                return function(e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }(),
            intersect: function(t) {
                return this.min.max(t.min), this.max.min(t.max), this
            },
            union: function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            translate: function(t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        });
        var kr = 0;
        Object.assign(q.prototype, e.prototype, {
            isMaterial: !0,
            setValues: function(t) {
                if (void 0 !== t)
                    for (var e in t) {
                        var i = t[e];
                        if (void 0 === i) console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                        else {
                            var n = this[e];
                            void 0 === n ? console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = "overdraw" === e ? Number(i) : i
                        }
                    }
            },
            toJSON: function(t) {
                function e(t) {
                    var e, i = [];
                    for (e in t) {
                        var n = t[e];
                        delete n.metadata, i.push(n)
                    }
                    return i
                }
                var i = void 0 === t;
                i && (t = {
                    textures: {},
                    images: {}
                });
                var n = {
                    metadata: {
                        version: 4.5,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 2 !== this.shading && (n.shading = this.shading), 0 !== this.side && (n.side = this.side), 0 !== this.vertexColors && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), n.skinning = this.skinning, n.morphTargets = this.morphTargets, n.dithering = this.dithering, i && (i = e(t.textures), t = e(t.images), 0 < i.length && (n.textures = i), 0 < t.length && (n.images = t)), n
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.shading = t.shading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection, t = t.clippingPlanes;
                var e = null;
                if (null !== t)
                    for (var i = t.length, e = Array(i), n = 0; n !== i; ++n) e[n] = t[n].clone();
                return this.clippingPlanes = e, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), $.prototype = Object.create(q.prototype), $.prototype.constructor = $, $.prototype.isShaderMaterial = !0, $.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Pr.clone(t.uniforms), this.defines = t.defines, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
        }, $.prototype.toJSON = function(t) {
            return t = q.prototype.toJSON.call(this, t), t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
        }, Y.prototype = Object.create(q.prototype), Y.prototype.constructor = Y, Y.prototype.isMeshDepthMaterial = !0, Y.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }, Object.assign(Z.prototype, {
            isBox3: !0,
            set: function(t, e) {
                return this.min.copy(t), this.max.copy(e), this
            },
            setFromArray: function(t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -(1 / 0), o = -(1 / 0), a = -(1 / 0), s = 0, l = t.length; s < l; s += 3) {
                    var c = t[s],
                        h = t[s + 1],
                        u = t[s + 2];
                    c < e && (e = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > o && (o = h), u > a && (a = u)
                }
                return this.min.set(e, i, n), this.max.set(r, o, a), this
            },
            setFromBufferAttribute: function(t) {
                for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -(1 / 0), o = -(1 / 0), a = -(1 / 0), s = 0, l = t.count; s < l; s++) {
                    var c = t.getX(s),
                        h = t.getY(s),
                        u = t.getZ(s);
                    c < e && (e = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > o && (o = h), u > a && (a = u)
                }
                return this.min.set(e, i, n), this.max.set(r, o, a), this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function() {
                var t = new l;
                return function(e, i) {
                    var n = t.copy(i).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
            }(),
            setFromObject: function(t) {
                return this.makeEmpty(), this.expandByObject(t)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -(1 / 0), this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            getCenter: function(t) {
                return t = t || new l, this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                return t = t || new l, this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t), this.max.max(t), this
            },
            expandByVector: function(t) {
                return this.min.sub(t), this.max.add(t), this
            },
            expandByScalar: function(t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            },
            expandByObject: function() {
                var t = new l;
                return function(e) {
                    var i = this;
                    return e.updateMatrixWorld(!0), e.traverse(function(e) {
                        var n, r;
                        if (n = e.geometry, void 0 !== n)
                            if (n.isGeometry) {
                                var o = n.vertices;
                                for (n = 0, r = o.length; n < r; n++) t.copy(o[n]), t.applyMatrix4(e.matrixWorld), i.expandByPoint(t)
                            } else if (n.isBufferGeometry && (o = n.attributes.position, void 0 !== o))
                            for (n = 0, r = o.count; n < r; n++) t.fromBufferAttribute(o, n).applyMatrix4(e.matrixWorld), i.expandByPoint(t)
                    }), this
                }
            }(),
            containsPoint: function(t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            },
            getParameter: function(t, e) {
                return (e || new l).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function(t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            },
            intersectsSphere: function() {
                var t = new l;
                return function(e) {
                    return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
                }
            }(),
            intersectsPlane: function(t) {
                var e, i;
                return 0 < t.normal.x ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= t.constant && i >= t.constant
            },
            clampPoint: function(t, e) {
                return (e || new l).copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var t = new l;
                return function(e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            }(),
            getBoundingSphere: function() {
                var t = new l;
                return function(e) {
                    return e = e || new Q, this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
                }
            }(),
            intersect: function(t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            },
            union: function(t) {
                return this.min.min(t.min), this.max.max(t.max), this
            },
            applyMatrix4: function() {
                var t = [new l, new l, new l, new l, new l, new l, new l, new l];
                return function(e) {
                    return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
                }
            }(),
            translate: function(t) {
                return this.min.add(t), this.max.add(t), this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }), Object.assign(Q.prototype, {
            set: function(t, e) {
                return this.center.copy(t), this.radius = e, this
            },
            setFromPoints: function() {
                var t = new Z;
                return function(e, i) {
                    var n = this.center;
                    void 0 !== i ? n.copy(i) : t.setFromPoints(e).getCenter(n);
                    for (var r = 0, o = 0, a = e.length; o < a; o++) r = Math.max(r, n.distanceToSquared(e[o]));
                    return this.radius = Math.sqrt(r), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            },
            empty: function() {
                return 0 >= this.radius
            },
            containsPoint: function(t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            },
            distanceToPoint: function(t) {
                return t.distanceTo(this.center) - this.radius
            },
            intersectsSphere: function(t) {
                var e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            },
            intersectsBox: function(t) {
                return t.intersectsSphere(this)
            },
            intersectsPlane: function(t) {
                return Math.abs(this.center.dot(t.normal) - t.constant) <= this.radius
            },
            clampPoint: function(t, e) {
                var i = this.center.distanceToSquared(t),
                    n = e || new l;
                return n.copy(t), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n
            },
            getBoundingBox: function(t) {
                return t = t || new Z, t.set(this.center, this.center), t.expandByScalar(this.radius), t
            },
            applyMatrix4: function(t) {
                return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this
            },
            translate: function(t) {
                return this.center.add(t), this
            },
            equals: function(t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
        }), Object.assign(J.prototype, {
            isMatrix3: !0,
            set: function(t, e, i, n, r, o, a, s, l) {
                var c = this.elements;
                return c[0] = t, c[1] = n, c[2] = a, c[3] = e, c[4] = r, c[5] = s, c[6] = i, c[7] = o, c[8] = l, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new this.constructor).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements;
                return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this
            },
            setFromMatrix4: function(t) {
                return t = t.elements, this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
            },
            applyToBufferAttribute: function() {
                var t = new l;
                return function(e) {
                    for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
                    return e
                }
            }(),
            multiply: function(t) {
                return this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var i = t.elements,
                    n = e.elements,
                    r = this.elements,
                    o = i[0],
                    a = i[3],
                    s = i[6],
                    l = i[1],
                    c = i[4],
                    h = i[7],
                    u = i[2],
                    d = i[5],
                    i = i[8],
                    p = n[0],
                    f = n[3],
                    m = n[6],
                    g = n[1],
                    v = n[4],
                    y = n[7],
                    _ = n[2],
                    x = n[5],
                    n = n[8];
                return r[0] = o * p + a * g + s * _, r[3] = o * f + a * v + s * x, r[6] = o * m + a * y + s * n, r[1] = l * p + c * g + h * _, r[4] = l * f + c * v + h * x, r[7] = l * m + c * y + h * n, r[2] = u * p + d * g + i * _, r[5] = u * f + d * v + i * x, r[8] = u * m + d * y + i * n, this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            },
            determinant: function() {
                var t = this.elements,
                    e = t[0],
                    i = t[1],
                    n = t[2],
                    r = t[3],
                    o = t[4],
                    a = t[5],
                    s = t[6],
                    l = t[7],
                    t = t[8];
                return e * o * t - e * a * l - i * r * t + i * a * s + n * r * l - n * o * s
            },
            getInverse: function(t, e) {
                t && t.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
                var i = t.elements,
                    n = this.elements,
                    r = i[0],
                    o = i[1],
                    a = i[2],
                    s = i[3],
                    l = i[4],
                    c = i[5],
                    h = i[6],
                    u = i[7],
                    i = i[8],
                    d = i * l - c * u,
                    p = c * h - i * s,
                    f = u * s - l * h,
                    m = r * d + o * p + a * f;
                if (0 === m) {
                    if (!0 === e) throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
                    return console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity()
                }
                return m = 1 / m, n[0] = d * m, n[1] = (a * u - i * o) * m, n[2] = (c * o - a * l) * m, n[3] = p * m, n[4] = (i * r - a * h) * m, n[5] = (a * s - c * r) * m, n[6] = f * m, n[7] = (o * h - u * r) * m, n[8] = (l * r - o * s) * m, this
            },
            transpose: function() {
                var t, e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            },
            getNormalMatrix: function(t) {
                return this.setFromMatrix4(t).getInverse(this).transpose()
            },
            transposeIntoArray: function(t) {
                var e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            },
            equals: function(t) {
                var e = this.elements;
                t = t.elements;
                for (var i = 0; 9 > i; i++)
                    if (e[i] !== t[i]) return !1;
                return !0
            },
            fromArray: function(t, e) {
                void 0 === e && (e = 0);
                for (var i = 0; 9 > i; i++) this.elements[i] = t[i + e];
                return this
            },
            toArray: function(t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var i = this.elements;
                return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
            }
        }), Object.assign(K.prototype, {
            set: function(t, e) {
                return this.normal.copy(t), this.constant = e, this
            },
            setComponents: function(t, e, i, n) {
                return this.normal.set(t, e, i), this.constant = n, this
            },
            setFromNormalAndCoplanarPoint: function(t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            },
            setFromCoplanarPoints: function() {
                var t = new l,
                    e = new l;
                return function(i, n, r) {
                    return n = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            },
            normalize: function() {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            },
            negate: function() {
                return this.constant *= -1, this.normal.negate(), this
            },
            distanceToPoint: function(t) {
                return this.normal.dot(t) + this.constant
            },
            distanceToSphere: function(t) {
                return this.distanceToPoint(t.center) - t.radius
            },
            projectPoint: function(t, e) {
                return this.orthoPoint(t, e).sub(t).negate()
            },
            orthoPoint: function(t, e) {
                var i = this.distanceToPoint(t);
                return (e || new l).copy(this.normal).multiplyScalar(i)
            },
            intersectLine: function() {
                var t = new l;
                return function(e, i) {
                    var n = i || new l,
                        r = e.delta(t),
                        o = this.normal.dot(r);
                    return 0 !== o ? (o = -(e.start.dot(this.normal) + this.constant) / o, 0 > o || 1 < o ? void 0 : n.copy(r).multiplyScalar(o).add(e.start)) : 0 === this.distanceToPoint(e.start) ? n.copy(e.start) : void 0
                }
            }(),
            intersectsLine: function(t) {
                var e = this.distanceToPoint(t.start);
                return t = this.distanceToPoint(t.end), 0 > e && 0 < t || 0 > t && 0 < e
            },
            intersectsBox: function(t) {
                return t.intersectsPlane(this)
            },
            intersectsSphere: function(t) {
                return t.intersectsPlane(this)
            },
            coplanarPoint: function(t) {
                return (t || new l).copy(this.normal).multiplyScalar(-this.constant)
            },
            applyMatrix4: function() {
                var t = new l,
                    e = new J;
                return function(i, n) {
                    var r = this.coplanarPoint(t).applyMatrix4(i),
                        o = n || e.getNormalMatrix(i),
                        o = this.normal.applyMatrix3(o).normalize();
                    return this.constant = -r.dot(o), this
                }
            }(),
            translate: function(t) {
                return this.constant -= t.dot(this.normal), this
            },
            equals: function(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        }), Object.assign(tt.prototype, {
            set: function(t, e, i, n, r, o) {
                var a = this.planes;
                return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                for (var e = this.planes, i = 0; 6 > i; i++) e[i].copy(t.planes[i]);
                return this
            },
            setFromMatrix: function(t) {
                var e = this.planes,
                    i = t.elements;
                t = i[0];
                var n = i[1],
                    r = i[2],
                    o = i[3],
                    a = i[4],
                    s = i[5],
                    l = i[6],
                    c = i[7],
                    h = i[8],
                    u = i[9],
                    d = i[10],
                    p = i[11],
                    f = i[12],
                    m = i[13],
                    g = i[14],
                    i = i[15];
                return e[0].setComponents(o - t, c - a, p - h, i - f).normalize(), e[1].setComponents(o + t, c + a, p + h, i + f).normalize(), e[2].setComponents(o + n, c + s, p + u, i + m).normalize(), e[3].setComponents(o - n, c - s, p - u, i - m).normalize(), e[4].setComponents(o - r, c - l, p - d, i - g).normalize(), e[5].setComponents(o + r, c + l, p + d, i + g).normalize(), this
            },
            intersectsObject: function() {
                var t = new Q;
                return function(e) {
                    var i = e.geometry;
                    return null === i.boundingSphere && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                }
            }(),
            intersectsSprite: function() {
                var t = new Q;
                return function(e) {
                    return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                }
            }(),
            intersectsSphere: function(t) {
                var e = this.planes,
                    i = t.center;
                t = -t.radius;
                for (var n = 0; 6 > n; n++)
                    if (e[n].distanceToPoint(i) < t) return !1;
                return !0
            },
            intersectsBox: function() {
                var t = new l,
                    e = new l;
                return function(i) {
                    for (var n = this.planes, r = 0; 6 > r; r++) {
                        var o = n[r];
                        t.x = 0 < o.normal.x ? i.min.x : i.max.x, e.x = 0 < o.normal.x ? i.max.x : i.min.x, t.y = 0 < o.normal.y ? i.min.y : i.max.y, e.y = 0 < o.normal.y ? i.max.y : i.min.y, t.z = 0 < o.normal.z ? i.min.z : i.max.z, e.z = 0 < o.normal.z ? i.max.z : i.min.z;
                        var a = o.distanceToPoint(t),
                            o = o.distanceToPoint(e);
                        if (0 > a && 0 > o) return !1
                    }
                    return !0
                }
            }(),
            containsPoint: function(t) {
                for (var e = this.planes, i = 0; 6 > i; i++)
                    if (0 > e[i].distanceToPoint(t)) return !1;
                return !0
            }
        }), Object.assign(it.prototype, {
            set: function(t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            },
            at: function(t, e) {
                return (e || new l).copy(this.direction).multiplyScalar(t).add(this.origin)
            },
            lookAt: function(t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            },
            recast: function() {
                var t = new l;
                return function(e) {
                    return this.origin.copy(this.at(e, t)), this
                }
            }(),
            closestPointToPoint: function(t, e) {
                var i = e || new l;
                i.subVectors(t, this.origin);
                var n = i.dot(this.direction);
                return 0 > n ? i.copy(this.origin) : i.copy(this.direction).multiplyScalar(n).add(this.origin)
            },
            distanceToPoint: function(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            },
            distanceSqToPoint: function() {
                var t = new l;
                return function(e) {
                    var i = t.subVectors(e, this.origin).dot(this.direction);
                    return 0 > i ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e))
                }
            }(),
            distanceSqToSegment: function() {
                var t = new l,
                    e = new l,
                    i = new l;
                return function(n, r, o, a) {
                    t.copy(n).add(r).multiplyScalar(.5), e.copy(r).sub(n).normalize(), i.copy(this.origin).sub(t);
                    var s, l = .5 * n.distanceTo(r),
                        c = -this.direction.dot(e),
                        h = i.dot(this.direction),
                        u = -i.dot(e),
                        d = i.lengthSq(),
                        p = Math.abs(1 - c * c);
                    return 0 < p ? (n = c * u - h, r = c * h - u, s = l * p, 0 <= n ? r >= -s ? r <= s ? (l = 1 / p, n *= l, r *= l, c = n * (n + c * r + 2 * h) + r * (c * n + r + 2 * u) + d) : (r = l, n = Math.max(0, -(c * r + h)), c = -n * n + r * (r + 2 * u) + d) : (r = -l, n = Math.max(0, -(c * r + h)), c = -n * n + r * (r + 2 * u) + d) : r <= -s ? (n = Math.max(0, -(-c * l + h)), r = 0 < n ? -l : Math.min(Math.max(-l, -u), l), c = -n * n + r * (r + 2 * u) + d) : r <= s ? (n = 0, r = Math.min(Math.max(-l, -u), l), c = r * (r + 2 * u) + d) : (n = Math.max(0, -(c * l + h)), r = 0 < n ? l : Math.min(Math.max(-l, -u), l), c = -n * n + r * (r + 2 * u) + d)) : (r = 0 < c ? -l : l, n = Math.max(0, -(c * r + h)), c = -n * n + r * (r + 2 * u) + d), o && o.copy(this.direction).multiplyScalar(n).add(this.origin), a && a.copy(e).multiplyScalar(r).add(t), c
                }
            }(),
            intersectSphere: function() {
                var t = new l;
                return function(e, i) {
                    t.subVectors(e.center, this.origin);
                    var n = t.dot(this.direction),
                        r = t.dot(t) - n * n,
                        o = e.radius * e.radius;
                    return r > o ? null : (o = Math.sqrt(o - r), r = n - o, n += o, 0 > r && 0 > n ? null : 0 > r ? this.at(n, i) : this.at(r, i))
                }
            }(),
            intersectsSphere: function(t) {
                return this.distanceToPoint(t.center) <= t.radius
            },
            distanceToPlane: function(t) {
                var e = t.normal.dot(this.direction);
                return 0 === e ? 0 === t.distanceToPoint(this.origin) ? 0 : null : (t = -(this.origin.dot(t.normal) + t.constant) / e, 0 <= t ? t : null)
            },
            intersectPlane: function(t, e) {
                var i = this.distanceToPlane(t);
                return null === i ? null : this.at(i, e)
            },
            intersectsPlane: function(t) {
                var e = t.distanceToPoint(this.origin);
                return 0 === e || 0 > t.normal.dot(this.direction) * e
            },
            intersectBox: function(t, e) {
                var i, n, r, o, a;
                n = 1 / this.direction.x, o = 1 / this.direction.y, a = 1 / this.direction.z;
                var s = this.origin;
                return 0 <= n ? (i = (t.min.x - s.x) * n, n *= t.max.x - s.x) : (i = (t.max.x - s.x) * n, n *= t.min.x - s.x), 0 <= o ? (r = (t.min.y - s.y) * o, o *= t.max.y - s.y) : (r = (t.max.y - s.y) * o, o *= t.min.y - s.y), i > o || r > n ? null : ((r > i || i !== i) && (i = r), (o < n || n !== n) && (n = o), 0 <= a ? (r = (t.min.z - s.z) * a, a *= t.max.z - s.z) : (r = (t.max.z - s.z) * a, a *= t.min.z - s.z), i > a || r > n ? null : ((r > i || i !== i) && (i = r), (a < n || n !== n) && (n = a), 0 > n ? null : this.at(0 <= i ? i : n, e)))
            },
            intersectsBox: function() {
                var t = new l;
                return function(e) {
                    return null !== this.intersectBox(e, t)
                }
            }(),
            intersectTriangle: function() {
                var t = new l,
                    e = new l,
                    i = new l,
                    n = new l;
                return function(r, o, a, s, l) {
                    if (e.subVectors(o, r), i.subVectors(a, r), n.crossVectors(e, i), o = this.direction.dot(n), 0 < o) {
                        if (s) return null;
                        s = 1
                    } else {
                        if (!(0 > o)) return null;
                        s = -1, o = -o
                    }
                    return t.subVectors(this.origin, r), r = s * this.direction.dot(i.crossVectors(t, i)), 0 > r ? null : (a = s * this.direction.dot(e.cross(t)), 0 > a || r + a > o ? null : (r = -s * t.dot(n), 0 > r ? null : this.at(r / o, l)))
                }
            }(),
            applyMatrix4: function(t) {
                return this.direction.add(this.origin).applyMatrix4(t), this.origin.applyMatrix4(t), this.direction.sub(this.origin), this.direction.normalize(), this
            },
            equals: function(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        }), nt.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), nt.DefaultOrder = "XYZ", Object.defineProperties(nt.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t, this.onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t, this.onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t, this.onChangeCallback()
                }
            },
            order: {
                get: function() {
                    return this._order
                },
                set: function(t) {
                    this._order = t, this.onChangeCallback()
                }
            }
        }), Object.assign(nt.prototype, {
            isEuler: !0,
            set: function(t, e, i, n) {
                return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function(t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
            },
            setFromRotationMatrix: function(t, e, i) {
                var n = yr.clamp,
                    r = t.elements;
                t = r[0];
                var o = r[4],
                    a = r[8],
                    s = r[1],
                    l = r[5],
                    c = r[9],
                    h = r[2],
                    u = r[6],
                    r = r[10];
                return e = e || this._order, "XYZ" === e ? (this._y = Math.asin(n(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(-c, r), this._z = Math.atan2(-o, t)) : (this._x = Math.atan2(u, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(c, -1, 1)), .99999 > Math.abs(c) ? (this._y = Math.atan2(a, r), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-h, t), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(u, -1, 1)), .99999 > Math.abs(u) ? (this._y = Math.atan2(-h, r), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(s, t))) : "ZYX" === e ? (this._y = Math.asin(-n(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(u, r), this._z = Math.atan2(s, t)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === e ? (this._z = Math.asin(n(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, t)) : (this._x = 0, this._y = Math.atan2(a, r))) : "XZY" === e ? (this._z = Math.asin(-n(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, t)) : (this._x = Math.atan2(-c, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this
            },
            setFromQuaternion: function() {
                var t = new c;
                return function(e, i, n) {
                    return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n)
                }
            }(),
            setFromVector3: function(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            },
            reorder: function() {
                var t = new s;
                return function(e) {
                    return t.setFromEuler(this), this.setFromQuaternion(t, e)
                }
            }(),
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            },
            fromArray: function(t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
            },
            toArray: function(t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            },
            toVector3: function(t) {
                return t ? t.set(this._x, this._y, this._z) : new l(this._x, this._y, this._z)
            },
            onChange: function(t) {
                return this.onChangeCallback = t, this
            },
            onChangeCallback: function() {}
        }), Object.assign(rt.prototype, {
            set: function(t) {
                this.mask = 1 << t | 0
            },
            enable: function(t) {
                this.mask = this.mask | 1 << t | 0
            },
            toggle: function(t) {
                this.mask ^= 1 << t | 0
            },
            disable: function(t) {
                this.mask &= ~(1 << t | 0)
            },
            test: function(t) {
                return 0 !== (this.mask & t.mask)
            }
        });
        var Or = 0;
        ot.DefaultUp = new l(0, 1, 0), ot.DefaultMatrixAutoUpdate = !0, Object.assign(ot.prototype, e.prototype, {
            isObject3D: !0,
            applyMatrix: function(t) {
                this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            setRotationFromAxisAngle: function(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function(t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function(t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function(t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function() {
                var t = new s;
                return function(e, i) {
                    return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this
                }
            }(),
            rotateX: function() {
                var t = new l(1, 0, 0);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            rotateY: function() {
                var t = new l(0, 1, 0);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            rotateZ: function() {
                var t = new l(0, 0, 1);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            translateOnAxis: function() {
                var t = new l;
                return function(e, i) {
                    return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this
                }
            }(),
            translateX: function() {
                var t = new l(1, 0, 0);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            translateY: function() {
                var t = new l(0, 1, 0);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            translateZ: function() {
                var t = new l(0, 0, 1);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            localToWorld: function(t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function() {
                var t = new c;
                return function(e) {
                    return e.applyMatrix4(t.getInverse(this.matrixWorld))
                }
            }(),
            lookAt: function() {
                var t = new c;
                return function(e) {
                    this.isCamera ? t.lookAt(this.position, e, this.up) : t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t)
                }
            }(),
            add: function(t) {
                if (1 < arguments.length) {
                    for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                    type: "added"
                }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            },
            remove: function(t) {
                if (1 < arguments.length)
                    for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                e = this.children.indexOf(t), -1 !== e && (t.parent = null, t.dispatchEvent({
                    type: "removed"
                }), this.children.splice(e, 1))
            },
            getObjectById: function(t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function(t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function(t, e) {
                if (this[t] === e) return this;
                for (var i = 0, n = this.children.length; i < n; i++) {
                    var r = this.children[i].getObjectByProperty(t, e);
                    if (void 0 !== r) return r
                }
            },
            getWorldPosition: function(t) {
                return t = t || new l, this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function() {
                var t = new l,
                    e = new l;
                return function(i) {
                    return i = i || new s, this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i
                }
            }(),
            getWorldRotation: function() {
                var t = new s;
                return function(e) {
                    return e = e || new nt, this.getWorldQuaternion(t), e.setFromQuaternion(t, this.rotation.order, !1)
                }
            }(),
            getWorldScale: function() {
                var t = new l,
                    e = new s;
                return function(i) {
                    return i = i || new l, this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i
                }
            }(),
            getWorldDirection: function() {
                var t = new s;
                return function(e) {
                    return e = e || new l, this.getWorldQuaternion(t), e.set(0, 0, 1).applyQuaternion(t)
                }
            }(),
            raycast: function() {},
            traverse: function(t) {
                t(this);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
            },
            traverseVisible: function(t) {
                if (!1 !== this.visible) {
                    t(this);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                }
            },
            traverseAncestors: function(t) {
                var e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function(t) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
            },
            toJSON: function(t) {
                function e(e, i) {
                    return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                }

                function i(t) {
                    var e, i = [];
                    for (e in t) {
                        var n = t[e];
                        delete n.metadata, i.push(n)
                    }
                    return i
                }
                var n = void 0 === t || "" === t,
                    r = {};
                n && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {}
                }, r.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var o = {};
                if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), o.matrix = this.matrix.toArray(), void 0 !== this.geometry && (o.geometry = e(t.geometries, this.geometry)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        for (var a = [], s = 0, l = this.material.length; s < l; s++) a.push(e(t.materials, this.material[s]));
                        o.material = a
                    } else o.material = e(t.materials, this.material);
                if (0 < this.children.length)
                    for (o.children = [], s = 0; s < this.children.length; s++) o.children.push(this.children[s].toJSON(t).object);
                return n && (n = i(t.geometries), a = i(t.materials), s = i(t.textures), l = i(t.images), 0 < n.length && (r.geometries = n), 0 < a.length && (r.materials = a), 0 < s.length && (r.textures = s), 0 < l.length && (r.images = l)), r.object = o, r
            },
            clone: function(t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function(t, e) {
                if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                    for (var i = 0; i < t.children.length; i++) this.add(t.children[i].clone());
                return this
            }
        }), Object.assign(at.prototype, {
            set: function(t, e) {
                return this.start.copy(t), this.end.copy(e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.start.copy(t.start), this.end.copy(t.end), this
            },
            getCenter: function(t) {
                return (t || new l).addVectors(this.start, this.end).multiplyScalar(.5)
            },
            delta: function(t) {
                return (t || new l).subVectors(this.end, this.start)
            },
            distanceSq: function() {
                return this.start.distanceToSquared(this.end)
            },
            distance: function() {
                return this.start.distanceTo(this.end)
            },
            at: function(t, e) {
                var i = e || new l;
                return this.delta(i).multiplyScalar(t).add(this.start)
            },
            closestPointToPointParameter: function() {
                var t = new l,
                    e = new l;
                return function(i, n) {
                    t.subVectors(i, this.start), e.subVectors(this.end, this.start);
                    var r = e.dot(e),
                        r = e.dot(t) / r;
                    return n && (r = yr.clamp(r, 0, 1)), r
                }
            }(),
            closestPointToPoint: function(t, e, i) {
                return t = this.closestPointToPointParameter(t, e), i = i || new l, this.delta(i).multiplyScalar(t).add(this.start)
            },
            applyMatrix4: function(t) {
                return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
            },
            equals: function(t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
        }), Object.assign(st, {
            normal: function() {
                var t = new l;
                return function(e, i, n, r) {
                    return r = r || new l, r.subVectors(n, i), t.subVectors(e, i), r.cross(t), e = r.lengthSq(), 0 < e ? r.multiplyScalar(1 / Math.sqrt(e)) : r.set(0, 0, 0)
                }
            }(),
            barycoordFromPoint: function() {
                var t = new l,
                    e = new l,
                    i = new l;
                return function(n, r, o, a, s) {
                    t.subVectors(a, r), e.subVectors(o, r), i.subVectors(n, r), n = t.dot(t), r = t.dot(e), o = t.dot(i);
                    var c = e.dot(e);
                    a = e.dot(i);
                    var h = n * c - r * r;
                    return s = s || new l, 0 === h ? s.set(-2, -1, -1) : (h = 1 / h, c = (c * o - r * a) * h, n = (n * a - r * o) * h, s.set(1 - c - n, n, c))
                }
            }(),
            containsPoint: function() {
                var t = new l;
                return function(e, i, n, r) {
                    return e = st.barycoordFromPoint(e, i, n, r, t), 0 <= e.x && 0 <= e.y && 1 >= e.x + e.y
                }
            }()
        }), Object.assign(st.prototype, {
            set: function(t, e, i) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
            },
            setFromPointsAndIndices: function(t, e, i, n) {
                return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            },
            area: function() {
                var t = new l,
                    e = new l;
                return function() {
                    return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
                }
            }(),
            midpoint: function(t) {
                return (t || new l).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            normal: function(t) {
                return st.normal(this.a, this.b, this.c, t)
            },
            plane: function(t) {
                return (t || new K).setFromCoplanarPoints(this.a, this.b, this.c)
            },
            barycoordFromPoint: function(t, e) {
                return st.barycoordFromPoint(t, this.a, this.b, this.c, e)
            },
            containsPoint: function(t) {
                return st.containsPoint(t, this.a, this.b, this.c)
            },
            closestPointToPoint: function() {
                var t = new K,
                    e = [new at, new at, new at],
                    i = new l,
                    n = new l;
                return function(r, o) {
                    var a = o || new l,
                        s = 1 / 0;
                    if (t.setFromCoplanarPoints(this.a, this.b, this.c), t.projectPoint(r, i), !0 === this.containsPoint(i)) a.copy(i);
                    else {
                        e[0].set(this.a, this.b), e[1].set(this.b, this.c), e[2].set(this.c, this.a);
                        for (var c = 0; c < e.length; c++) {
                            e[c].closestPointToPoint(i, !0, n);
                            var h = i.distanceToSquared(n);
                            h < s && (s = h, a.copy(n))
                        }
                    }
                    return a
                }
            }(),
            equals: function(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }), Object.assign(lt.prototype, {
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        }), ct.prototype = Object.create(q.prototype), ct.prototype.constructor = ct, ct.prototype.isMeshBasicMaterial = !0, ct.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
        }, Object.defineProperty(ht.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(ht.prototype, {
            isBufferAttribute: !0,
            setArray: function(t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t
            },
            setDynamic: function(t) {
                return this.dynamic = t, this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
            },
            copyAt: function(t, e, i) {
                t *= this.itemSize, i *= e.itemSize;
                for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            copyArray: function(t) {
                return this.array.set(t), this
            },
            copyColorsArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var o = t[n];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new G), e[i++] = o.r, e[i++] = o.g, e[i++] = o.b
                }
                return this
            },
            copyIndicesArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var o = t[n];
                    e[i++] = o.a, e[i++] = o.b, e[i++] = o.c
                }
                return this
            },
            copyVector2sArray: function(t) {
                for (var e = this.array, n = 0, r = 0, o = t.length; r < o; r++) {
                    var a = t[r];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new i), e[n++] = a.x, e[n++] = a.y
                }
                return this
            },
            copyVector3sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                    var o = t[n];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), o = new l), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z
                }
                return this
            },
            copyVector4sArray: function(t) {
                for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) {
                    var a = t[n];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), a = new r), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z, e[i++] = a.w
                }
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            getX: function(t) {
                return this.array[t * this.itemSize]
            },
            setX: function(t, e) {
                return this.array[t * this.itemSize] = e, this
            },
            getY: function(t) {
                return this.array[t * this.itemSize + 1]
            },
            setY: function(t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            },
            getZ: function(t) {
                return this.array[t * this.itemSize + 2]
            },
            setZ: function(t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            },
            getW: function(t) {
                return this.array[t * this.itemSize + 3]
            },
            setW: function(t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            },
            setXY: function(t, e, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            },
            clone: function() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
        }), ut.prototype = Object.create(ht.prototype), ut.prototype.constructor = ut, dt.prototype = Object.create(ht.prototype), dt.prototype.constructor = dt, pt.prototype = Object.create(ht.prototype), pt.prototype.constructor = pt, ft.prototype = Object.create(ht.prototype), ft.prototype.constructor = ft, mt.prototype = Object.create(ht.prototype), mt.prototype.constructor = mt, gt.prototype = Object.create(ht.prototype), gt.prototype.constructor = gt, vt.prototype = Object.create(ht.prototype), vt.prototype.constructor = vt, yt.prototype = Object.create(ht.prototype), yt.prototype.constructor = yt, _t.prototype = Object.create(ht.prototype), _t.prototype.constructor = _t, Object.assign(xt.prototype, {
            computeGroups: function(t) {
                var e, i = [],
                    n = void 0;
                t = t.faces;
                for (var r = 0; r < t.length; r++) {
                    var o = t[r];
                    o.materialIndex !== n && (n = o.materialIndex, void 0 !== e && (e.count = 3 * r - e.start, i.push(e)), e = {
                        start: 3 * r,
                        materialIndex: n
                    })
                }
                void 0 !== e && (e.count = 3 * r - e.start, i.push(e)), this.groups = i
            },
            fromGeometry: function(t) {
                var e, n = t.faces,
                    r = t.vertices,
                    o = t.faceVertexUvs,
                    a = o[0] && 0 < o[0].length,
                    s = o[1] && 0 < o[1].length,
                    l = t.morphTargets,
                    c = l.length;
                if (0 < c) {
                    e = [];
                    for (var h = 0; h < c; h++) e[h] = [];
                    this.morphTargets.position = e
                }
                var u, d = t.morphNormals,
                    p = d.length;
                if (0 < p) {
                    for (u = [], h = 0; h < p; h++) u[h] = [];
                    this.morphTargets.normal = u
                }
                for (var f = t.skinIndices, m = t.skinWeights, g = f.length === r.length, v = m.length === r.length, h = 0; h < n.length; h++) {
                    var y = n[h];
                    this.vertices.push(r[y.a], r[y.b], r[y.c]);
                    var _ = y.vertexNormals;
                    for (3 === _.length ? this.normals.push(_[0], _[1], _[2]) : (_ = y.normal, this.normals.push(_, _, _)), _ = y.vertexColors, 3 === _.length ? this.colors.push(_[0], _[1], _[2]) : (_ = y.color, this.colors.push(_, _, _)), !0 === a && (_ = o[0][h], void 0 !== _ ? this.uvs.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new i, new i, new i))), !0 === s && (_ = o[1][h], void 0 !== _ ? this.uvs2.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new i, new i, new i))), _ = 0; _ < c; _++) {
                        var x = l[_].vertices;
                        e[_].push(x[y.a], x[y.b], x[y.c])
                    }
                    for (_ = 0; _ < p; _++) x = d[_].vertexNormals[h], u[_].push(x.a, x.b, x.c);
                    g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                }
                return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            }
        });
        var Dr = 0;
        Object.assign(wt.prototype, e.prototype, {
            isGeometry: !0,
            applyMatrix: function(t) {
                for (var e = (new J).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(t);
                for (i = 0, n = this.faces.length; i < n; i++) {
                    t = this.faces[i], t.normal.applyMatrix3(e).normalize();
                    for (var r = 0, o = t.vertexNormals.length; r < o; r++) t.vertexNormals[r].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
            },
            rotateX: function() {
                var t = new c;
                return function(e) {
                    return t.makeRotationX(e), this.applyMatrix(t), this
                }
            }(),
            rotateY: function() {
                var t = new c;
                return function(e) {
                    return t.makeRotationY(e), this.applyMatrix(t), this
                }
            }(),
            rotateZ: function() {
                var t = new c;
                return function(e) {
                    return t.makeRotationZ(e), this.applyMatrix(t), this
                }
            }(),
            translate: function() {
                var t = new c;
                return function(e, i, n) {
                    return t.makeTranslation(e, i, n), this.applyMatrix(t), this
                }
            }(),
            scale: function() {
                var t = new c;
                return function(e, i, n) {
                    return t.makeScale(e, i, n), this.applyMatrix(t), this
                }
            }(),
            lookAt: function() {
                var t = new ot;
                return function(e) {
                    t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                }
            }(),
            fromBufferGeometry: function(t) {
                function e(t, e, i, r) {
                    var o = void 0 !== s ? [d[t].clone(), d[e].clone(), d[i].clone()] : [],
                        a = void 0 !== c ? [n.colors[t].clone(), n.colors[e].clone(), n.colors[i].clone()] : [];
                    r = new lt(t, e, i, o, a, r), n.faces.push(r), void 0 !== h && n.faceVertexUvs[0].push([p[t].clone(), p[e].clone(), p[i].clone()]), void 0 !== u && n.faceVertexUvs[1].push([f[t].clone(), f[e].clone(), f[i].clone()])
                }
                var n = this,
                    r = null !== t.index ? t.index.array : void 0,
                    o = t.attributes,
                    a = o.position.array,
                    s = void 0 !== o.normal ? o.normal.array : void 0,
                    c = void 0 !== o.color ? o.color.array : void 0,
                    h = void 0 !== o.uv ? o.uv.array : void 0,
                    u = void 0 !== o.uv2 ? o.uv2.array : void 0;
                void 0 !== u && (this.faceVertexUvs[1] = []);
                for (var d = [], p = [], f = [], m = o = 0; o < a.length; o += 3, m += 2) n.vertices.push(new l(a[o], a[o + 1], a[o + 2])), void 0 !== s && d.push(new l(s[o], s[o + 1], s[o + 2])), void 0 !== c && n.colors.push(new G(c[o], c[o + 1], c[o + 2])), void 0 !== h && p.push(new i(h[m], h[m + 1])), void 0 !== u && f.push(new i(u[m], u[m + 1]));
                var g = t.groups;
                if (0 < g.length)
                    for (o = 0; o < g.length; o++)
                        for (var a = g[o], v = a.start, y = a.count, m = v, v = v + y; m < v; m += 3) void 0 !== r ? e(r[m], r[m + 1], r[m + 2], a.materialIndex) : e(m, m + 1, m + 2, a.materialIndex);
                else if (void 0 !== r)
                    for (o = 0; o < r.length; o += 3) e(r[o], r[o + 1], r[o + 2]);
                else
                    for (o = 0; o < a.length / 3; o += 3) e(o, o + 1, o + 2);
                return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            },
            center: function() {
                this.computeBoundingBox();
                var t = this.boundingBox.getCenter().negate();
                return this.translate(t.x, t.y, t.z), t
            },
            normalize: function() {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center,
                    e = this.boundingSphere.radius,
                    e = 0 === e ? 1 : 1 / e,
                    i = new c;
                return i.set(e, 0, 0, -e * t.x, 0, e, 0, -e * t.y, 0, 0, e, -e * t.z, 0, 0, 0, 1), this.applyMatrix(i), this
            },
            computeFaceNormals: function() {
                for (var t = new l, e = new l, i = 0, n = this.faces.length; i < n; i++) {
                    var r = this.faces[i],
                        o = this.vertices[r.a],
                        a = this.vertices[r.b];
                    t.subVectors(this.vertices[r.c], a), e.subVectors(o, a), t.cross(e), t.normalize(), r.normal.copy(t)
                }
            },
            computeVertexNormals: function(t) {
                void 0 === t && (t = !0);
                var e, i, n;
                for (n = Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++) n[e] = new l;
                if (t) {
                    var r, o, a, s = new l,
                        c = new l;
                    for (t = 0, e = this.faces.length; t < e; t++) i = this.faces[t], r = this.vertices[i.a], o = this.vertices[i.b], a = this.vertices[i.c], s.subVectors(a, o), c.subVectors(r, o), s.cross(c), n[i.a].add(s), n[i.b].add(s), n[i.c].add(s)
                } else
                    for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) i = this.faces[t], n[i.a].add(i.normal), n[i.b].add(i.normal), n[i.c].add(i.normal);
                for (e = 0, i = this.vertices.length; e < i; e++) n[e].normalize();
                for (t = 0, e = this.faces.length; t < e; t++) i = this.faces[t], r = i.vertexNormals, 3 === r.length ? (r[0].copy(n[i.a]), r[1].copy(n[i.b]), r[2].copy(n[i.c])) : (r[0] = n[i.a].clone(), r[1] = n[i.b].clone(), r[2] = n[i.c].clone());
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeFlatVertexNormals: function() {
                var t, e, i;
                for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                    i = this.faces[t];
                    var n = i.vertexNormals;
                    3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
                }
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function() {
                var t, e, i, n, r;
                for (i = 0, n = this.faces.length; i < n; i++)
                    for (r = this.faces[i], r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                var o = new wt;
                for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                    if (!this.morphNormals[t]) {
                        this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [], r = this.morphNormals[t].faceNormals;
                        var a, s, c = this.morphNormals[t].vertexNormals;
                        for (i = 0, n = this.faces.length; i < n; i++) a = new l, s = {
                            a: new l,
                            b: new l,
                            c: new l
                        }, r.push(a), c.push(s)
                    }
                    for (c = this.morphNormals[t], o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], a = c.faceNormals[i], s = c.vertexNormals[i], a.copy(r.normal), s.a.copy(r.vertexNormals[0]), s.b.copy(r.vertexNormals[1]), s.c.copy(r.vertexNormals[2])
                }
                for (i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
            },
            computeLineDistances: function() {
                for (var t = 0, e = this.vertices, i = 0, n = e.length; i < n; i++) 0 < i && (t += e[i].distanceTo(e[i - 1])), this.lineDistances[i] = t
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new Z), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new Q), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function(t, e, i) {
                if (!1 === (t && t.isGeometry)) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                else {
                    var n, r = this.vertices.length,
                        o = this.vertices,
                        a = t.vertices,
                        s = this.faces,
                        l = t.faces,
                        c = this.faceVertexUvs[0],
                        h = t.faceVertexUvs[0],
                        u = this.colors,
                        d = t.colors;
                    void 0 === i && (i = 0), void 0 !== e && (n = (new J).getNormalMatrix(e)), t = 0;
                    for (var p = a.length; t < p; t++) {
                        var f = a[t].clone();
                        void 0 !== e && f.applyMatrix4(e), o.push(f)
                    }
                    for (t = 0, p = d.length; t < p; t++) u.push(d[t].clone());
                    for (t = 0, p = l.length; t < p; t++) {
                        var a = l[t],
                            m = a.vertexNormals,
                            d = a.vertexColors,
                            u = new lt(a.a + r, a.b + r, a.c + r);
                        for (u.normal.copy(a.normal), void 0 !== n && u.normal.applyMatrix3(n).normalize(), e = 0, o = m.length; e < o; e++) f = m[e].clone(), void 0 !== n && f.applyMatrix3(n).normalize(), u.vertexNormals.push(f);
                        for (u.color.copy(a.color), e = 0, o = d.length; e < o; e++) f = d[e], u.vertexColors.push(f.clone());
                        u.materialIndex = a.materialIndex + i, s.push(u)
                    }
                    for (t = 0, p = h.length; t < p; t++)
                        if (i = h[t], n = [], void 0 !== i) {
                            for (e = 0, o = i.length; e < o; e++) n.push(i[e].clone());
                            c.push(n)
                        }
                }
            },
            mergeMesh: function(t) {
                !1 === (t && t.isMesh) ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) : (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix))
            },
            mergeVertices: function() {
                var t, e, i, n = {},
                    r = [],
                    o = [],
                    a = Math.pow(10, 4);
                for (e = 0, i = this.vertices.length; e < i; e++) t = this.vertices[e], t = Math.round(t.x * a) + "_" + Math.round(t.y * a) + "_" + Math.round(t.z * a), void 0 === n[t] ? (n[t] = e, r.push(this.vertices[e]), o[e] = r.length - 1) : o[e] = o[n[t]];
                for (n = [], e = 0, i = this.faces.length; e < i; e++)
                    for (a = this.faces[e], a.a = o[a.a], a.b = o[a.b], a.c = o[a.c], a = [a.a, a.b, a.c], t = 0; 3 > t; t++)
                        if (a[t] === a[(t + 1) % 3]) {
                            n.push(e);
                            break
                        }
                for (e = n.length - 1; 0 <= e; e--)
                    for (a = n[e], this.faces.splice(a, 1), o = 0, i = this.faceVertexUvs.length; o < i; o++) this.faceVertexUvs[o].splice(a, 1);
                return e = this.vertices.length - r.length, this.vertices = r, e
            },
            sortFacesByMaterialIndex: function() {
                for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
                t.sort(function(t, e) {
                    return t.materialIndex - e.materialIndex
                });
                var n, r, o = this.faceVertexUvs[0],
                    a = this.faceVertexUvs[1];
                for (o && o.length === e && (n = []), a && a.length === e && (r = []), i = 0; i < e; i++) {
                    var s = t[i]._id;
                    n && n.push(o[s]), r && r.push(a[s])
                }
                n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
            },
            toJSON: function() {
                function t(t, e, i) {
                    return i ? t | 1 << e : t & ~(1 << e)
                }

                function e(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== c[e] ? c[e] : (c[e] = l.length / 3, l.push(t.x, t.y, t.z), c[e])
                }

                function i(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== u[e] ? u[e] : (u[e] = h.length, h.push(t.getHex()), u[e])
                }

                function n(t) {
                    var e = t.x.toString() + t.y.toString();
                    return void 0 !== p[e] ? p[e] : (p[e] = d.length / 2, d.push(t.x, t.y), p[e])
                }
                var r = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                    var o, a = this.parameters;
                    for (o in a) void 0 !== a[o] && (r[o] = a[o]);
                    return r
                }
                for (a = [], o = 0; o < this.vertices.length; o++) {
                    var s = this.vertices[o];
                    a.push(s.x, s.y, s.z)
                }
                var s = [],
                    l = [],
                    c = {},
                    h = [],
                    u = {},
                    d = [],
                    p = {};
                for (o = 0; o < this.faces.length; o++) {
                    var f = this.faces[o],
                        m = void 0 !== this.faceVertexUvs[0][o],
                        g = 0 < f.normal.length(),
                        v = 0 < f.vertexNormals.length,
                        y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                        _ = 0 < f.vertexColors.length,
                        x = 0,
                        x = t(x, 0, 0),
                        x = t(x, 1, !0),
                        x = t(x, 2, !1),
                        x = t(x, 3, m),
                        x = t(x, 4, g),
                        x = t(x, 5, v),
                        x = t(x, 6, y),
                        x = t(x, 7, _);
                    s.push(x), s.push(f.a, f.b, f.c), s.push(f.materialIndex), m && (m = this.faceVertexUvs[0][o], s.push(n(m[0]), n(m[1]), n(m[2]))), g && s.push(e(f.normal)), v && (g = f.vertexNormals, s.push(e(g[0]), e(g[1]), e(g[2]))), y && s.push(i(f.color)), _ && (f = f.vertexColors, s.push(i(f[0]), i(f[1]), i(f[2])))
                }
                return r.data = {}, r.data.vertices = a, r.data.normals = l, 0 < h.length && (r.data.colors = h), 0 < d.length && (r.data.uvs = [d]), r.data.faces = s, r
            },
            clone: function() {
                return (new wt).copy(this)
            },
            copy: function(t) {
                var e, i, n, r, o, a;
                for (this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = t.name, n = t.vertices, e = 0, i = n.length; e < i; e++) this.vertices.push(n[e].clone());
                for (n = t.colors, e = 0, i = n.length; e < i; e++) this.colors.push(n[e].clone());
                for (n = t.faces, e = 0, i = n.length; e < i; e++) this.faces.push(n[e].clone());
                for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
                    var s = t.faceVertexUvs[e];
                    for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n = 0, r = s.length; n < r; n++) {
                        var l = s[n],
                            c = [];
                        for (o = 0, a = l.length; o < a; o++) c.push(l[o].clone());
                        this.faceVertexUvs[e].push(c)
                    }
                }
                for (o = t.morphTargets, e = 0, i = o.length; e < i; e++) {
                    if (a = {}, a.name = o[e].name, void 0 !== o[e].vertices)
                        for (a.vertices = [], n = 0, r = o[e].vertices.length; n < r; n++) a.vertices.push(o[e].vertices[n].clone());
                    if (void 0 !== o[e].normals)
                        for (a.normals = [], n = 0, r = o[e].normals.length; n < r; n++) a.normals.push(o[e].normals[n].clone());
                    this.morphTargets.push(a)
                }
                for (o = t.morphNormals, e = 0, i = o.length; e < i; e++) {
                    if (a = {}, void 0 !== o[e].vertexNormals)
                        for (a.vertexNormals = [], n = 0, r = o[e].vertexNormals.length; n < r; n++) s = o[e].vertexNormals[n], l = {}, l.a = s.a.clone(), l.b = s.b.clone(), l.c = s.c.clone(), a.vertexNormals.push(l);
                    if (void 0 !== o[e].faceNormals)
                        for (a.faceNormals = [], n = 0, r = o[e].faceNormals.length; n < r; n++) a.faceNormals.push(o[e].faceNormals[n].clone());
                    this.morphNormals.push(a)
                }
                for (n = t.skinWeights, e = 0, i = n.length; e < i; e++) this.skinWeights.push(n[e].clone());
                for (n = t.skinIndices, e = 0, i = n.length; e < i; e++) this.skinIndices.push(n[e].clone());
                for (n = t.lineDistances, e = 0, i = n.length; e < i; e++) this.lineDistances.push(n[e]);
                return e = t.boundingBox, null !== e && (this.boundingBox = e.clone()), e = t.boundingSphere, null !== e && (this.boundingSphere = e.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Tt.MaxIndex = 65535, Object.assign(Tt.prototype, e.prototype, {
            isBufferGeometry: !0,
            getIndex: function() {
                return this.index
            },
            setIndex: function(t) {
                Array.isArray(t) ? this.index = new(65535 < bt(t) ? vt : mt)(t, 1) : this.index = t
            },
            addAttribute: function(t, e, i) {
                if (!1 === (e && e.isBufferAttribute) && !1 === (e && e.isInterleavedBufferAttribute)) console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new ht(e, i));
                else {
                    if ("index" !== t) return this.attributes[t] = e, this;
                    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e)
                }
            },
            getAttribute: function(t) {
                return this.attributes[t]
            },
            removeAttribute: function(t) {
                return delete this.attributes[t], this
            },
            addGroup: function(t, e, i) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: void 0 !== i ? i : 0
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            },
            applyMatrix: function(t) {
                var e = this.attributes.position;
                return void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0), e = this.attributes.normal, void 0 !== e && ((new J).getNormalMatrix(t).applyToBufferAttribute(e), e.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: function() {
                var t = new c;
                return function(e) {
                    return t.makeRotationX(e), this.applyMatrix(t), this
                }
            }(),
            rotateY: function() {
                var t = new c;
                return function(e) {
                    return t.makeRotationY(e), this.applyMatrix(t), this
                }
            }(),
            rotateZ: function() {
                var t = new c;
                return function(e) {
                    return t.makeRotationZ(e), this.applyMatrix(t), this
                }
            }(),
            translate: function() {
                var t = new c;
                return function(e, i, n) {
                    return t.makeTranslation(e, i, n), this.applyMatrix(t), this
                }
            }(),
            scale: function() {
                var t = new c;
                return function(e, i, n) {
                    return t.makeScale(e, i, n), this.applyMatrix(t), this
                }
            }(),
            lookAt: function() {
                var t = new ot;
                return function(e) {
                    t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                }
            }(),
            center: function() {
                this.computeBoundingBox();
                var t = this.boundingBox.getCenter().negate();
                return this.translate(t.x, t.y, t.z), t
            },
            setFromObject: function(t) {
                var e = t.geometry;
                if (t.isPoints || t.isLine) {
                    t = new yt(3 * e.vertices.length, 3);
                    var i = new yt(3 * e.colors.length, 3);
                    this.addAttribute("position", t.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new yt(e.lineDistances.length, 1), this.addAttribute("lineDistance", t.copyArray(e.lineDistances))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                return this
            },
            updateFromObject: function(t) {
                var e = t.geometry;
                if (t.isMesh) {
                    var i = e.__directGeometry;
                    if (!0 === e.elementsNeedUpdate && (i = void 0, e.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(e);
                    i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i
                }
                return !0 === e.verticesNeedUpdate && (i = this.attributes.position, void 0 !== i && (i.copyVector3sArray(e.vertices), i.needsUpdate = !0), e.verticesNeedUpdate = !1), !0 === e.normalsNeedUpdate && (i = this.attributes.normal, void 0 !== i && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1), !0 === e.colorsNeedUpdate && (i = this.attributes.color, void 0 !== i && (i.copyColorsArray(e.colors), i.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (i = this.attributes.uv, void 0 !== i && (i.copyVector2sArray(e.uvs), i.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (i = this.attributes.lineDistance, void 0 !== i && (i.copyArray(e.lineDistances), i.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
            },
            fromGeometry: function(t) {
                return t.__directGeometry = (new xt).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
            },
            fromDirectGeometry: function(t) {
                var e = new Float32Array(3 * t.vertices.length);
                this.addAttribute("position", new ht(e, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new ht(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.addAttribute("color", new ht(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (e = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new ht(e, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (e = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new ht(e, 2).copyVector2sArray(t.uvs2))), 0 < t.indices.length && (e = new(65535 < bt(t.indices) ? Uint32Array : Uint16Array)(3 * t.indices.length), this.setIndex(new ht(e, 1).copyIndicesArray(t.indices))), this.groups = t.groups;
                for (var i in t.morphTargets) {
                    for (var e = [], n = t.morphTargets[i], r = 0, o = n.length; r < o; r++) {
                        var a = n[r],
                            s = new yt(3 * a.length, 3);
                        e.push(s.copyVector3sArray(a))
                    }
                    this.morphAttributes[i] = e
                }
                return 0 < t.skinIndices.length && (i = new yt(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (i = new yt(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(t.skinWeights))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new Z);
                var t = this.attributes.position;
                void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function() {
                var t = new Z,
                    e = new l;
                return function() {
                    null === this.boundingSphere && (this.boundingSphere = new Q);
                    var i = this.attributes.position;
                    if (i) {
                        var n = this.boundingSphere.center;
                        t.setFromBufferAttribute(i), t.getCenter(n);
                        for (var r = 0, o = 0, a = i.count; o < a; o++) e.x = i.getX(o), e.y = i.getY(o), e.z = i.getZ(o), r = Math.max(r, n.distanceToSquared(e));
                        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
            }(),
            computeFaceNormals: function() {},
            computeVertexNormals: function() {
                var t = this.index,
                    e = this.attributes,
                    i = this.groups;
                if (e.position) {
                    var n = e.position.array;
                    if (void 0 === e.normal) this.addAttribute("normal", new ht(new Float32Array(n.length), 3));
                    else
                        for (var r = e.normal.array, o = 0, a = r.length; o < a; o++) r[o] = 0;
                    var s, c, h, r = e.normal.array,
                        u = new l,
                        d = new l,
                        p = new l,
                        f = new l,
                        m = new l;
                    if (t) {
                        t = t.array, 0 === i.length && this.addGroup(0, t.length);
                        for (var g = 0, v = i.length; g < v; ++g)
                            for (o = i[g], a = o.start, s = o.count, o = a, a += s; o < a; o += 3) s = 3 * t[o + 0], c = 3 * t[o + 1], h = 3 * t[o + 2], u.fromArray(n, s), d.fromArray(n, c), p.fromArray(n, h), f.subVectors(p, d), m.subVectors(u, d), f.cross(m), r[s] += f.x, r[s + 1] += f.y, r[s + 2] += f.z, r[c] += f.x, r[c + 1] += f.y, r[c + 2] += f.z, r[h] += f.x, r[h + 1] += f.y, r[h + 2] += f.z
                    } else
                        for (o = 0, a = n.length; o < a; o += 9) u.fromArray(n, o), d.fromArray(n, o + 3), p.fromArray(n, o + 6), f.subVectors(p, d), m.subVectors(u, d), f.cross(m), r[o] = f.x, r[o + 1] = f.y, r[o + 2] = f.z, r[o + 3] = f.x, r[o + 4] = f.y, r[o + 5] = f.z, r[o + 6] = f.x, r[o + 7] = f.y, r[o + 8] = f.z;
                    this.normalizeNormals(), e.normal.needsUpdate = !0
                }
            },
            merge: function(t, e) {
                if (!1 !== (t && t.isBufferGeometry)) {
                    void 0 === e && (e = 0);
                    var i, n = this.attributes;
                    for (i in n)
                        if (void 0 !== t.attributes[i])
                            for (var r = n[i].array, o = t.attributes[i], a = o.array, s = 0, o = o.itemSize * e; s < a.length; s++, o++) r[o] = a[s];
                    return this
                }
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
            },
            normalizeNormals: function() {
                for (var t, e, i, n, r = this.attributes.normal, o = 0, a = r.count; o < a; o++) t = r.getX(o), e = r.getY(o), i = r.getZ(o), n = 1 / Math.sqrt(t * t + e * e + i * i), r.setXYZ(o, t * n, e * n, i * n)
            },
            toNonIndexed: function() {
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var t, e = new Tt,
                    i = this.index.array,
                    n = this.attributes;
                for (t in n) {
                    for (var r, o = n[t], a = o.array, o = o.itemSize, s = new a.constructor(i.length * o), l = 0, c = 0, h = i.length; c < h; c++) {
                        r = i[c] * o;
                        for (var u = 0; u < o; u++) s[l++] = a[r++]
                    }
                    e.addAttribute(t, new ht(s, o))
                }
                return e
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                    var e, i = this.parameters;
                    for (e in i) void 0 !== i[e] && (t[e] = i[e]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                var n = this.index;
                null !== n && (i = Array.prototype.slice.call(n.array), t.data.index = {
                    type: n.array.constructor.name,
                    array: i
                }), n = this.attributes;
                for (e in n) {
                    var r = n[e],
                        i = Array.prototype.slice.call(r.array);
                    t.data.attributes[e] = {
                        itemSize: r.itemSize,
                        type: r.array.constructor.name,
                        array: i,
                        normalized: r.normalized
                    }
                }
                return e = this.groups, 0 < e.length && (t.data.groups = JSON.parse(JSON.stringify(e))), e = this.boundingSphere, null !== e && (t.data.boundingSphere = {
                    center: e.center.toArray(),
                    radius: e.radius
                }), t
            },
            clone: function() {
                return (new Tt).copy(this)
            },
            copy: function(t) {
                var e, i, n;
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = t.name, i = t.index, null !== i && this.setIndex(i.clone()), i = t.attributes;
                for (e in i) this.addAttribute(e, i[e].clone());
                var r = t.morphAttributes;
                for (e in r) {
                    var o = [],
                        a = r[e];
                    for (i = 0, n = a.length; i < n; i++) o.push(a[i].clone());
                    this.morphAttributes[e] = o
                }
                for (e = t.groups, i = 0, n = e.length; i < n; i++) r = e[i], this.addGroup(r.start, r.count, r.materialIndex);
                return e = t.boundingBox, null !== e && (this.boundingBox = e.clone()), e = t.boundingSphere, null !== e && (this.boundingSphere = e.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), St.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: St,
            isMesh: !0,
            setDrawMode: function(t) {
                this.drawMode = t
            },
            copy: function(t) {
                return ot.prototype.copy.call(this, t), this.drawMode = t.drawMode, this
            },
            updateMorphTargets: function() {
                var t = this.geometry.morphTargets;
                if (void 0 !== t && 0 < t.length) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (var e = 0, i = t.length; e < i; e++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[t[e].name] = e
                }
            },
            raycast: function() {
                function t(t, e, i, n, r, o, a) {
                    return st.barycoordFromPoint(t, e, i, n, y), r.multiplyScalar(y.x), o.multiplyScalar(y.y), a.multiplyScalar(y.z), r.add(o).add(a), r.clone()
                }

                function e(t, e, i, n, r, o, a) {
                    var s = t.material;
                    return null === (1 === s.side ? i.intersectTriangle(o, r, n, !0, a) : i.intersectTriangle(n, r, o, 2 !== s.side, a)) ? null : (x.copy(a), x.applyMatrix4(t.matrixWorld), i = e.ray.origin.distanceTo(x), i < e.near || i > e.far ? null : {
                        distance: i,
                        point: x.clone(),
                        object: t
                    })
                }

                function n(i, n, r, o, a, l, c, d) {
                    return s.fromBufferAttribute(o, l), h.fromBufferAttribute(o, c), u.fromBufferAttribute(o, d), (i = e(i, n, r, s, h, u, _)) && (a && (m.fromBufferAttribute(a, l), g.fromBufferAttribute(a, c), v.fromBufferAttribute(a, d), i.uv = t(_, s, h, u, m, g, v)), i.face = new lt(l, c, d, st.normal(s, h, u)), i.faceIndex = l), i
                }
                var r = new c,
                    o = new it,
                    a = new Q,
                    s = new l,
                    h = new l,
                    u = new l,
                    d = new l,
                    p = new l,
                    f = new l,
                    m = new i,
                    g = new i,
                    v = new i,
                    y = new l,
                    _ = new l,
                    x = new l;
                return function(i, l) {
                    var c = this.geometry,
                        y = this.material,
                        x = this.matrixWorld;
                    if (void 0 !== y && (null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere), a.applyMatrix4(x), !1 !== i.ray.intersectsSphere(a) && (r.getInverse(x), o.copy(i.ray).applyMatrix4(r), null === c.boundingBox || !1 !== o.intersectsBox(c.boundingBox)))) {
                        var b;
                        if (c.isBufferGeometry) {
                            var w, T, S, M, y = c.index,
                                E = c.attributes.position,
                                x = c.attributes.uv;
                            if (null !== y)
                                for (S = 0, M = y.count; S < M; S += 3) c = y.getX(S), w = y.getX(S + 1), T = y.getX(S + 2), (b = n(this, i, o, E, x, c, w, T)) && (b.faceIndex = Math.floor(S / 3), l.push(b));
                            else
                                for (S = 0, M = E.count; S < M; S += 3) c = S, w = S + 1, T = S + 2, (b = n(this, i, o, E, x, c, w, T)) && (b.index = c, l.push(b))
                        } else if (c.isGeometry) {
                            var A, x = Array.isArray(y);
                            S = c.vertices, M = c.faces, w = c.faceVertexUvs[0], 0 < w.length && (E = w);
                            for (var C = 0, P = M.length; C < P; C++) {
                                var R = M[C];
                                if (b = x ? y[R.materialIndex] : y, void 0 !== b) {
                                    if (w = S[R.a], T = S[R.b], A = S[R.c], !0 === b.morphTargets) {
                                        b = c.morphTargets;
                                        var L = this.morphTargetInfluences;
                                        s.set(0, 0, 0), h.set(0, 0, 0), u.set(0, 0, 0);
                                        for (var k = 0, O = b.length; k < O; k++) {
                                            var D = L[k];
                                            if (0 !== D) {
                                                var I = b[k].vertices;
                                                s.addScaledVector(d.subVectors(I[R.a], w), D), h.addScaledVector(p.subVectors(I[R.b], T), D), u.addScaledVector(f.subVectors(I[R.c], A), D)
                                            }
                                        }
                                        s.add(w), h.add(T), u.add(A), w = s, T = h, A = u
                                    }(b = e(this, i, o, w, T, A, _)) && (E && E[C] && (L = E[C], m.copy(L[0]), g.copy(L[1]), v.copy(L[2]), b.uv = t(_, w, T, A, m, g, v)), b.face = R, b.faceIndex = C, l.push(b))
                                }
                            }
                        }
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Mt.prototype = Object.create(wt.prototype), Mt.prototype.constructor = Mt, Et.prototype = Object.create(Tt.prototype), Et.prototype.constructor = Et, At.prototype = Object.create(wt.prototype), At.prototype.constructor = At, Ct.prototype = Object.create(Tt.prototype), Ct.prototype.constructor = Ct, Pt.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: Pt,
            isCamera: !0,
            copy: function(t) {
                return ot.prototype.copy.call(this, t), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this
            },
            getWorldDirection: function() {
                var t = new s;
                return function(e) {
                    return e = e || new l, this.getWorldQuaternion(t), e.set(0, 0, -1).applyQuaternion(t)
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }), Rt.prototype = Object.assign(Object.create(Pt.prototype), {
            constructor: Rt,
            isPerspectiveCamera: !0,
            copy: function(t) {
                return Pt.prototype.copy.call(this, t), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            },
            setFocalLength: function(t) {
                t = .5 * this.getFilmHeight() / t, this.fov = 2 * yr.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
            },
            getFocalLength: function() {
                var t = Math.tan(.5 * yr.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            },
            getEffectiveFOV: function() {
                return 2 * yr.RAD2DEG * Math.atan(Math.tan(.5 * yr.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function() {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function() {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function(t, e, i, n, r, o) {
                this.aspect = t / e, this.view = {
                    fullWidth: t,
                    fullHeight: e,
                    offsetX: i,
                    offsetY: n,
                    width: r,
                    height: o
                }, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                this.view = null, this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t = this.near,
                    e = t * Math.tan(.5 * yr.DEG2RAD * this.fov) / this.zoom,
                    i = 2 * e,
                    n = this.aspect * i,
                    r = -.5 * n,
                    o = this.view;
                if (null !== o) var a = o.fullWidth,
                    s = o.fullHeight,
                    r = r + o.offsetX * n / a,
                    e = e - o.offsetY * i / s,
                    n = o.width / a * n,
                    i = o.height / s * i;
                o = this.filmOffset, 0 !== o && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far)
            },
            toJSON: function(t) {
                return t = ot.prototype.toJSON.call(this, t), t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
            }
        }), Lt.prototype = Object.assign(Object.create(Pt.prototype), {
            constructor: Lt,
            isOrthographicCamera: !0,
            copy: function(t) {
                return Pt.prototype.copy.call(this, t), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            },
            setViewOffset: function(t, e, i, n, r, o) {
                this.view = {
                    fullWidth: t,
                    fullHeight: e,
                    offsetX: i,
                    offsetY: n,
                    width: r,
                    height: o
                }, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                this.view = null, this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t = (this.right - this.left) / (2 * this.zoom),
                    e = (this.top - this.bottom) / (2 * this.zoom),
                    i = (this.right + this.left) / 2,
                    n = (this.top + this.bottom) / 2,
                    r = i - t,
                    i = i + t,
                    t = n + e,
                    e = n - e;
                if (null !== this.view) var i = this.zoom / (this.view.width / this.view.fullWidth),
                    e = this.zoom / (this.view.height / this.view.fullHeight),
                    o = (this.right - this.left) / this.view.width,
                    n = (this.top - this.bottom) / this.view.height,
                    r = r + this.view.offsetX / i * o,
                    i = r + this.view.width / i * o,
                    t = t - this.view.offsetY / e * n,
                    e = t - this.view.height / e * n;
                this.projectionMatrix.makeOrthographic(r, i, t, e, this.near, this.far)
            },
            toJSON: function(t) {
                return t = ot.prototype.toJSON.call(this, t), t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
            }
        });
        var Ir = 0;
        ce.prototype.isFogExp2 = !0, ce.prototype.clone = function() {
            return new ce(this.color.getHex(), this.density)
        }, ce.prototype.toJSON = function(t) {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }, he.prototype.isFog = !0, he.prototype.clone = function() {
            return new he(this.color.getHex(), this.near, this.far)
        }, he.prototype.toJSON = function(t) {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }, ue.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: ue,
            copy: function(t, e) {
                return ot.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
            },
            toJSON: function(t) {
                var e = ot.prototype.toJSON.call(this, t);
                return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
            }
        }), de.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: de,
            isLensFlare: !0,
            copy: function(t) {
                ot.prototype.copy.call(this, t), this.positionScreen.copy(t.positionScreen), this.customUpdateCallback = t.customUpdateCallback;
                for (var e = 0, i = t.lensFlares.length; e < i; e++) this.lensFlares.push(t.lensFlares[e]);
                return this
            },
            add: function(t, e, i, n, r, o) {
                void 0 === e && (e = -1), void 0 === i && (i = 0), void 0 === o && (o = 1), void 0 === r && (r = new G(16777215)), void 0 === n && (n = 1), i = Math.min(i, Math.max(0, i)), this.lensFlares.push({
                    texture: t,
                    size: e,
                    distance: i,
                    x: 0,
                    y: 0,
                    z: 0,
                    scale: 1,
                    rotation: 0,
                    opacity: o,
                    color: r,
                    blending: n
                })
            },
            updateLensFlares: function() {
                var t, e, i = this.lensFlares.length,
                    n = 2 * -this.positionScreen.x,
                    r = 2 * -this.positionScreen.y;
                for (t = 0; t < i; t++) e = this.lensFlares[t], e.x = this.positionScreen.x + n * e.distance, e.y = this.positionScreen.y + r * e.distance, e.wantedRotation = e.x * Math.PI * .25, e.rotation += .25 * (e.wantedRotation - e.rotation)
            }
        }), pe.prototype = Object.create(q.prototype), pe.prototype.constructor = pe, pe.prototype.isSpriteMaterial = !0, pe.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this
        }, fe.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: fe,
            isSprite: !0,
            raycast: function() {
                var t = new l,
                    e = new l,
                    i = new l;
                return function(n, r) {
                    e.setFromMatrixPosition(this.matrixWorld), n.ray.closestPointToPoint(e, t), i.setFromMatrixScale(this.matrixWorld);
                    var o = i.x * i.y / 4;
                    e.distanceToSquared(t) > o || (o = n.ray.origin.distanceTo(t), o < n.near || o > n.far || r.push({
                        distance: o,
                        point: t.clone(),
                        face: null,
                        object: this
                    }))
                }
            }(),
            clone: function() {
                return new this.constructor(this.material).copy(this)
            }
        }), me.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: me,
            copy: function(t) {
                ot.prototype.copy.call(this, t, !1), t = t.levels;
                for (var e = 0, i = t.length; e < i; e++) {
                    var n = t[e];
                    this.addLevel(n.object.clone(), n.distance)
                }
                return this
            },
            addLevel: function(t, e) {
                void 0 === e && (e = 0), e = Math.abs(e);
                for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
                i.splice(n, 0, {
                    distance: e,
                    object: t
                }), this.add(t)
            },
            getObjectForDistance: function(t) {
                for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
                return e[i - 1].object
            },
            raycast: function() {
                var t = new l;
                return function(e, i) {
                    t.setFromMatrixPosition(this.matrixWorld);
                    var n = e.ray.origin.distanceTo(t);
                    this.getObjectForDistance(n).raycast(e, i)
                }
            }(),
            update: function() {
                var t = new l,
                    e = new l;
                return function(i) {
                    var n = this.levels;
                    if (1 < n.length) {
                        t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld), i = t.distanceTo(e), n[0].object.visible = !0;
                        for (var r = 1, o = n.length; r < o && i >= n[r].distance; r++) n[r - 1].object.visible = !1, n[r].object.visible = !0;
                        for (; r < o; r++) n[r].object.visible = !1
                    }
                }
            }(),
            toJSON: function(t) {
                t = ot.prototype.toJSON.call(this, t), t.object.levels = [];
                for (var e = this.levels, i = 0, n = e.length; i < n; i++) {
                    var r = e[i];
                    t.object.levels.push({
                        object: r.object.uuid,
                        distance: r.distance
                    })
                }
                return t
            }
        }), Object.assign(ge.prototype, {
            calculateInverses: function() {
                this.boneInverses = [];
                for (var t = 0, e = this.bones.length; t < e; t++) {
                    var i = new c;
                    this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
                }
            },
            pose: function() {
                var t, e, i;
                for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
            },
            update: function() {
                var t = new c,
                    e = new c;
                return function() {
                    for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, a = 0, s = i.length; a < s; a++) t.multiplyMatrices(i[a] ? i[a].matrixWorld : e, n[a]), t.toArray(r, 16 * a);
                    void 0 !== o && (o.needsUpdate = !0)
                }
            }(),
            clone: function() {
                return new ge(this.bones, this.boneInverses)
            }
        }), ve.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: ve,
            isBone: !0
        }), ye.prototype = Object.assign(Object.create(St.prototype), {
            constructor: ye,
            isSkinnedMesh: !0,
            initBones: function() {
                var t, e, i, n, r = [];
                if (this.geometry && void 0 !== this.geometry.bones) {
                    for (i = 0, n = this.geometry.bones.length; i < n; i++) e = this.geometry.bones[i], t = new ve, r.push(t), t.name = e.name, t.position.fromArray(e.pos), t.quaternion.fromArray(e.rotq), void 0 !== e.scl && t.scale.fromArray(e.scl);
                    for (i = 0, n = this.geometry.bones.length; i < n; i++) e = this.geometry.bones[i], -1 !== e.parent && null !== e.parent && void 0 !== r[e.parent] ? r[e.parent].add(r[i]) : this.add(r[i])
                }
                return this.updateMatrixWorld(!0), r
            },
            bind: function(t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
            },
            pose: function() {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function() {
                var t, e;
                if (this.geometry && this.geometry.isGeometry)
                    for (e = 0; e < this.geometry.skinWeights.length; e++) {
                        var i = this.geometry.skinWeights[e];
                        t = 1 / i.lengthManhattan(), 1 / 0 !== t ? i.multiplyScalar(t) : i.set(1, 0, 0, 0)
                    } else if (this.geometry && this.geometry.isBufferGeometry) {
                        var i = new r,
                            n = this.geometry.attributes.skinWeight;
                        for (e = 0; e < n.count; e++) i.x = n.getX(e), i.y = n.getY(e), i.z = n.getZ(e), i.w = n.getW(e), t = 1 / i.lengthManhattan(), 1 / 0 !== t ? i.multiplyScalar(t) : i.set(1, 0, 0, 0), n.setXYZW(e, i.x, i.y, i.z, i.w)
                    }
            },
            updateMatrixWorld: function(t) {
                St.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            },
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), _e.prototype = Object.create(q.prototype), _e.prototype.constructor = _e, _e.prototype.isLineBasicMaterial = !0, _e.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
        }, xe.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: xe,
            isLine: !0,
            raycast: function() {
                var t = new c,
                    e = new it,
                    i = new Q;
                return function(n, r) {
                    var o = n.linePrecision,
                        o = o * o,
                        a = this.geometry,
                        s = this.matrixWorld;
                    if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(s), !1 !== n.ray.intersectsSphere(i)) {
                        t.getInverse(s), e.copy(n.ray).applyMatrix4(t);
                        var c = new l,
                            h = new l,
                            s = new l,
                            u = new l,
                            d = this && this.isLineSegments ? 2 : 1;
                        if (a.isBufferGeometry) {
                            var p = a.index,
                                f = a.attributes.position.array;
                            if (null !== p)
                                for (var p = p.array, a = 0, m = p.length - 1; a < m; a += d) {
                                    var g = p[a + 1];
                                    c.fromArray(f, 3 * p[a]), h.fromArray(f, 3 * g), g = e.distanceSqToSegment(c, h, u, s), g > o || (u.applyMatrix4(this.matrixWorld), g = n.ray.origin.distanceTo(u), g < n.near || g > n.far || r.push({
                                        distance: g,
                                        point: s.clone().applyMatrix4(this.matrixWorld),
                                        index: a,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                                } else
                                    for (a = 0, m = f.length / 3 - 1; a < m; a += d) c.fromArray(f, 3 * a), h.fromArray(f, 3 * a + 3), g = e.distanceSqToSegment(c, h, u, s), g > o || (u.applyMatrix4(this.matrixWorld), g = n.ray.origin.distanceTo(u), g < n.near || g > n.far || r.push({
                                        distance: g,
                                        point: s.clone().applyMatrix4(this.matrixWorld),
                                        index: a,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                        } else if (a.isGeometry)
                            for (c = a.vertices, h = c.length, a = 0; a < h - 1; a += d) g = e.distanceSqToSegment(c[a], c[a + 1], u, s), g > o || (u.applyMatrix4(this.matrixWorld), g = n.ray.origin.distanceTo(u), g < n.near || g > n.far || r.push({
                                distance: g,
                                point: s.clone().applyMatrix4(this.matrixWorld),
                                index: a,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), be.prototype = Object.assign(Object.create(xe.prototype), {
            constructor: be,
            isLineSegments: !0
        }), we.prototype = Object.assign(Object.create(xe.prototype), {
            constructor: we,
            isLineLoop: !0
        }), Te.prototype = Object.create(q.prototype), Te.prototype.constructor = Te, Te.prototype.isPointsMaterial = !0, Te.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
        }, Se.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: Se,
            isPoints: !0,
            raycast: function() {
                var t = new c,
                    e = new it,
                    i = new Q;
                return function(n, r) {
                    function o(t, i) {
                        var o = e.distanceSqToPoint(t);
                        if (o < u) {
                            var s = e.closestPointToPoint(t);
                            s.applyMatrix4(c);
                            var l = n.ray.origin.distanceTo(s);
                            l < n.near || l > n.far || r.push({
                                distance: l,
                                distanceToRay: Math.sqrt(o),
                                point: s.clone(),
                                index: i,
                                face: null,
                                object: a
                            })
                        }
                    }
                    var a = this,
                        s = this.geometry,
                        c = this.matrixWorld,
                        h = n.params.Points.threshold;
                    if (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(c), i.radius += h, !1 !== n.ray.intersectsSphere(i)) {
                        t.getInverse(c), e.copy(n.ray).applyMatrix4(t);
                        var h = h / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            u = h * h,
                            h = new l;
                        if (s.isBufferGeometry) {
                            var d = s.index,
                                s = s.attributes.position.array;
                            if (null !== d)
                                for (var p = d.array, d = 0, f = p.length; d < f; d++) {
                                    var m = p[d];
                                    h.fromArray(s, 3 * m), o(h, m)
                                } else
                                    for (d = 0, p = s.length / 3; d < p; d++) h.fromArray(s, 3 * d), o(h, d)
                        } else
                            for (h = s.vertices, d = 0, p = h.length; d < p; d++) o(h[d], d)
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Me.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: Me
        }), Ee.prototype = Object.create(n.prototype), Ee.prototype.constructor = Ee, Ae.prototype = Object.create(n.prototype), Ae.prototype.constructor = Ae, Ae.prototype.isCompressedTexture = !0, Ce.prototype = Object.create(n.prototype), Ce.prototype.constructor = Ce, Pe.prototype = Object.create(n.prototype), Pe.prototype.constructor = Pe, Pe.prototype.isDepthTexture = !0, Re.prototype = Object.create(Tt.prototype), Re.prototype.constructor = Re, Le.prototype = Object.create(wt.prototype), Le.prototype.constructor = Le, ke.prototype = Object.create(Tt.prototype), ke.prototype.constructor = ke, Oe.prototype = Object.create(wt.prototype), Oe.prototype.constructor = Oe, De.prototype = Object.create(Tt.prototype), De.prototype.constructor = De, Ie.prototype = Object.create(wt.prototype), Ie.prototype.constructor = Ie, Ne.prototype = Object.create(De.prototype), Ne.prototype.constructor = Ne, Be.prototype = Object.create(wt.prototype), Be.prototype.constructor = Be, Ue.prototype = Object.create(De.prototype), Ue.prototype.constructor = Ue, Fe.prototype = Object.create(wt.prototype), Fe.prototype.constructor = Fe, ze.prototype = Object.create(De.prototype), ze.prototype.constructor = ze, He.prototype = Object.create(wt.prototype), He.prototype.constructor = He, je.prototype = Object.create(De.prototype), je.prototype.constructor = je, Ge.prototype = Object.create(wt.prototype), Ge.prototype.constructor = Ge, Ve.prototype = Object.create(Tt.prototype), Ve.prototype.constructor = Ve, We.prototype = Object.create(wt.prototype), We.prototype.constructor = We, Xe.prototype = Object.create(Tt.prototype), Xe.prototype.constructor = Xe, qe.prototype = Object.create(wt.prototype), qe.prototype.constructor = qe, $e.prototype = Object.create(Tt.prototype), $e.prototype.constructor = $e;
        var Nr = {
            area: function(t) {
                for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                return .5 * i
            },
            triangulate: function() {
                return function(t, e) {
                    var i = t.length;
                    if (3 > i) return null;
                    var n, r, o, a = [],
                        s = [],
                        l = [];
                    if (0 < Nr.area(t))
                        for (r = 0; r < i; r++) s[r] = r;
                    else
                        for (r = 0; r < i; r++) s[r] = i - 1 - r;
                    var c = 2 * i;
                    for (r = i - 1; 2 < i;) {
                        if (0 >= c--) {
                            console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
                            break
                        }
                        n = r, i <= n && (n = 0), r = n + 1, i <= r && (r = 0), o = r + 1, i <= o && (o = 0);
                        var h;
                        t: {
                            var u, d, p, f, m, g, v, y;
                            if (u = t[s[n]].x, d = t[s[n]].y, p = t[s[r]].x, f = t[s[r]].y, m = t[s[o]].x, g = t[s[o]].y, 0 >= (p - u) * (g - d) - (f - d) * (m - u)) h = !1;
                            else {
                                var _, x, b, w, T, S, M, E, A, C;
                                for (_ = m - p, x = g - f, b = u - m, w = d - g, T = p - u, S = f - d, h = 0; h < i; h++)
                                    if (v = t[s[h]].x, y = t[s[h]].y, !(v === u && y === d || v === p && y === f || v === m && y === g) && (M = v - u, E = y - d, A = v - p, C = y - f, v -= m, y -= g, A = _ * C - x * A, M = T * E - S * M, E = b * y - w * v, A >= -Number.EPSILON && E >= -Number.EPSILON && M >= -Number.EPSILON)) {
                                        h = !1;
                                        break t
                                    }
                                h = !0
                            }
                        }
                        if (h) {
                            for (a.push([t[s[n]], t[s[r]], t[s[o]]]), l.push([s[n], s[r], s[o]]), n = r, o = r + 1; o < i; n++, o++) s[n] = s[o];
                            i--, c = 2 * i
                        }
                    }
                    return e ? l : a
                }
            }(),
            triangulateShape: function(t, e) {
                function i(t) {
                    var e = t.length;
                    2 < e && t[e - 1].equals(t[0]) && t.pop()
                }

                function n(t, e, i) {
                    return t.x !== e.x ? t.x < e.x ? t.x <= i.x && i.x <= e.x : e.x <= i.x && i.x <= t.x : t.y < e.y ? t.y <= i.y && i.y <= e.y : e.y <= i.y && i.y <= t.y
                }

                function r(t, e, i, r, o) {
                    var a = e.x - t.x,
                        s = e.y - t.y,
                        l = r.x - i.x,
                        c = r.y - i.y,
                        h = t.x - i.x,
                        u = t.y - i.y,
                        d = s * l - a * c,
                        p = s * h - a * u;
                    if (Math.abs(d) > Number.EPSILON) {
                        if (0 < d) {
                            if (0 > p || p > d) return [];
                            if (l = c * h - l * u, 0 > l || l > d) return []
                        } else {
                            if (0 < p || p < d) return [];
                            if (l = c * h - l * u, 0 < l || l < d) return []
                        }
                        return 0 === l ? !o || 0 !== p && p !== d ? [t] : [] : l === d ? !o || 0 !== p && p !== d ? [e] : [] : 0 === p ? [i] : p === d ? [r] : (o = l / d, [{
                            x: t.x + o * a,
                            y: t.y + o * s
                        }])
                    }
                    return 0 !== p || c * h !== l * u ? [] : (s = 0 === a && 0 === s, l = 0 === l && 0 === c, s && l ? t.x !== i.x || t.y !== i.y ? [] : [t] : s ? n(i, r, t) ? [t] : [] : l ? n(t, e, i) ? [i] : [] : (0 !== a ? (t.x < e.x ? (a = t, l = t.x, s = e, t = e.x) : (a = e, l = e.x, s = t, t = t.x), i.x < r.x ? (e = i, d = i.x, c = r, i = r.x) : (e = r,
                        d = r.x, c = i, i = i.x)) : (t.y < e.y ? (a = t, l = t.y, s = e, t = e.y) : (a = e, l = e.y, s = t, t = t.y), i.y < r.y ? (e = i, d = i.y, c = r, i = r.y) : (e = r, d = r.y, c = i, i = i.y)), l <= d ? t < d ? [] : t === d ? o ? [] : [e] : t <= i ? [e, s] : [e, c] : l > i ? [] : l === i ? o ? [] : [a] : t <= i ? [a, s] : [a, c]))
                }

                function o(t, e, i, n) {
                    var r = e.x - t.x,
                        o = e.y - t.y;
                    e = i.x - t.x, i = i.y - t.y;
                    var a = n.x - t.x;
                    return n = n.y - t.y, t = r * i - o * e, r = r * n - o * a, Math.abs(t) > Number.EPSILON ? (e = a * i - n * e, 0 < t ? 0 <= r && 0 <= e : 0 <= r || 0 <= e) : 0 < r
                }
                i(t), e.forEach(i);
                var a, s, l, c, h, u = {};
                for (l = t.concat(), a = 0, s = e.length; a < s; a++) Array.prototype.push.apply(l, e[a]);
                for (a = 0, s = l.length; a < s; a++) h = l[a].x + ":" + l[a].y, void 0 !== u[h] && console.warn("THREE.ShapeUtils: Duplicate point", h, a), u[h] = a;
                a = function(t, e) {
                    function i(t, e) {
                        var i = g.length - 1,
                            n = t - 1;
                        0 > n && (n = i);
                        var r = t + 1;
                        return r > i && (r = 0), !!(i = o(g[t], g[n], g[r], s[e])) && (i = s.length - 1, n = e - 1, 0 > n && (n = i), r = e + 1, r > i && (r = 0), !!(i = o(s[e], s[n], s[r], g[t])))
                    }

                    function n(t, e) {
                        var i, n;
                        for (i = 0; i < g.length; i++)
                            if (n = i + 1, n %= g.length, n = r(t, e, g[i], g[n], !0), 0 < n.length) return !0;
                        return !1
                    }

                    function a(t, i) {
                        var n, o, a, s;
                        for (n = 0; n < v.length; n++)
                            for (o = e[v[n]], a = 0; a < o.length; a++)
                                if (s = a + 1, s %= o.length, s = r(t, i, o[a], o[s], !0), 0 < s.length) return !0;
                        return !1
                    }
                    var s, l, c, h, u, d, p, f, m, g = t.concat(),
                        v = [],
                        y = [],
                        _ = 0;
                    for (l = e.length; _ < l; _++) v.push(_);
                    p = 0;
                    for (var x = 2 * v.length; 0 < v.length;) {
                        if (x--, 0 > x) {
                            console.log("Infinite Loop! Holes left:" + v.length + ", Probably Hole outside Shape!");
                            break
                        }
                        for (c = p; c < g.length; c++) {
                            for (h = g[c], l = -1, _ = 0; _ < v.length; _++)
                                if (u = v[_], d = h.x + ":" + h.y + ":" + u, void 0 === y[d]) {
                                    for (s = e[u], f = 0; f < s.length; f++)
                                        if (u = s[f], i(c, f) && !n(h, u) && !a(h, u)) {
                                            l = f, v.splice(_, 1), p = g.slice(0, c + 1), u = g.slice(c), f = s.slice(l), m = s.slice(0, l + 1), g = p.concat(f).concat(m).concat(u), p = c;
                                            break
                                        }
                                    if (0 <= l) break;
                                    y[d] = !0
                                }
                            if (0 <= l) break
                        }
                    }
                    return g
                }(t, e);
                var d = Nr.triangulate(a, !1);
                for (a = 0, s = d.length; a < s; a++)
                    for (c = d[a], l = 0; 3 > l; l++) h = c[l].x + ":" + c[l].y, h = u[h], void 0 !== h && (c[l] = h);
                return d.concat()
            },
            isClockWise: function(t) {
                return 0 > Nr.area(t)
            }
        };
        Ye.prototype = Object.create(wt.prototype), Ye.prototype.constructor = Ye, Ze.prototype = Object.create(Tt.prototype), Ze.prototype.constructor = Ze, Ze.prototype.getArrays = function() {
            var t = this.getAttribute("position"),
                t = t ? Array.prototype.slice.call(t.array) : [],
                e = this.getAttribute("uv"),
                e = e ? Array.prototype.slice.call(e.array) : [],
                i = this.index,
                i = i ? Array.prototype.slice.call(i.array) : [];
            return {
                position: t,
                uv: e,
                index: i
            }
        }, Ze.prototype.addShapeList = function(t, e) {
            var i = t.length;
            e.arrays = this.getArrays();
            for (var n = 0; n < i; n++) this.addShape(t[n], e);
            this.setIndex(e.arrays.index), this.addAttribute("position", new yt(e.arrays.position, 3)), this.addAttribute("uv", new yt(e.arrays.uv, 2))
        }, Ze.prototype.addShape = function(t, e) {
            function n(t, e, i) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
            }

            function r(t, e, n) {
                var r, o, a;
                o = t.x - e.x, a = t.y - e.y, r = n.x - t.x;
                var s = n.y - t.y,
                    l = o * o + a * a;
                if (Math.abs(o * s - a * r) > Number.EPSILON) {
                    var c = Math.sqrt(l),
                        h = Math.sqrt(r * r + s * s),
                        l = e.x - a / c;
                    if (e = e.y + o / c, s = ((n.x - s / h - l) * s - (n.y + r / h - e) * r) / (o * s - a * r), r = l + o * s - t.x, o = e + a * s - t.y, a = r * r + o * o, 2 >= a) return new i(r, o);
                    a = Math.sqrt(a / 2)
                } else t = !1, o > Number.EPSILON ? r > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? r < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(s) && (t = !0), t ? (r = -a, a = Math.sqrt(l)) : (r = o, o = a, a = Math.sqrt(l / 2));
                return new i(r / a, o / a)
            }

            function o(t, e) {
                var i, n;
                for (W = t.length; 0 <= --W;) {
                    i = W, n = W - 1, 0 > n && (n = t.length - 1);
                    var r, o = E + 2 * T;
                    for (r = 0; r < o; r++) {
                        var a = G * r,
                            s = G * (r + 1),
                            l = e + n + a,
                            u = e + n + s,
                            s = e + i + s;
                        c(e + i + a), c(l), c(s), c(l), c(u), c(s), a = v.length / 3, a = P.generateSideWallUV(O, v, a - 6, a - 3, a - 2, a - 1), h(a[0]), h(a[1]), h(a[3]), h(a[1]), h(a[2]), h(a[3])
                    }
                }
            }

            function a(t, e, i) {
                x.push(t), x.push(e), x.push(i)
            }

            function s(t, e, i) {
                c(t), c(e), c(i), t = v.length / 3, t = P.generateTopUV(O, v, t - 3, t - 2, t - 1), h(t[0]), h(t[1]), h(t[2])
            }

            function c(t) {
                y.push(v.length / 3), v.push(x[3 * t + 0]), v.push(x[3 * t + 1]), v.push(x[3 * t + 2])
            }

            function h(t) {
                _.push(t.x), _.push(t.y)
            }
            var u, d, p, f, m, g = e.arrays ? e.arrays : this.getArrays(),
                v = g.position,
                y = g.index,
                _ = g.uv,
                x = [],
                g = void 0 !== e.amount ? e.amount : 100,
                b = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                w = void 0 !== e.bevelSize ? e.bevelSize : b - 2,
                T = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                S = void 0 === e.bevelEnabled || e.bevelEnabled,
                M = void 0 !== e.curveSegments ? e.curveSegments : 12,
                E = void 0 !== e.steps ? e.steps : 1,
                A = e.extrudePath,
                C = !1,
                P = void 0 !== e.UVGenerator ? e.UVGenerator : Ye.WorldUVGenerator;
            A && (u = A.getSpacedPoints(E), C = !0, S = !1, d = void 0 !== e.frames ? e.frames : A.computeFrenetFrames(E, !1), p = new l, f = new l, m = new l), S || (w = b = T = 0);
            var R, L, k, O = this,
                A = t.extractPoints(M),
                M = A.shape,
                D = A.holes;
            if (A = !Nr.isClockWise(M)) {
                for (M = M.reverse(), L = 0, k = D.length; L < k; L++) R = D[L], Nr.isClockWise(R) && (D[L] = R.reverse());
                A = !1
            }
            var I = Nr.triangulateShape(M, D),
                N = M;
            for (L = 0, k = D.length; L < k; L++) R = D[L], M = M.concat(R);
            var B, U, F, z, H, j, G = M.length,
                V = I.length,
                A = [],
                W = 0;
            for (F = N.length, B = F - 1, U = W + 1; W < F; W++, B++, U++) B === F && (B = 0), U === F && (U = 0), A[W] = r(N[W], N[B], N[U]);
            var X, q = [],
                $ = A.concat();
            for (L = 0, k = D.length; L < k; L++) {
                for (R = D[L], X = [], W = 0, F = R.length, B = F - 1, U = W + 1; W < F; W++, B++, U++) B === F && (B = 0), U === F && (U = 0), X[W] = r(R[W], R[B], R[U]);
                q.push(X), $ = $.concat(X)
            }
            for (B = 0; B < T; B++) {
                for (F = B / T, z = b * Math.cos(F * Math.PI / 2), U = w * Math.sin(F * Math.PI / 2), W = 0, F = N.length; W < F; W++) H = n(N[W], A[W], U), a(H.x, H.y, -z);
                for (L = 0, k = D.length; L < k; L++)
                    for (R = D[L], X = q[L], W = 0, F = R.length; W < F; W++) H = n(R[W], X[W], U), a(H.x, H.y, -z)
            }
            for (U = w, W = 0; W < G; W++) H = S ? n(M[W], $[W], U) : M[W], C ? (f.copy(d.normals[0]).multiplyScalar(H.x), p.copy(d.binormals[0]).multiplyScalar(H.y), m.copy(u[0]).add(f).add(p), a(m.x, m.y, m.z)) : a(H.x, H.y, 0);
            for (F = 1; F <= E; F++)
                for (W = 0; W < G; W++) H = S ? n(M[W], $[W], U) : M[W], C ? (f.copy(d.normals[F]).multiplyScalar(H.x), p.copy(d.binormals[F]).multiplyScalar(H.y), m.copy(u[F]).add(f).add(p), a(m.x, m.y, m.z)) : a(H.x, H.y, g / E * F);
            for (B = T - 1; 0 <= B; B--) {
                for (F = B / T, z = b * Math.cos(F * Math.PI / 2), U = w * Math.sin(F * Math.PI / 2), W = 0, F = N.length; W < F; W++) H = n(N[W], A[W], U), a(H.x, H.y, g + z);
                for (L = 0, k = D.length; L < k; L++)
                    for (R = D[L], X = q[L], W = 0, F = R.length; W < F; W++) H = n(R[W], X[W], U), C ? a(H.x, H.y + u[E - 1].y, u[E - 1].x + z) : a(H.x, H.y, g + z)
            }! function() {
                var t = v.length / 3;
                if (S) {
                    var i = 0 * G;
                    for (W = 0; W < V; W++) j = I[W], s(j[2] + i, j[1] + i, j[0] + i);
                    for (i = G * (E + 2 * T), W = 0; W < V; W++) j = I[W], s(j[0] + i, j[1] + i, j[2] + i)
                } else {
                    for (W = 0; W < V; W++) j = I[W], s(j[2], j[1], j[0]);
                    for (W = 0; W < V; W++) j = I[W], s(j[0] + G * E, j[1] + G * E, j[2] + G * E)
                }
                O.addGroup(t, v.length / 3 - t, void 0 !== e.material ? e.material : 0)
            }(),
            function() {
                var t = v.length / 3,
                    i = 0;
                for (o(N, i), i += N.length, L = 0, k = D.length; L < k; L++) R = D[L], o(R, i), i += R.length;
                O.addGroup(t, v.length / 3 - t, void 0 !== e.extrudeMaterial ? e.extrudeMaterial : 1)
            }(), e.arrays || (this.setIndex(y), this.addAttribute("position", new yt(v, 3)), this.addAttribute("uv", new yt(e.arrays.uv, 2)))
        }, Ye.WorldUVGenerator = {
            generateTopUV: function(t, e, n, r, o) {
                t = e[3 * r], r = e[3 * r + 1];
                var a = e[3 * o];
                return o = e[3 * o + 1], [new i(e[3 * n], e[3 * n + 1]), new i(t, r), new i(a, o)]
            },
            generateSideWallUV: function(t, e, n, r, o, a) {
                t = e[3 * n];
                var s = e[3 * n + 1];
                n = e[3 * n + 2];
                var l = e[3 * r],
                    c = e[3 * r + 1];
                r = e[3 * r + 2];
                var h = e[3 * o],
                    u = e[3 * o + 1];
                o = e[3 * o + 2];
                var d = e[3 * a],
                    p = e[3 * a + 1];
                return e = e[3 * a + 2], .01 > Math.abs(s - c) ? [new i(t, 1 - n), new i(l, 1 - r), new i(h, 1 - o), new i(d, 1 - e)] : [new i(s, 1 - n), new i(c, 1 - r), new i(u, 1 - o), new i(p, 1 - e)]
            }
        }, Qe.prototype = Object.create(wt.prototype), Qe.prototype.constructor = Qe, Je.prototype = Object.create(Ze.prototype), Je.prototype.constructor = Je, Ke.prototype = Object.create(wt.prototype), Ke.prototype.constructor = Ke, ti.prototype = Object.create(Tt.prototype), ti.prototype.constructor = ti, ei.prototype = Object.create(wt.prototype), ei.prototype.constructor = ei, ii.prototype = Object.create(Tt.prototype), ii.prototype.constructor = ii, ni.prototype = Object.create(wt.prototype), ni.prototype.constructor = ni, ri.prototype = Object.create(Tt.prototype), ri.prototype.constructor = ri, oi.prototype = Object.create(wt.prototype), oi.prototype.constructor = oi, ai.prototype = Object.create(Tt.prototype), ai.prototype.constructor = ai, si.prototype = Object.create(Tt.prototype), si.prototype.constructor = si, li.prototype = Object.create(wt.prototype), li.prototype.constructor = li, ci.prototype = Object.create(Tt.prototype), ci.prototype.constructor = ci, hi.prototype = Object.create(li.prototype), hi.prototype.constructor = hi, ui.prototype = Object.create(ci.prototype), ui.prototype.constructor = ui, di.prototype = Object.create(wt.prototype), di.prototype.constructor = di, pi.prototype = Object.create(Tt.prototype), pi.prototype.constructor = pi;
        var Br = Object.freeze({
            WireframeGeometry: Re,
            ParametricGeometry: Le,
            ParametricBufferGeometry: ke,
            TetrahedronGeometry: Ie,
            TetrahedronBufferGeometry: Ne,
            OctahedronGeometry: Be,
            OctahedronBufferGeometry: Ue,
            IcosahedronGeometry: Fe,
            IcosahedronBufferGeometry: ze,
            DodecahedronGeometry: He,
            DodecahedronBufferGeometry: je,
            PolyhedronGeometry: Oe,
            PolyhedronBufferGeometry: De,
            TubeGeometry: Ge,
            TubeBufferGeometry: Ve,
            TorusKnotGeometry: We,
            TorusKnotBufferGeometry: Xe,
            TorusGeometry: qe,
            TorusBufferGeometry: $e,
            TextGeometry: Qe,
            TextBufferGeometry: Je,
            SphereGeometry: Ke,
            SphereBufferGeometry: ti,
            RingGeometry: ei,
            RingBufferGeometry: ii,
            PlaneGeometry: At,
            PlaneBufferGeometry: Ct,
            LatheGeometry: ni,
            LatheBufferGeometry: ri,
            ShapeGeometry: oi,
            ShapeBufferGeometry: ai,
            ExtrudeGeometry: Ye,
            ExtrudeBufferGeometry: Ze,
            EdgesGeometry: si,
            ConeGeometry: hi,
            ConeBufferGeometry: ui,
            CylinderGeometry: li,
            CylinderBufferGeometry: ci,
            CircleGeometry: di,
            CircleBufferGeometry: pi,
            BoxGeometry: Mt,
            BoxBufferGeometry: Et
        });
        fi.prototype = Object.create($.prototype), fi.prototype.constructor = fi, fi.prototype.isShadowMaterial = !0, mi.prototype = Object.create($.prototype), mi.prototype.constructor = mi, mi.prototype.isRawShaderMaterial = !0, gi.prototype = Object.create(q.prototype), gi.prototype.constructor = gi, gi.prototype.isMeshStandardMaterial = !0, gi.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.defines = {
                STANDARD: ""
            }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, vi.prototype = Object.create(gi.prototype), vi.prototype.constructor = vi, vi.prototype.isMeshPhysicalMaterial = !0, vi.prototype.copy = function(t) {
            return gi.prototype.copy.call(this, t), this.defines = {
                PHYSICAL: ""
            }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
        }, yi.prototype = Object.create(q.prototype), yi.prototype.constructor = yi, yi.prototype.isMeshPhongMaterial = !0, yi.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, _i.prototype = Object.create(yi.prototype), _i.prototype.constructor = _i, _i.prototype.isMeshToonMaterial = !0, _i.prototype.copy = function(t) {
            return yi.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
        }, xi.prototype = Object.create(q.prototype), xi.prototype.constructor = xi, xi.prototype.isMeshNormalMaterial = !0, xi.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, bi.prototype = Object.create(q.prototype), bi.prototype.constructor = bi, bi.prototype.isMeshLambertMaterial = !0, bi.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, wi.prototype = Object.create(q.prototype), wi.prototype.constructor = wi, wi.prototype.isLineDashedMaterial = !0, wi.prototype.copy = function(t) {
            return q.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
        };
        var Ur = Object.freeze({
                ShadowMaterial: fi,
                SpriteMaterial: pe,
                RawShaderMaterial: mi,
                ShaderMaterial: $,
                PointsMaterial: Te,
                MeshPhysicalMaterial: vi,
                MeshStandardMaterial: gi,
                MeshPhongMaterial: yi,
                MeshToonMaterial: _i,
                MeshNormalMaterial: xi,
                MeshLambertMaterial: bi,
                MeshDepthMaterial: Y,
                MeshBasicMaterial: ct,
                LineDashedMaterial: wi,
                LineBasicMaterial: _e,
                Material: q
            }),
            Fr = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            },
            zr = new Ti;
        Object.assign(Si.prototype, {
            load: function(t, e, i, n) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t);
                var r = this,
                    o = Fr.get(t);
                if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                    e && e(o), r.manager.itemEnd(t)
                }, 0), o;
                var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (a) {
                    var s = a[1],
                        l = !!a[2],
                        a = a[3],
                        a = window.decodeURIComponent(a);
                    l && (a = window.atob(a));
                    try {
                        var c, h = (this.responseType || "").toLowerCase();
                        switch (h) {
                            case "arraybuffer":
                            case "blob":
                                c = new ArrayBuffer(a.length);
                                for (var u = new Uint8Array(c), l = 0; l < a.length; l++) u[l] = a.charCodeAt(l);
                                "blob" === h && (c = new Blob([c], {
                                    type: s
                                }));
                                break;
                            case "document":
                                c = (new DOMParser).parseFromString(a, s);
                                break;
                            case "json":
                                c = JSON.parse(a);
                                break;
                            default:
                                c = a
                        }
                        window.setTimeout(function() {
                            e && e(c), r.manager.itemEnd(t)
                        }, 0)
                    } catch (e) {
                        window.setTimeout(function() {
                            n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
                        }, 0)
                    }
                } else {
                    var d = new XMLHttpRequest;
                    d.open("GET", t, !0), d.addEventListener("load", function(i) {
                        var o = i.target.response;
                        Fr.add(t, o), 200 === this.status ? (e && e(o), r.manager.itemEnd(t)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), e && e(o), r.manager.itemEnd(t)) : (n && n(i), r.manager.itemEnd(t), r.manager.itemError(t))
                    }, !1), void 0 !== i && d.addEventListener("progress", function(t) {
                        i(t)
                    }, !1), d.addEventListener("error", function(e) {
                        n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
                    }, !1), void 0 !== this.responseType && (d.responseType = this.responseType), void 0 !== this.withCredentials && (d.withCredentials = this.withCredentials), d.overrideMimeType && d.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (s in this.requestHeader) d.setRequestHeader(s, this.requestHeader[s]);
                    d.send(null)
                }
                return r.manager.itemStart(t), d
            },
            setPath: function(t) {
                return this.path = t, this
            },
            setResponseType: function(t) {
                return this.responseType = t, this
            },
            setWithCredentials: function(t) {
                return this.withCredentials = t, this
            },
            setMimeType: function(t) {
                return this.mimeType = t, this
            },
            setRequestHeader: function(t) {
                return this.requestHeader = t, this
            }
        }), Object.assign(Mi.prototype, {
            load: function(t, e, i, n) {
                function r(r) {
                    l.load(t[r], function(t) {
                        t = o._parser(t, !0), a[r] = {
                            width: t.width,
                            height: t.height,
                            format: t.format,
                            mipmaps: t.mipmaps
                        }, c += 1, 6 === c && (1 === t.mipmapCount && (s.minFilter = 1006), s.format = t.format, s.needsUpdate = !0, e && e(s))
                    }, i, n)
                }
                var o = this,
                    a = [],
                    s = new Ae;
                s.image = a;
                var l = new Si(this.manager);
                if (l.setPath(this.path), l.setResponseType("arraybuffer"), Array.isArray(t))
                    for (var c = 0, h = 0, u = t.length; h < u; ++h) r(h);
                else l.load(t, function(t) {
                    if (t = o._parser(t, !0), t.isCubemap)
                        for (var i = t.mipmaps.length / t.mipmapCount, n = 0; n < i; n++) {
                            a[n] = {
                                mipmaps: []
                            };
                            for (var r = 0; r < t.mipmapCount; r++) a[n].mipmaps.push(t.mipmaps[n * t.mipmapCount + r]), a[n].format = t.format, a[n].width = t.width, a[n].height = t.height
                        } else s.image.width = t.width, s.image.height = t.height, s.mipmaps = t.mipmaps;
                    1 === t.mipmapCount && (s.minFilter = 1006), s.format = t.format, s.needsUpdate = !0, e && e(s)
                }, i, n);
                return s
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Object.assign(Ei.prototype, {
            load: function(t, e, i, n) {
                var r = this,
                    o = new h,
                    a = new Si(this.manager);
                return a.setResponseType("arraybuffer"), a.load(t, function(t) {
                    (t = r._parser(t)) && (void 0 !== t.image ? o.image = t.image : void 0 !== t.data && (o.image.width = t.width, o.image.height = t.height, o.image.data = t.data), o.wrapS = void 0 !== t.wrapS ? t.wrapS : 1001, o.wrapT = void 0 !== t.wrapT ? t.wrapT : 1001, o.magFilter = void 0 !== t.magFilter ? t.magFilter : 1006, o.minFilter = void 0 !== t.minFilter ? t.minFilter : 1008, o.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (o.format = t.format), void 0 !== t.type && (o.type = t.type), void 0 !== t.mipmaps && (o.mipmaps = t.mipmaps), 1 === t.mipmapCount && (o.minFilter = 1006), o.needsUpdate = !0, e && e(o, t))
                }, i, n), o
            }
        }), Object.assign(Ai.prototype, {
            load: function(t, e, i, n) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t);
                var r = this,
                    o = Fr.get(t);
                return void 0 !== o ? (r.manager.itemStart(t), setTimeout(function() {
                    e && e(o), r.manager.itemEnd(t)
                }, 0), o) : (i = document.createElementNS("http://www.w3.org/1999/xhtml", "img"), i.addEventListener("load", function() {
                    Fr.add(t, this), e && e(this), r.manager.itemEnd(t)
                }, !1), i.addEventListener("error", function(e) {
                    n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
                }, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (i.crossOrigin = this.crossOrigin), r.manager.itemStart(t), i.src = t, i)
            },
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Object.assign(Ci.prototype, {
            load: function(t, e, i, n) {
                function r(i) {
                    a.load(t[i], function(t) {
                        o.images[i] = t, s++, 6 === s && (o.needsUpdate = !0, e && e(o))
                    }, void 0, n)
                }
                var o = new u,
                    a = new Ai(this.manager);
                a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                var s = 0;
                for (i = 0; i < t.length; ++i) r(i);
                return o
            },
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Object.assign(Pi.prototype, {
            load: function(t, e, i, r) {
                var o = new Ai(this.manager);
                o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                var a = new n;
                return a.image = o.load(t, function() {
                    var i = 0 < t.search(/\.(jpg|jpeg)$/) || 0 === t.search(/^data\:image\/jpeg/);
                    a.format = i ? 1022 : 1023, a.needsUpdate = !0, void 0 !== e && e(a)
                }, i, r), a
            },
            setCrossOrigin: function(t) {
                return this.crossOrigin = t, this
            },
            setPath: function(t) {
                return this.path = t, this
            }
        }), Ri.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: Ri,
            isLight: !0,
            copy: function(t) {
                return ot.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
            },
            toJSON: function(t) {
                return t = ot.prototype.toJSON.call(this, t), t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
            }
        }), Li.prototype = Object.assign(Object.create(Ri.prototype), {
            constructor: Li,
            isHemisphereLight: !0,
            copy: function(t) {
                return Ri.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }), Object.assign(ki.prototype, {
            copy: function(t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                var t = {};
                return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }), Oi.prototype = Object.assign(Object.create(ki.prototype), {
            constructor: Oi,
            isSpotLightShadow: !0,
            update: function(t) {
                var e = this.camera,
                    i = 2 * yr.RAD2DEG * t.angle,
                    n = this.mapSize.width / this.mapSize.height;
                t = t.distance || e.far, i === e.fov && n === e.aspect && t === e.far || (e.fov = i, e.aspect = n, e.far = t, e.updateProjectionMatrix())
            }
        }), Di.prototype = Object.assign(Object.create(Ri.prototype), {
            constructor: Di,
            isSpotLight: !0,
            copy: function(t) {
                return Ri.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), Ii.prototype = Object.assign(Object.create(Ri.prototype), {
            constructor: Ii,
            isPointLight: !0,
            copy: function(t) {
                return Ri.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }), Ni.prototype = Object.assign(Object.create(ki.prototype), {
            constructor: Ni
        }), Bi.prototype = Object.assign(Object.create(Ri.prototype), {
            constructor: Bi,
            isDirectionalLight: !0,
            copy: function(t) {
                return Ri.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), Ui.prototype = Object.assign(Object.create(Ri.prototype), {
            constructor: Ui,
            isAmbientLight: !0
        }), Fi.prototype = Object.assign(Object.create(Ri.prototype), {
            constructor: Fi,
            isRectAreaLight: !0,
            copy: function(t) {
                return Ri.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
            },
            toJSON: function(t) {
                return t = Ri.prototype.toJSON.call(this, t), t.object.width = this.width, t.object.height = this.height, t
            }
        });
        var Hr = {
            arraySlice: function(t, e, i) {
                return Hr.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
            },
            convertArray: function(t, e, i) {
                return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                for (var e = t.length, i = Array(e), n = 0; n !== e; ++n) i[n] = n;
                return i.sort(function(e, i) {
                    return t[e] - t[i]
                }), i
            },
            sortedArray: function(t, e, i) {
                for (var n = t.length, r = new t.constructor(n), o = 0, a = 0; a !== n; ++o)
                    for (var s = i[o] * e, l = 0; l !== e; ++l) r[a++] = t[s + l];
                return r
            },
            flattenJSON: function(t, e, i, n) {
                for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[n];) o = t[r++];
                if (void 0 !== o) {
                    var a = o[n];
                    if (void 0 !== a)
                        if (Array.isArray(a)) {
                            do a = o[n], void 0 !== a && (e.push(o.time), i.push.apply(i, a)), o = t[r++]; while (void 0 !== o)
                        } else if (void 0 !== a.toArray) {
                        do a = o[n], void 0 !== a && (e.push(o.time), a.toArray(i, i.length)), o = t[r++]; while (void 0 !== o)
                    } else
                        do a = o[n], void 0 !== a && (e.push(o.time), i.push(a)), o = t[r++]; while (void 0 !== o)
                }
            }
        };
        Object.assign(zi.prototype, {
            evaluate: function(t) {
                var e = this.parameterPositions,
                    i = this._cachedIndex,
                    n = e[i],
                    r = e[i - 1];
                t: {
                    e: {
                        i: {
                            n: if (!(t < n)) {
                                for (var o = i + 2;;) {
                                    if (void 0 === n) {
                                        if (t < r) break n;
                                        return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, t, r)
                                    }
                                    if (i === o) break;
                                    if (r = n, n = e[++i], t < n) break e
                                }
                                n = e.length;
                                break i
                            }if (t >= r) break t;
                            for (o = e[1], t < o && (i = 2, r = o), o = i - 2;;) {
                                if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                if (i === o) break;
                                if (n = r, r = e[--i - 1], t >= r) break e
                            }
                            n = i,
                            i = 0
                        }
                        for (; i < n;) r = i + n >>> 1,
                        t < e[r] ? n = r : i = r + 1;
                        if (n = e[i], r = e[i - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                        if (void 0 === n) return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, r, t)
                    }
                    this._cachedIndex = i,
                    this.intervalChanged_(i, r, n)
                }
                return this.interpolate_(i, r, t, n)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(t) {
                var e = this.resultBuffer,
                    i = this.sampleValues,
                    n = this.valueSize;
                t *= n;
                for (var r = 0; r !== n; ++r) e[r] = i[t + r];
                return e
            },
            interpolate_: function(t, e, i, n) {
                throw Error("call to abstract method")
            },
            intervalChanged_: function(t, e, i) {}
        }), Object.assign(zi.prototype, {
            beforeStart_: zi.prototype.copySampleValue_,
            afterEnd_: zi.prototype.copySampleValue_
        }), Hi.prototype = Object.assign(Object.create(zi.prototype), {
            constructor: Hi,
            DefaultSettings_: {
                endingStart: 2400,
                endingEnd: 2400
            },
            intervalChanged_: function(t, e, i) {
                var n = this.parameterPositions,
                    r = t - 2,
                    o = t + 1,
                    a = n[r],
                    s = n[o];
                if (void 0 === a) switch (this.getSettings_().endingStart) {
                    case 2401:
                        r = t, a = 2 * e - i;
                        break;
                    case 2402:
                        r = n.length - 2, a = e + n[r] - n[r + 1];
                        break;
                    default:
                        r = t, a = i
                }
                if (void 0 === s) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        o = t, s = 2 * i - e;
                        break;
                    case 2402:
                        o = 1, s = i + n[1] - n[0];
                        break;
                    default:
                        o = t - 1, s = e
                }
                t = .5 * (i - e), n = this.valueSize, this._weightPrev = t / (e - a), this._weightNext = t / (s - i), this._offsetPrev = r * n, this._offsetNext = o * n
            },
            interpolate_: function(t, e, i, n) {
                var r = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize;
                t *= a;
                var s = t - a,
                    l = this._offsetPrev,
                    c = this._offsetNext,
                    h = this._weightPrev,
                    u = this._weightNext,
                    d = (i - e) / (n - e);
                for (i = d * d, n = i * d, e = -h * n + 2 * h * i - h * d, h = (1 + h) * n + (-1.5 - 2 * h) * i + (-.5 + h) * d + 1, d = (-1 - u) * n + (1.5 + u) * i + .5 * d, u = u * n - u * i, i = 0; i !== a; ++i) r[i] = e * o[l + i] + h * o[s + i] + d * o[t + i] + u * o[c + i];
                return r
            }
        }), ji.prototype = Object.assign(Object.create(zi.prototype), {
            constructor: ji,
            interpolate_: function(t, e, i, n) {
                var r = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize;
                t *= a;
                var s = t - a;
                for (e = (i - e) / (n - e), i = 1 - e, n = 0; n !== a; ++n) r[n] = o[s + n] * i + o[t + n] * e;
                return r
            }
        }), Gi.prototype = Object.assign(Object.create(zi.prototype), {
            constructor: Gi,
            interpolate_: function(t, e, i, n) {
                return this.copySampleValue_(t - 1)
            }
        });
        var jr;
        jr = {
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodDiscrete: function(t) {
                return new Gi(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodLinear: function(t) {
                return new ji(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: function(t) {
                return new Hi(this.times, this.values, this.getValueSize(), t)
            },
            setInterpolation: function(t) {
                var e;
                switch (t) {
                    case 2300:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case 2301:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case 2302:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation) throw Error(e);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    console.warn(e)
                } else this.createInterpolant = e
            },
            getInterpolation: function() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return 2300;
                    case this.InterpolantFactoryMethodLinear:
                        return 2301;
                    case this.InterpolantFactoryMethodSmooth:
                        return 2302
                }
            },
            getValueSize: function() {
                return this.values.length / this.times.length
            },
            shift: function(t) {
                if (0 !== t)
                    for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
                return this
            },
            scale: function(t) {
                if (1 !== t)
                    for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
                return this
            },
            trim: function(t, e) {
                for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < t;) ++r;
                for (; - 1 !== o && i[o] > e;) --o;
                return ++o, 0 === r && o === n || (r >= o && (o = Math.max(o, 1), r = o - 1), n = this.getValueSize(), this.times = Hr.arraySlice(i, r, o), this.values = Hr.arraySlice(this.values, r * n, o * n)), this
            },
            validate: function() {
                var t = !0,
                    e = this.getValueSize();
                0 !== e - Math.floor(e) && (console.error("invalid value size in track", this), t = !1);
                var i = this.times,
                    e = this.values,
                    n = i.length;
                0 === n && (console.error("track is empty", this), t = !1);
                for (var r = null, o = 0; o !== n; o++) {
                    var a = i[o];
                    if ("number" == typeof a && isNaN(a)) {
                        console.error("time is not a valid number", this, o, a), t = !1;
                        break
                    }
                    if (null !== r && r > a) {
                        console.error("out of order keys", this, o, a, r), t = !1;
                        break
                    }
                    r = a
                }
                if (void 0 !== e && Hr.isTypedArray(e))
                    for (o = 0, i = e.length; o !== i; ++o)
                        if (n = e[o], isNaN(n)) {
                            console.error("value is not a valid number", this, o, n), t = !1;
                            break
                        }
                return t
            },
            optimize: function() {
                for (var t = this.times, e = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, o = t.length - 1, a = 1; a < o; ++a) {
                    var s = !1,
                        l = t[a];
                    if (l !== t[a + 1] && (1 !== a || l !== l[0]))
                        if (n) s = !0;
                        else
                            for (var c = a * i, h = c - i, u = c + i, l = 0; l !== i; ++l) {
                                var d = e[c + l];
                                if (d !== e[h + l] || d !== e[u + l]) {
                                    s = !0;
                                    break
                                }
                            }
                    if (s) {
                        if (a !== r)
                            for (t[r] = t[a], s = a * i, c = r * i, l = 0; l !== i; ++l) e[c + l] = e[s + l];
                        ++r
                    }
                }
                if (0 < o) {
                    for (t[r] = t[o], s = o * i, c = r * i, l = 0; l !== i; ++l) e[c + l] = e[s + l];
                    ++r
                }
                return r !== t.length && (this.times = Hr.arraySlice(t, 0, r), this.values = Hr.arraySlice(e, 0, r * i)), this
            }
        }, Wi.prototype = Object.assign(Object.create(jr), {
            constructor: Wi,
            ValueTypeName: "vector"
        }), Xi.prototype = Object.assign(Object.create(zi.prototype), {
            constructor: Xi,
            interpolate_: function(t, e, i, n) {
                var r = this.resultBuffer,
                    o = this.sampleValues,
                    a = this.valueSize;
                for (t *= a, e = (i - e) / (n - e), i = t + a; t !== i; t += 4) s.slerpFlat(r, 0, o, t - a, o, t, e);
                return r
            }
        }), qi.prototype = Object.assign(Object.create(jr), {
            constructor: qi,
            ValueTypeName: "quaternion",
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodLinear: function(t) {
                return new Xi(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), $i.prototype = Object.assign(Object.create(jr), {
            constructor: $i,
            ValueTypeName: "number"
        }), Yi.prototype = Object.assign(Object.create(jr), {
            constructor: Yi,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Zi.prototype = Object.assign(Object.create(jr), {
            constructor: Zi,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Qi.prototype = Object.assign(Object.create(jr), {
            constructor: Qi,
            ValueTypeName: "color"
        }), Ji.prototype = jr, jr.constructor = Ji, Object.assign(Ji, {
            parse: function(t) {
                if (void 0 === t.type) throw Error("track type undefined, can not parse");
                var e = Ji._getTrackTypeForValueTypeName(t.type);
                if (void 0 === t.times) {
                    var i = [],
                        n = [];
                    Hr.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            },
            toJSON: function(t) {
                var e = t.constructor;
                if (void 0 !== e.toJSON) e = e.toJSON(t);
                else {
                    var e = {
                            name: t.name,
                            times: Hr.convertArray(t.times, Array),
                            values: Hr.convertArray(t.values, Array)
                        },
                        i = t.getInterpolation();
                    i !== t.DefaultInterpolation && (e.interpolation = i)
                }
                return e.type = t.ValueTypeName, e
            },
            _getTrackTypeForValueTypeName: function(t) {
                switch (t.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return $i;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return Wi;
                    case "color":
                        return Qi;
                    case "quaternion":
                        return qi;
                    case "bool":
                    case "boolean":
                        return Zi;
                    case "string":
                        return Yi
                }
                throw Error("Unsupported typeName: " + t)
            }
        }), Object.assign(Ki, {
            parse: function(t) {
                for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, o = i.length; r !== o; ++r) e.push(Ji.parse(i[r]).scale(n));
                return new Ki(t.name, t.duration, e)
            },
            toJSON: function(t) {
                var e = [],
                    i = t.tracks;
                t = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e
                };
                for (var n = 0, r = i.length; n !== r; ++n) e.push(Ji.toJSON(i[n]));
                return t
            },
            CreateFromMorphTargetSequence: function(t, e, i, n) {
                for (var r = e.length, o = [], a = 0; a < r; a++) {
                    var s = [],
                        l = [];
                    s.push((a + r - 1) % r, a, (a + 1) % r), l.push(0, 1, 0);
                    var c = Hr.getKeyframeOrder(s),
                        s = Hr.sortedArray(s, 1, c),
                        l = Hr.sortedArray(l, 1, c);
                    n || 0 !== s[0] || (s.push(r), l.push(l[0])), o.push(new $i(".morphTargetInfluences[" + e[a].name + "]", s, l).scale(1 / i))
                }
                return new Ki(t, -1, o)
            },
            findByName: function(t, e) {
                var i = t;
                Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations);
                for (var n = 0; n < i.length; n++)
                    if (i[n].name === e) return i[n];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(t, e, i) {
                for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                    var s = t[o],
                        l = s.name.match(r);
                    if (l && 1 < l.length) {
                        var c = l[1];
                        (l = n[c]) || (n[c] = l = []), l.push(s)
                    }
                }
                t = [];
                for (c in n) t.push(Ki.CreateFromMorphTargetSequence(c, n[c], e, i));
                return t
            },
            parseAnimation: function(t, e) {
                if (!t) return console.error("  no animation in JSONLoader data"), null;
                for (var i = function(t, e, i, n, r) {
                        if (0 !== i.length) {
                            var o = [],
                                a = [];
                            Hr.flattenJSON(i, o, a, n), 0 !== o.length && r.push(new t(e, o, a))
                        }
                    }, n = [], r = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], l = 0; l < s.length; l++) {
                    var c = s[l].keys;
                    if (c && 0 !== c.length)
                        if (c[0].morphTargets) {
                            for (var o = {}, h = 0; h < c.length; h++)
                                if (c[h].morphTargets)
                                    for (var u = 0; u < c[h].morphTargets.length; u++) o[c[h].morphTargets[u]] = -1;
                            for (var d in o) {
                                for (var p = [], f = [], u = 0; u !== c[h].morphTargets.length; ++u) {
                                    var m = c[h];
                                    p.push(m.time), f.push(m.morphTarget === d ? 1 : 0)
                                }
                                n.push(new $i(".morphTargetInfluence[" + d + "]", p, f))
                            }
                            o = o.length * (a || 1)
                        } else h = ".bones[" + e[l].name + "]", i(Wi, h + ".position", c, "pos", n), i(qi, h + ".quaternion", c, "rot", n), i(Wi, h + ".scale", c, "scl", n)
                }
                return 0 === n.length ? null : new Ki(r, o, n)
            }
        }), Object.assign(Ki.prototype, {
            resetDuration: function() {
                for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) var n = this.tracks[e],
                    t = Math.max(t, n.times[n.times.length - 1]);
                this.duration = t
            },
            trim: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            },
            optimize: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }
        }), Object.assign(tn.prototype, {
            load: function(t, e, i, n) {
                var r = this,
                    o = new Si(r.manager);
                o.setResponseType("json"), o.load(t, function(t) {
                    e(r.parse(t))
                }, i, n)
            },
            setTextures: function(t) {
                this.textures = t
            },
            parse: function(t) {
                function e(t) {
                    return void 0 === n[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), n[t]
                }
                var n = this.textures,
                    r = new Ur[t.type];
                if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.uniforms && (r.uniforms = t.uniforms), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.shading && (r.shading = t.shading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = e(t.map)), void 0 !== t.alphaMap && (r.alphaMap = e(t.alphaMap), r.transparent = !0), void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)), void 0 !== t.normalScale) {
                    var o = t.normalScale;
                    !1 === Array.isArray(o) && (o = [o, o]), r.normalScale = (new i).fromArray(o)
                }
                return void 0 !== t.displacementMap && (r.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)), void 0 !== t.envMap && (r.envMap = e(t.envMap)), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)), r
            }
        }), Object.assign(en.prototype, {
            load: function(t, e, i, n) {
                var r = this,
                    o = new Si(r.manager);
                o.setResponseType("json"), o.load(t, function(t) {
                    e(r.parse(t))
                }, i, n)
            },
            parse: function(t) {
                var e = new Tt,
                    i = t.data.index;
                void 0 !== i && (i = new Gr[i.type](i.array), e.setIndex(new ht(i, 1)));
                var n, r = t.data.attributes;
                for (n in r) {
                    var o = r[n],
                        i = new Gr[o.type](o.array);
                    e.addAttribute(n, new ht(i, o.itemSize, o.normalized))
                }
                if (n = t.data.groups || t.data.drawcalls || t.data.offsets, void 0 !== n)
                    for (i = 0, r = n.length; i !== r; ++i) o = n[i], e.addGroup(o.start, o.count, o.materialIndex);
                return t = t.data.boundingSphere, void 0 !== t && (n = new l, void 0 !== t.center && n.fromArray(t.center), e.boundingSphere = new Q(n, t.radius)), e
            }
        });
        var Gr = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: Uint8ClampedArray,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };
        nn.Handlers = {
            handlers: [],
            add: function(t, e) {
                this.handlers.push(t, e)
            },
            get: function(t) {
                for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                    var r = e[i + 1];
                    if (e[i].test(t)) return r
                }
                return null
            }
        }, Object.assign(nn.prototype, {
            crossOrigin: void 0,
            extractUrlBase: function(t) {
                return t = t.split("/"), 1 === t.length ? "./" : (t.pop(), t.join("/") + "/")
            },
            initMaterials: function(t, e, i) {
                for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
                return n
            },
            createMaterial: function() {
                var t = {
                        NoBlending: 0,
                        NormalBlending: 1,
                        AdditiveBlending: 2,
                        SubtractiveBlending: 3,
                        MultiplyBlending: 4,
                        CustomBlending: 5
                    },
                    e = new G,
                    i = new Pi,
                    n = new tn;
                return function(r, o, a) {
                    function s(t, e, n, r, s) {
                        t = o + t;
                        var l = nn.Handlers.get(t);
                        return null !== l ? t = l.load(t) : (i.setCrossOrigin(a), t = i.load(t)), void 0 !== e && (t.repeat.fromArray(e), 1 !== e[0] && (t.wrapS = 1e3), 1 !== e[1] && (t.wrapT = 1e3)), void 0 !== n && t.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (t.wrapS = 1e3), "mirror" === r[0] && (t.wrapS = 1002), "repeat" === r[1] && (t.wrapT = 1e3), "mirror" === r[1] && (t.wrapT = 1002)), void 0 !== s && (t.anisotropy = s), e = yr.generateUUID(), c[e] = t, e
                    }
                    var l, c = {},
                        h = {
                            uuid: yr.generateUUID(),
                            type: "MeshLambertMaterial"
                        };
                    for (l in r) {
                        var u = r[l];
                        switch (l) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                h.name = u;
                                break;
                            case "blending":
                                h.blending = t[u];
                                break;
                            case "colorAmbient":
                            case "mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                                break;
                            case "colorDiffuse":
                                h.color = e.fromArray(u).getHex();
                                break;
                            case "colorSpecular":
                                h.specular = e.fromArray(u).getHex();
                                break;
                            case "colorEmissive":
                                h.emissive = e.fromArray(u).getHex();
                                break;
                            case "specularCoef":
                                h.shininess = u;
                                break;
                            case "shading":
                                "basic" === u.toLowerCase() && (h.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (h.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (h.type = "MeshStandardMaterial");
                                break;
                            case "mapDiffuse":
                                h.map = s(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                                break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                h.emissiveMap = s(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                                break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                h.lightMap = s(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                                break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                h.aoMap = s(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                                break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                h.bumpMap = s(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                                break;
                            case "mapBumpScale":
                                h.bumpScale = u;
                                break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                h.normalMap = s(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                                break;
                            case "mapNormalFactor":
                                h.normalScale = [u, u];
                                break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                h.specularMap = s(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                                break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                h.metalnessMap = s(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                                break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                h.roughnessMap = s(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                                break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                h.alphaMap = s(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                                break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                h.side = 1;
                                break;
                            case "doubleSided":
                                h.side = 2;
                                break;
                            case "transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), h.opacity = u;
                                break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                h[l] = u;
                                break;
                            case "vertexColors":
                                !0 === u && (h.vertexColors = 2), "face" === u && (h.vertexColors = 1);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", l, u)
                        }
                    }
                    return "MeshBasicMaterial" === h.type && delete h.emissive, "MeshPhongMaterial" !== h.type && delete h.specular, 1 > h.opacity && (h.transparent = !0), n.setTextures(c), n.parse(h)
                }
            }()
        }), Object.assign(rn.prototype, {
            load: function(t, e, i, n) {
                var r = this,
                    o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : nn.prototype.extractUrlBase(t),
                    a = new Si(this.manager);
                a.setResponseType("json"), a.setWithCredentials(this.withCredentials), a.load(t, function(i) {
                    var n = i.metadata;
                    if (void 0 !== n && (n = n.type, void 0 !== n)) {
                        if ("object" === n.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                        if ("scene" === n.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                    }
                    i = r.parse(i, o), e(i.geometry, i.materials)
                }, i, n)
            },
            setTexturePath: function(t) {
                this.texturePath = t
            },
            parse: function() {
                return function(t, e) {
                    void 0 !== t.data && (t = t.data), t.scale = void 0 !== t.scale ? 1 / t.scale : 1;
                    var n, o, a, s, c, h, u, d, p, f, m, g, v, y, _ = new wt,
                        x = t,
                        b = x.faces;
                    p = x.vertices;
                    var w = x.normals,
                        T = x.colors;
                    h = x.scale;
                    var S = 0;
                    if (void 0 !== x.uvs) {
                        for (n = 0; n < x.uvs.length; n++) x.uvs[n].length && S++;
                        for (n = 0; n < S; n++) _.faceVertexUvs[n] = []
                    }
                    for (s = 0, c = p.length; s < c;) n = new l, n.x = p[s++] * h, n.y = p[s++] * h, n.z = p[s++] * h, _.vertices.push(n);
                    for (s = 0, c = b.length; s < c;)
                        if (p = b[s++], f = 1 & p, a = 2 & p, n = 8 & p, u = 16 & p, m = 32 & p, h = 64 & p, p &= 128, f) {
                            if (f = new lt, f.a = b[s], f.b = b[s + 1], f.c = b[s + 3], g = new lt, g.a = b[s + 1], g.b = b[s + 2], g.c = b[s + 3], s += 4, a && (a = b[s++], f.materialIndex = a, g.materialIndex = a), a = _.faces.length, n)
                                for (n = 0; n < S; n++)
                                    for (v = x.uvs[n], _.faceVertexUvs[n][a] = [], _.faceVertexUvs[n][a + 1] = [], o = 0; 4 > o; o++) d = b[s++], y = v[2 * d], d = v[2 * d + 1], y = new i(y, d), 2 !== o && _.faceVertexUvs[n][a].push(y), 0 !== o && _.faceVertexUvs[n][a + 1].push(y);
                            if (u && (u = 3 * b[s++], f.normal.set(w[u++], w[u++], w[u]), g.normal.copy(f.normal)), m)
                                for (n = 0; 4 > n; n++) u = 3 * b[s++], m = new l(w[u++], w[u++], w[u]), 2 !== n && f.vertexNormals.push(m), 0 !== n && g.vertexNormals.push(m);
                            if (h && (h = b[s++], h = T[h], f.color.setHex(h), g.color.setHex(h)), p)
                                for (n = 0; 4 > n; n++) h = b[s++], h = T[h], 2 !== n && f.vertexColors.push(new G(h)), 0 !== n && g.vertexColors.push(new G(h));
                            _.faces.push(f), _.faces.push(g)
                        } else {
                            if (f = new lt, f.a = b[s++], f.b = b[s++], f.c = b[s++], a && (a = b[s++], f.materialIndex = a), a = _.faces.length, n)
                                for (n = 0; n < S; n++)
                                    for (v = x.uvs[n], _.faceVertexUvs[n][a] = [], o = 0; 3 > o; o++) d = b[s++], y = v[2 * d], d = v[2 * d + 1], y = new i(y, d), _.faceVertexUvs[n][a].push(y);
                            if (u && (u = 3 * b[s++], f.normal.set(w[u++], w[u++], w[u])), m)
                                for (n = 0; 3 > n; n++) u = 3 * b[s++], m = new l(w[u++], w[u++], w[u]), f.vertexNormals.push(m);
                            if (h && (h = b[s++], f.color.setHex(T[h])), p)
                                for (n = 0; 3 > n; n++) h = b[s++], f.vertexColors.push(new G(T[h]));
                            _.faces.push(f)
                        }
                    if (x = t, s = void 0 !== x.influencesPerVertex ? x.influencesPerVertex : 2, x.skinWeights)
                        for (c = 0, b = x.skinWeights.length; c < b; c += s) _.skinWeights.push(new r(x.skinWeights[c], 1 < s ? x.skinWeights[c + 1] : 0, 2 < s ? x.skinWeights[c + 2] : 0, 3 < s ? x.skinWeights[c + 3] : 0));
                    if (x.skinIndices)
                        for (c = 0, b = x.skinIndices.length; c < b; c += s) _.skinIndices.push(new r(x.skinIndices[c], 1 < s ? x.skinIndices[c + 1] : 0, 2 < s ? x.skinIndices[c + 2] : 0, 3 < s ? x.skinIndices[c + 3] : 0));
                    if (_.bones = x.bones, _.bones && 0 < _.bones.length && (_.skinWeights.length !== _.skinIndices.length || _.skinIndices.length !== _.vertices.length) && console.warn("When skinning, number of vertices (" + _.vertices.length + "), skinIndices (" + _.skinIndices.length + "), and skinWeights (" + _.skinWeights.length + ") should match."), c = t, b = c.scale, void 0 !== c.morphTargets)
                        for (x = 0, s = c.morphTargets.length; x < s; x++)
                            for (_.morphTargets[x] = {}, _.morphTargets[x].name = c.morphTargets[x].name, _.morphTargets[x].vertices = [], w = _.morphTargets[x].vertices, T = c.morphTargets[x].vertices, S = 0, p = T.length; S < p; S += 3) h = new l, h.x = T[S] * b, h.y = T[S + 1] * b, h.z = T[S + 2] * b, w.push(h);
                    if (void 0 !== c.morphColors && 0 < c.morphColors.length)
                        for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), b = _.faces, c = c.morphColors[0].colors, x = 0, s = b.length; x < s; x++) b[x].color.fromArray(c, 3 * x);
                    for (c = t, x = [], s = [], void 0 !== c.animation && s.push(c.animation), void 0 !== c.animations && (c.animations.length ? s = s.concat(c.animations) : s.push(c.animations)), c = 0; c < s.length; c++)(b = Ki.parseAnimation(s[c], _.bones)) && x.push(b);
                    return _.morphTargets && (s = Ki.CreateClipsFromMorphTargetSequences(_.morphTargets, 10), x = x.concat(s)), 0 < x.length && (_.animations = x), _.computeFaceNormals(), _.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length ? {
                        geometry: _
                    } : (x = nn.prototype.initMaterials(t.materials, e, this.crossOrigin), {
                        geometry: _,
                        materials: x
                    })
                }
            }()
        }), Object.assign(on.prototype, {
            load: function(t, e, i, n) {
                "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
                var r = this;
                new Si(r.manager).load(t, function(i) {
                    var o = null;
                    try {
                        o = JSON.parse(i)
                    } catch (e) {
                        return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                    }
                    i = o.metadata, void 0 === i || void 0 === i.type || "geometry" === i.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.") : r.parse(o, e)
                }, i, n)
            },
            setTexturePath: function(t) {
                this.texturePath = t
            },
            setCrossOrigin: function(t) {
                this.crossOrigin = t
            },
            parse: function(t, e) {
                var i = this.parseGeometries(t.geometries),
                    n = this.parseImages(t.images, function() {
                        void 0 !== e && e(r)
                    }),
                    n = this.parseTextures(t.textures, n),
                    n = this.parseMaterials(t.materials, n),
                    r = this.parseObject(t.object, i, n);
                return t.animations && (r.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 === e || e(r), r
            },
            parseGeometries: function(t) {
                var e = {};
                if (void 0 !== t)
                    for (var i = new rn, n = new en, r = 0, o = t.length; r < o; r++) {
                        var a, s = t[r];
                        switch (s.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                a = new Br[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                a = new Br[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                a = new Br[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                a = new Br[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                a = new Br[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                a = new Br[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "IcosahedronGeometry":
                            case "OctahedronGeometry":
                            case "TetrahedronGeometry":
                                a = new Br[s.type](s.radius, s.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                a = new Br[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                a = new Br[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                a = new Br[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                a = new Br[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                break;
                            case "BufferGeometry":
                                a = n.parse(s);
                                break;
                            case "Geometry":
                                a = i.parse(s, this.texturePath).geometry;
                                break;
                            default:
                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                continue
                        }
                        a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), e[s.uuid] = a
                    }
                return e
            },
            parseMaterials: function(t, e) {
                var i = {};
                if (void 0 !== t) {
                    var n = new tn;
                    n.setTextures(e);
                    for (var r = 0, o = t.length; r < o; r++) {
                        var a = t[r];
                        if ("MultiMaterial" === a.type) {
                            for (var s = [], l = 0; l < a.materials.length; l++) s.push(n.parse(a.materials[l]));
                            i[a.uuid] = s
                        } else i[a.uuid] = n.parse(a)
                    }
                }
                return i
            },
            parseAnimations: function(t) {
                for (var e = [], i = 0; i < t.length; i++) {
                    var n = Ki.parse(t[i]);
                    e.push(n)
                }
                return e
            },
            parseImages: function(t, e) {
                function i(t) {
                    return n.manager.itemStart(t), a.load(t, function() {
                        n.manager.itemEnd(t)
                    }, void 0, function() {
                        n.manager.itemEnd(t), n.manager.itemError(t)
                    })
                }
                var n = this,
                    r = {};
                if (void 0 !== t && 0 < t.length) {
                    var o = new Ti(e),
                        a = new Ai(o);
                    a.setCrossOrigin(this.crossOrigin);
                    for (var o = 0, s = t.length; o < s; o++) {
                        var l = t[o],
                            c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : n.texturePath + l.url;
                        r[l.uuid] = i(c)
                    }
                }
                return r
            },
            parseTextures: function(t, e) {
                function i(t, e) {
                    return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                }
                var r = {};
                if (void 0 !== t)
                    for (var o = 0, a = t.length; o < a; o++) {
                        var s = t[o];
                        void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                        var l = new n(e[s.image]);
                        l.needsUpdate = !0, l.uuid = s.uuid, void 0 !== s.name && (l.name = s.name), void 0 !== s.mapping && (l.mapping = i(s.mapping, Vr)), void 0 !== s.offset && l.offset.fromArray(s.offset), void 0 !== s.repeat && l.repeat.fromArray(s.repeat), void 0 !== s.wrap && (l.wrapS = i(s.wrap[0], Wr), l.wrapT = i(s.wrap[1], Wr)), void 0 !== s.minFilter && (l.minFilter = i(s.minFilter, Xr)), void 0 !== s.magFilter && (l.magFilter = i(s.magFilter, Xr)), void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy), void 0 !== s.flipY && (l.flipY = s.flipY), r[s.uuid] = l
                    }
                return r
            },
            parseObject: function() {
                var t = new c;
                return function(e, i, n) {
                    function r(t) {
                        return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), i[t]
                    }

                    function o(t) {
                        if (void 0 !== t) {
                            if (Array.isArray(t)) {
                                for (var e = [], i = 0, r = t.length; i < r; i++) {
                                    var o = t[i];
                                    void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(n[o])
                                }
                                return e
                            }
                            return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                        }
                    }
                    var a;
                    switch (e.type) {
                        case "Scene":
                            a = new ue, void 0 !== e.background && Number.isInteger(e.background) && (a.background = new G(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new he(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new ce(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            a = new Rt(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (a.focus = e.focus), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            a = new Lt(e.left, e.right, e.top, e.bottom, e.near, e.far);
                            break;
                        case "AmbientLight":
                            a = new Ui(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            a = new Bi(e.color, e.intensity);
                            break;
                        case "PointLight":
                            a = new Ii(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            a = new Fi(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            a = new Di(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            a = new Li(e.color, e.groundColor, e.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            a = r(e.geometry);
                            var s = o(e.material);
                            a = a.bones && 0 < a.bones.length ? new ye(a, s) : new St(a, s);
                            break;
                        case "LOD":
                            a = new me;
                            break;
                        case "Line":
                            a = new xe(r(e.geometry), o(e.material), e.mode);
                            break;
                        case "LineLoop":
                            a = new we(r(e.geometry), o(e.material));
                            break;
                        case "LineSegments":
                            a = new be(r(e.geometry), o(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            a = new Se(r(e.geometry), o(e.material));
                            break;
                        case "Sprite":
                            a = new fe(o(e.material));
                            break;
                        case "Group":
                            a = new Me;
                            break;
                        default:
                            a = new ot
                    }
                    if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (t.fromArray(e.matrix), t.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion), void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.castShadow && (a.castShadow = e.castShadow), void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.children)
                        for (var l in e.children) a.add(this.parseObject(e.children[l], i, n));
                    if ("LOD" === e.type)
                        for (e = e.levels, s = 0; s < e.length; s++) {
                            var c = e[s];
                            l = a.getObjectByProperty("uuid", c.object), void 0 !== l && a.addLevel(l, c.distance)
                        }
                    return a
                }
            }()
        });
        var Vr = {
                UVMapping: 300,
                CubeReflectionMapping: 301,
                CubeRefractionMapping: 302,
                EquirectangularReflectionMapping: 303,
                EquirectangularRefractionMapping: 304,
                SphericalReflectionMapping: 305,
                CubeUVReflectionMapping: 306,
                CubeUVRefractionMapping: 307
            },
            Wr = {
                RepeatWrapping: 1e3,
                ClampToEdgeWrapping: 1001,
                MirroredRepeatWrapping: 1002
            },
            Xr = {
                NearestFilter: 1003,
                NearestMipMapNearestFilter: 1004,
                NearestMipMapLinearFilter: 1005,
                LinearFilter: 1006,
                LinearMipMapNearestFilter: 1007,
                LinearMipMapLinearFilter: 1008
            };
        Object.assign(cn.prototype, {
            getPoint: function() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            },
            getPointAt: function(t) {
                return t = this.getUtoTmapping(t), this.getPoint(t)
            },
            getPoints: function(t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return e
            },
            getSpacedPoints: function(t) {
                void 0 === t && (t = 5);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                return e
            },
            getLength: function() {
                var t = this.getLengths();
                return t[t.length - 1]
            },
            getLengths: function(t) {
                if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var e, i, n = [],
                    r = this.getPoint(0),
                    o = 0;
                for (n.push(0), i = 1; i <= t; i++) e = this.getPoint(i / t), o += e.distanceTo(r), n.push(o), r = e;
                return this.cacheArcLengths = n
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function(t, e) {
                var i, n, r = this.getLengths(),
                    o = r.length;
                n = e ? e : t * r[o - 1];
                for (var a, s = 0, l = o - 1; s <= l;)
                    if (i = Math.floor(s + (l - s) / 2), a = r[i] - n, 0 > a) s = i + 1;
                    else {
                        if (!(0 < a)) {
                            l = i;
                            break
                        }
                        l = i - 1
                    }
                return i = l, r[i] === n ? i / (o - 1) : (s = r[i], (i + (n - s) / (r[i + 1] - s)) / (o - 1))
            },
            getTangent: function(t) {
                var e = t - 1e-4;
                return t += 1e-4, 0 > e && (e = 0), 1 < t && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize()
            },
            getTangentAt: function(t) {
                return t = this.getUtoTmapping(t), this.getTangent(t)
            },
            computeFrenetFrames: function(t, e) {
                var i, n, r = new l,
                    o = [],
                    a = [],
                    s = [],
                    h = new l,
                    u = new c;
                for (i = 0; i <= t; i++) n = i / t, o[i] = this.getTangentAt(n), o[i].normalize();
                a[0] = new l, s[0] = new l, i = Number.MAX_VALUE, n = Math.abs(o[0].x);
                var d = Math.abs(o[0].y),
                    p = Math.abs(o[0].z);
                for (n <= i && (i = n, r.set(1, 0, 0)), d <= i && (i = d, r.set(0, 1, 0)), p <= i && r.set(0, 0, 1), h.crossVectors(o[0], r).normalize(), a[0].crossVectors(o[0], h), s[0].crossVectors(o[0], a[0]), i = 1; i <= t; i++) a[i] = a[i - 1].clone(), s[i] = s[i - 1].clone(), h.crossVectors(o[i - 1], o[i]), h.length() > Number.EPSILON && (h.normalize(), r = Math.acos(yr.clamp(o[i - 1].dot(o[i]), -1, 1)), a[i].applyMatrix4(u.makeRotationAxis(h, r))), s[i].crossVectors(o[i], a[i]);
                if (!0 === e)
                    for (r = Math.acos(yr.clamp(a[0].dot(a[t]), -1, 1)), r /= t, 0 < o[0].dot(h.crossVectors(a[0], a[t])) && (r = -r), i = 1; i <= t; i++) a[i].applyMatrix4(u.makeRotationAxis(o[i], r * i)), s[i].crossVectors(o[i], a[i]);
                return {
                    tangents: o,
                    normals: a,
                    binormals: s
                }
            }
        }), hn.prototype = Object.create(cn.prototype), hn.prototype.constructor = hn, hn.prototype.isLineCurve = !0, hn.prototype.getPoint = function(t) {
            if (1 === t) return this.v2.clone();
            var e = this.v2.clone().sub(this.v1);
            return e.multiplyScalar(t).add(this.v1), e
        }, hn.prototype.getPointAt = function(t) {
            return this.getPoint(t)
        }, hn.prototype.getTangent = function(t) {
            return this.v2.clone().sub(this.v1).normalize()
        }, un.prototype = Object.assign(Object.create(cn.prototype), {
            constructor: un,
            add: function(t) {
                this.curves.push(t)
            },
            closePath: function() {
                var t = this.curves[0].getPoint(0),
                    e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new hn(e, t))
            },
            getPoint: function(t) {
                var e = t * this.getLength(),
                    i = this.getCurveLengths();
                for (t = 0; t < i.length;) {
                    if (i[t] >= e) return e = i[t] - e, t = this.curves[t], i = t.getLength(), t.getPointAt(0 === i ? 0 : 1 - e / i);
                    t++
                }
                return null
            },
            getLength: function() {
                var t = this.getCurveLengths();
                return t[t.length - 1]
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
            },
            getCurveLengths: function() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                return this.cacheLengths = t
            },
            getSpacedPoints: function(t) {
                void 0 === t && (t = 40);
                for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                return this.autoClose && e.push(e[0]), e
            },
            getPoints: function(t) {
                t = t || 12;
                for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
                    for (var o = r[n], o = o.getPoints(o && o.isEllipseCurve ? 2 * t : o && o.isLineCurve ? 1 : o && o.isSplineCurve ? t * o.points.length : t), a = 0; a < o.length; a++) {
                        var s = o[a];
                        e && e.equals(s) || (i.push(s), e = s)
                    }
                return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
            },
            createPointsGeometry: function(t) {
                return t = this.getPoints(t), this.createGeometry(t)
            },
            createSpacedPointsGeometry: function(t) {
                return t = this.getSpacedPoints(t), this.createGeometry(t)
            },
            createGeometry: function(t) {
                for (var e = new wt, i = 0, n = t.length; i < n; i++) {
                    var r = t[i];
                    e.vertices.push(new l(r.x, r.y, r.z || 0))
                }
                return e
            }
        }), dn.prototype = Object.create(cn.prototype), dn.prototype.constructor = dn, dn.prototype.isEllipseCurve = !0, dn.prototype.getPoint = function(t) {
            for (var e = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, r = Math.abs(n) < Number.EPSILON; 0 > n;) n += e;
            for (; n > e;) n -= e;
            n < Number.EPSILON && (n = r ? 0 : e), !0 !== this.aClockwise || r || (n = n === e ? -e : n - e), e = this.aStartAngle + t * n, t = this.aX + this.xRadius * Math.cos(e);
            var o = this.aY + this.yRadius * Math.sin(e);
            return 0 !== this.aRotation && (e = Math.cos(this.aRotation), n = Math.sin(this.aRotation), r = t - this.aX, o -= this.aY, t = r * e - o * n + this.aX, o = r * n + o * e + this.aY), new i(t, o)
        }, pn.prototype = Object.create(cn.prototype), pn.prototype.constructor = pn, pn.prototype.isSplineCurve = !0, pn.prototype.getPoint = function(t) {
            var e = this.points,
                n = (e.length - 1) * t;
            t = Math.floor(n);
            var n = n - t,
                r = e[0 === t ? t : t - 1],
                o = e[t],
                a = e[t > e.length - 2 ? e.length - 1 : t + 1],
                e = e[t > e.length - 3 ? e.length - 1 : t + 2];
            return new i(an(n, r.x, o.x, a.x, e.x), an(n, r.y, o.y, a.y, e.y))
        }, fn.prototype = Object.create(cn.prototype), fn.prototype.constructor = fn, fn.prototype.getPoint = function(t) {
            var e = this.v0,
                n = this.v1,
                r = this.v2,
                o = this.v3;
            return new i(ln(t, e.x, n.x, r.x, o.x), ln(t, e.y, n.y, r.y, o.y))
        }, mn.prototype = Object.create(cn.prototype), mn.prototype.constructor = mn, mn.prototype.getPoint = function(t) {
            var e = this.v0,
                n = this.v1,
                r = this.v2;
            return new i(sn(t, e.x, n.x, r.x), sn(t, e.y, n.y, r.y))
        };
        var qr = Object.assign(Object.create(un.prototype), {
            fromPoints: function(t) {
                this.moveTo(t[0].x, t[0].y);
                for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
            },
            moveTo: function(t, e) {
                this.currentPoint.set(t, e)
            },
            lineTo: function(t, e) {
                var n = new hn(this.currentPoint.clone(), new i(t, e));
                this.curves.push(n), this.currentPoint.set(t, e)
            },
            quadraticCurveTo: function(t, e, n, r) {
                t = new mn(this.currentPoint.clone(), new i(t, e), new i(n, r)), this.curves.push(t), this.currentPoint.set(n, r)
            },
            bezierCurveTo: function(t, e, n, r, o, a) {
                t = new fn(this.currentPoint.clone(), new i(t, e), new i(n, r), new i(o, a)), this.curves.push(t), this.currentPoint.set(o, a)
            },
            splineThru: function(t) {
                var e = [this.currentPoint.clone()].concat(t),
                    e = new pn(e);
                this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
            },
            arc: function(t, e, i, n, r, o) {
                this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, o)
            },
            absarc: function(t, e, i, n, r, o) {
                this.absellipse(t, e, i, i, n, r, o)
            },
            ellipse: function(t, e, i, n, r, o, a, s) {
                this.absellipse(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, o, a, s)
            },
            absellipse: function(t, e, i, n, r, o, a, s) {
                t = new dn(t, e, i, n, r, o, a, s), 0 < this.curves.length && (e = t.getPoint(0), e.equals(this.currentPoint) || this.lineTo(e.x, e.y)), this.curves.push(t), t = t.getPoint(1), this.currentPoint.copy(t)
            }
        });
        gn.prototype = qr, qr.constructor = gn, vn.prototype = Object.assign(Object.create(qr), {
            constructor: vn,
            getPointsHoles: function(t) {
                for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                return e
            },
            extractAllPoints: function(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            },
            extractPoints: function(t) {
                return this.extractAllPoints(t)
            }
        }), Object.assign(yn.prototype, {
            moveTo: function(t, e) {
                this.currentPath = new gn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
            },
            lineTo: function(t, e) {
                this.currentPath.lineTo(t, e)
            },
            quadraticCurveTo: function(t, e, i, n) {
                this.currentPath.quadraticCurveTo(t, e, i, n)
            },
            bezierCurveTo: function(t, e, i, n, r, o) {
                this.currentPath.bezierCurveTo(t, e, i, n, r, o)
            },
            splineThru: function(t) {
                this.currentPath.splineThru(t)
            },
            toShapes: function(t, e) {
                function i(t) {
                    for (var e = [], i = 0, n = t.length; i < n; i++) {
                        var r = t[i],
                            o = new vn;
                        o.curves = r.curves, e.push(o)
                    }
                    return e
                }

                function n(t, e) {
                    for (var i = e.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
                        var a = e[r],
                            s = e[o],
                            l = s.x - a.x,
                            c = s.y - a.y;
                        if (Math.abs(c) > Number.EPSILON) {
                            if (0 > c && (a = e[o], l = -l, s = e[r], c = -c), !(t.y < a.y || t.y > s.y))
                                if (t.y === a.y) {
                                    if (t.x === a.x) return !0
                                } else {
                                    if (r = c * (t.x - a.x) - l * (t.y - a.y), 0 === r) return !0;
                                    0 > r || (n = !n)
                                }
                        } else if (t.y === a.y && (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x)) return !0
                    }
                    return n
                }
                var r = Nr.isClockWise,
                    o = this.subPaths;
                if (0 === o.length) return [];
                if (!0 === e) return i(o);
                var a, s, l, c = [];
                if (1 === o.length) return s = o[0], l = new vn, l.curves = s.curves, c.push(l), c;
                var h = !r(o[0].getPoints()),
                    h = t ? !h : h;
                l = [];
                var u, d = [],
                    p = [],
                    f = 0;
                d[f] = void 0, p[f] = [];
                for (var m = 0, g = o.length; m < g; m++) s = o[m], u = s.getPoints(), a = r(u), (a = t ? !a : a) ? (!h && d[f] && f++, d[f] = {
                    s: new vn,
                    p: u
                }, d[f].s.curves = s.curves, h && f++, p[f] = []) : p[f].push({
                    h: s,
                    p: u[0]
                });
                if (!d[0]) return i(o);
                if (1 < d.length) {
                    for (m = !1, s = [], r = 0, o = d.length; r < o; r++) l[r] = [];
                    for (r = 0, o = d.length; r < o; r++)
                        for (a = p[r], h = 0; h < a.length; h++) {
                            for (f = a[h], u = !0, g = 0; g < d.length; g++) n(f.p, d[g].p) && (r !== g && s.push({
                                froms: r,
                                tos: g,
                                hole: h
                            }), u ? (u = !1, l[g].push(f)) : m = !0);
                            u && l[r].push(f)
                        }
                    0 < s.length && (m || (p = l))
                }
                for (m = 0, r = d.length; m < r; m++)
                    for (l = d[m].s, c.push(l), s = p[m], o = 0, a = s.length; o < a; o++) l.holes.push(s[o].h);
                return c
            }
        }), Object.assign(_n.prototype, {
            isFont: !0,
            generateShapes: function(t, e, i) {
                void 0 === e && (e = 100), void 0 === i && (i = 4);
                var n = this.data;
                t = String(t).split("");
                var r = e / n.resolution,
                    o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                    a = 0,
                    s = 0;
                e = [];
                for (var l = 0; l < t.length; l++) {
                    var c = t[l];
                    if ("\n" === c) a = 0, s -= o;
                    else {
                        var h;
                        h = r;
                        var u = a,
                            d = s;
                        if (c = n.glyphs[c] || n.glyphs["?"]) {
                            var p, f, m, g, v, y, _, x, b = new yn,
                                w = [];
                            if (c.o)
                                for (var T = c._cachedOutline || (c._cachedOutline = c.o.split(" ")), S = 0, M = T.length; S < M;) switch (T[S++]) {
                                    case "m":
                                        p = T[S++] * h + u, f = T[S++] * h + d, b.moveTo(p, f);
                                        break;
                                    case "l":
                                        p = T[S++] * h + u, f = T[S++] * h + d, b.lineTo(p, f);
                                        break;
                                    case "q":
                                        if (p = T[S++] * h + u, f = T[S++] * h + d, v = T[S++] * h + u, y = T[S++] * h + d, b.quadraticCurveTo(v, y, p, f), g = w[w.length - 1]) {
                                            m = g.x, g = g.y;
                                            for (var E = 1; E <= i; E++) {
                                                var A = E / i;
                                                sn(A, m, v, p), sn(A, g, y, f)
                                            }
                                        }
                                        break;
                                    case "b":
                                        if (p = T[S++] * h + u, f = T[S++] * h + d, v = T[S++] * h + u, y = T[S++] * h + d, _ = T[S++] * h + u, x = T[S++] * h + d, b.bezierCurveTo(v, y, _, x, p, f), g = w[w.length - 1])
                                            for (m = g.x, g = g.y, E = 1; E <= i; E++) A = E / i, ln(A, m, v, _, p), ln(A, g, y, x, f)
                                }
                            h = {
                                offsetX: c.ha * h,
                                path: b
                            }
                        } else h = void 0;
                        a += h.offsetX, e.push(h.path)
                    }
                }
                for (i = [], n = 0, t = e.length; n < t; n++) Array.prototype.push.apply(i, e[n].toShapes());
                return i
            }
        }), Object.assign(xn.prototype, {
            load: function(t, e, i, n) {
                var r = this;
                new Si(this.manager).load(t, function(t) {
                    var i;
                    try {
                        i = JSON.parse(t)
                    } catch (e) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2))
                    }
                    t = r.parse(i), e && e(t)
                }, i, n)
            },
            parse: function(t) {
                return new _n(t)
            }
        });
        var $r, Yr = {
            getContext: function() {
                return void 0 === $r && ($r = new(window.AudioContext || window.webkitAudioContext)), $r
            },
            setContext: function(t) {
                $r = t
            }
        };
        Object.assign(bn.prototype, {
            load: function(t, e, i, n) {
                var r = new Si(this.manager);
                r.setResponseType("arraybuffer"), r.load(t, function(t) {
                    Yr.getContext().decodeAudioData(t, function(t) {
                        e(t)
                    })
                }, i, n)
            }
        }), Object.assign(wn.prototype, {
            update: function() {
                var t, e, i, n, r, o, a, s, l = new c,
                    h = new c;
                return function(c) {
                    if (t !== this || e !== c.focus || i !== c.fov || n !== c.aspect * this.aspect || r !== c.near || o !== c.far || a !== c.zoom || s !== this.eyeSep) {
                        t = this, e = c.focus, i = c.fov, n = c.aspect * this.aspect, r = c.near, o = c.far, a = c.zoom;
                        var u = c.projectionMatrix.clone();
                        s = this.eyeSep / 2;
                        var d, p, f = s * r / e,
                            m = r * Math.tan(yr.DEG2RAD * i * .5) / a;
                        h.elements[12] = -s, l.elements[12] = s, d = -m * n + f, p = m * n + f, u.elements[0] = 2 * r / (p - d), u.elements[8] = (p + d) / (p - d), this.cameraL.projectionMatrix.copy(u), d = -m * n - f, p = m * n - f, u.elements[0] = 2 * r / (p - d), u.elements[8] = (p + d) / (p - d), this.cameraR.projectionMatrix.copy(u)
                    }
                    this.cameraL.matrixWorld.copy(c.matrixWorld).multiply(h), this.cameraR.matrixWorld.copy(c.matrixWorld).multiply(l)
                }
            }()
        }), Tn.prototype = Object.create(ot.prototype), Tn.prototype.constructor = Tn, Sn.prototype = Object.assign(Object.create(Rt.prototype), {
            constructor: Sn,
            isArrayCamera: !0
        }), Mn.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: Mn,
            getInput: function() {
                return this.gain
            },
            removeFilter: function() {
                null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
            },
            getFilter: function() {
                return this.filter
            },
            setFilter: function(t) {
                null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
            },
            getMasterVolume: function() {
                return this.gain.gain.value
            },
            setMasterVolume: function(t) {
                this.gain.gain.value = t
            },
            updateMatrixWorld: function() {
                var t = new l,
                    e = new s,
                    i = new l,
                    n = new l;
                return function(r) {
                    ot.prototype.updateMatrixWorld.call(this, r), r = this.context.listener;
                    var o = this.up;
                    this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), r.positionX ? (r.positionX.setValueAtTime(t.x, this.context.currentTime), r.positionY.setValueAtTime(t.y, this.context.currentTime), r.positionZ.setValueAtTime(t.z, this.context.currentTime), r.forwardX.setValueAtTime(n.x, this.context.currentTime), r.forwardY.setValueAtTime(n.y, this.context.currentTime), r.forwardZ.setValueAtTime(n.z, this.context.currentTime), r.upX.setValueAtTime(o.x, this.context.currentTime), r.upY.setValueAtTime(o.y, this.context.currentTime), r.upZ.setValueAtTime(o.z, this.context.currentTime)) : (r.setPosition(t.x, t.y, t.z), r.setOrientation(n.x, n.y, n.z, o.x, o.y, o.z))
                }
            }()
        }), En.prototype = Object.assign(Object.create(ot.prototype), {
            constructor: En,
            getOutput: function() {
                return this.gain
            },
            setNodeSource: function(t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            },
            setBuffer: function(t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            },
            play: function() {
                if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
                else {
                    if (!1 !== this.hasPlaybackControl) {
                        var t = this.context.createBufferSource();
                        return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), t.start(0, this.startTime), this.isPlaying = !0, this.source = t, this.connect()
                    }
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
            },
            pause: function() {
                return !1 !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this) : void console.warn("THREE.Audio: this Audio has no playback control.")
            },
            stop: function() {
                return !1 !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = 0, this.isPlaying = !1, this) : void console.warn("THREE.Audio: this Audio has no playback control.")
            },
            connect: function() {
                if (0 < this.filters.length) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function() {
                if (0 < this.filters.length) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function() {
                return this.filters
            },
            setFilters: function(t) {
                return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
            },
            getFilter: function() {
                return this.getFilters()[0]
            },
            setFilter: function(t) {
                return this.setFilters(t ? [t] : [])
            },
            setPlaybackRate: function(t) {
                return !1 !== this.hasPlaybackControl ? (this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this) : void console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getPlaybackRate: function() {
                return this.playbackRate
            },
            onEnded: function() {
                this.isPlaying = !1
            },
            getLoop: function() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            },
            setLoop: function(t) {
                return !1 !== this.hasPlaybackControl ? (this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this) : void console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getVolume: function() {
                return this.gain.gain.value
            },
            setVolume: function(t) {
                return this.gain.gain.value = t, this
            }
        }), An.prototype = Object.assign(Object.create(En.prototype), {
            constructor: An,
            getOutput: function() {
                return this.panner
            },
            getRefDistance: function() {
                return this.panner.refDistance
            },
            setRefDistance: function(t) {
                this.panner.refDistance = t
            },
            getRolloffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function(t) {
                this.panner.rolloffFactor = t
            },
            getDistanceModel: function() {
                return this.panner.distanceModel
            },
            setDistanceModel: function(t) {
                this.panner.distanceModel = t
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(t) {
                this.panner.maxDistance = t
            },
            updateMatrixWorld: function() {
                var t = new l;
                return function(e) {
                    ot.prototype.updateMatrixWorld.call(this, e), t.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(t.x, t.y, t.z)
                }
            }()
        }), Object.assign(Cn.prototype, {
            getFrequencyData: function() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            },
            getAverageFrequency: function() {
                for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                return t / e.length
            }
        }), Object.assign(Pn.prototype, {
            accumulate: function(t, e) {
                var i = this.buffer,
                    n = this.valueSize,
                    r = t * n + n,
                    o = this.cumulativeWeight;
                if (0 === o) {
                    for (o = 0; o !== n; ++o) i[r + o] = i[o];
                    o = e
                } else o += e, this._mixBufferRegion(i, r, 0, e / o, n);
                this.cumulativeWeight = o
            },
            apply: function(t) {
                var e = this.valueSize,
                    i = this.buffer;
                t = t * e + e;
                var n = this.cumulativeWeight,
                    r = this.binding;
                this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, t, 3 * e, 1 - n, e);
                for (var n = e, o = e + e; n !== o; ++n)
                    if (i[n] !== i[n + e]) {
                        r.setValue(i, t);
                        break
                    }
            },
            saveOriginalState: function() {
                var t = this.buffer,
                    e = this.valueSize,
                    i = 3 * e;
                this.binding.getValue(t, i);
                for (var n = e; n !== i; ++n) t[n] = t[i + n % e];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function() {
                this.binding.setValue(this.buffer, 3 * this.valueSize)
            },
            _select: function(t, e, i, n, r) {
                if (.5 <= n)
                    for (n = 0; n !== r; ++n) t[e + n] = t[i + n]
            },
            _slerp: function(t, e, i, n) {
                s.slerpFlat(t, e, t, e, t, i, n)
            },
            _lerp: function(t, e, i, n, r) {
                for (var o = 1 - n, a = 0; a !== r; ++a) {
                    var s = e + a;
                    t[s] = t[s] * o + t[i + a] * n
                }
            }
        }), Object.assign(Rn.prototype, {
            getValue: function(t, e) {
                this.bind();
                var i = this._bindings[this._targetGroup.nCachedObjects_];
                void 0 !== i && i.getValue(t, e)
            },
            setValue: function(t, e) {
                for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
            },
            bind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
            },
            unbind: function() {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
            }
        }), Object.assign(Ln, {
            Composite: Rn,
            create: function(t, e, i) {
                return t && t.isAnimationObjectGroup ? new Ln.Composite(t, e, i) : new Ln(t, e, i)
            },
            parseTrackName: function() {
                var t = new RegExp("^" + /((?:[\w-]+[\/:])*)/.source + /([\w-\.]+)?/.source + /(?:\.([\w-]+)(?:\[(.+)\])?)?/.source + /\.([\w-]+)(?:\[(.+)\])?/.source + "$"),
                    e = ["material", "materials", "bones"];
                return function(i) {
                    var n = t.exec(i);
                    if (!n) throw Error("PropertyBinding: Cannot parse trackName: " + i);
                    var n = {
                            nodeName: n[2],
                            objectName: n[3],
                            objectIndex: n[4],
                            propertyName: n[5],
                            propertyIndex: n[6]
                        },
                        r = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== r && -1 !== r) {
                        var o = n.nodeName.substring(r + 1); - 1 !== e.indexOf(o) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = o)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + i);
                    return n
                }
            }(),
            findNode: function(t, e) {
                if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    var i = function(t) {
                        for (var i = 0; i < t.bones.length; i++) {
                            var n = t.bones[i];
                            if (n.name === e) return n
                        }
                        return null
                    }(t.skeleton);
                    if (i) return i
                }
                if (t.children) {
                    var n = function(t) {
                        for (var i = 0; i < t.length; i++) {
                            var r = t[i];
                            if (r.name === e || r.uuid === e || (r = n(r.children))) return r
                        }
                        return null
                    };
                    if (i = n(t.children)) return i
                }
                return null
            }
        }), Object.assign(Ln.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(t, e) {
                t[e] = this.node[this.propertyName]
            }, function(t, e) {
                for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
            }, function(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function(t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(t, e) {
                    this.node[this.propertyName] = t[e]
                }, function(t, e) {
                    this.node[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.node[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }, function(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ],
            getValue: function(t, e) {
                this.bind(), this.getValue(t, e)
            },
            setValue: function(t, e) {
                this.bind(), this.setValue(t, e)
            },
            bind: function() {
                var t = this.node,
                    e = this.parsedPath,
                    i = e.objectName,
                    n = e.propertyName,
                    r = e.propertyIndex;
                if (t || (this.node = t = Ln.findNode(this.rootNode, e.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                    if (i) {
                        var o = e.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!t.material) return void console.error("  can not bind to material as node does not have a material", this);
                                if (!t.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this);
                                for (t = t.skeleton.bones, i = 0; i < t.length; i++)
                                    if (t[i].name === o) {
                                        o = i;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === t[i]) return void console.error("  can not bind to objectName of node, undefined", this);
                                t = t[i]
                        }
                        if (void 0 !== o) {
                            if (void 0 === t[o]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, t);
                            t = t[o]
                        }
                    }
                    if (o = t[n], void 0 === o) console.error("  trying to update property for track: " + e.nodeName + "." + n + " but it wasn't found.", t);
                    else {
                        if (e = this.Versioning.None, void 0 !== t.needsUpdate ? (e = this.Versioning.NeedsUpdate, this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (e = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t), i = this.BindingType.Direct, void 0 !== r) {
                            if ("morphTargetInfluences" === n) {
                                if (!t.geometry) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                                if (!t.geometry.morphTargets) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                                    if (t.geometry.morphTargets[i].name === r) {
                                        r = i;
                                        break
                                    }
                            }
                            i = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                        } else void 0 !== o.fromArray && void 0 !== o.toArray ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (i = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
                        this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][e]
                    }
                } else console.error("  trying to update node for track: " + this.path + " but it wasn't found.")
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }), Object.assign(Ln.prototype, {
            _getValue_unbound: Ln.prototype.getValue,
            _setValue_unbound: Ln.prototype.setValue
        }), Object.assign(kn.prototype, {
            isAnimationObjectGroup: !0,
            add: function(t) {
                for (var e = this._objects, i = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, o = this._paths, a = this._parsedPaths, s = this._bindings, l = s.length, c = 0, h = arguments.length; c !== h; ++c) {
                    var u = arguments[c],
                        d = u.uuid,
                        p = r[d];
                    if (void 0 === p) {
                        p = i++, r[d] = p, e.push(u);
                        for (var d = 0, f = l; d !== f; ++d) s[d].push(new Ln(u, o[d], a[d]))
                    } else if (p < n) {
                        var m = --n,
                            f = e[m];
                        for (r[f.uuid] = p, e[p] = f, r[d] = m, e[m] = u, d = 0, f = l; d !== f; ++d) {
                            var g = s[d],
                                v = g[p];
                            g[p] = g[m], void 0 === v && (v = new Ln(u, o[d], a[d])), g[m] = v
                        }
                    } else void 0 !== e[p] && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
                }
                this.nCachedObjects_ = n
            },
            remove: function(t) {
                for (var e = this._objects, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                    var l = arguments[a],
                        c = l.uuid,
                        h = n[c];
                    if (void 0 !== h && h >= i) {
                        var u = i++,
                            d = e[u];
                        for (n[d.uuid] = h, e[h] = d, n[c] = u, e[u] = l, l = 0, c = o; l !== c; ++l) {
                            var d = r[l],
                                p = d[h];
                            d[h] = d[u], d[u] = p
                        }
                    }
                }
                this.nCachedObjects_ = i
            },
            uncache: function(t) {
                for (var e = this._objects, i = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, o = this._bindings, a = o.length, s = 0, l = arguments.length; s !== l; ++s) {
                    var c = arguments[s].uuid,
                        h = r[c];
                    if (void 0 !== h)
                        if (delete r[c], h < n) {
                            var c = --n,
                                u = e[c],
                                d = --i,
                                p = e[d];
                            for (r[u.uuid] = h, e[h] = u, r[p.uuid] = c, e[c] = p, e.pop(), u = 0, p = a; u !== p; ++u) {
                                var f = o[u],
                                    m = f[d];
                                f[h] = f[c], f[c] = m, f.pop()
                            }
                        } else
                            for (d = --i, p = e[d], r[p.uuid] = h, e[h] = p, e.pop(), u = 0, p = a; u !== p; ++u) f = o[u], f[h] = f[d], f.pop()
                }
                this.nCachedObjects_ = n
            },
            subscribe_: function(t, e) {
                var i = this._bindingsIndicesByPath,
                    n = i[t],
                    r = this._bindings;
                if (void 0 !== n) return r[n];
                var o = this._paths,
                    a = this._parsedPaths,
                    s = this._objects,
                    l = this.nCachedObjects_,
                    c = Array(s.length),
                    n = r.length;
                for (i[t] = n, o.push(t), a.push(e), r.push(c), i = l, n = s.length; i !== n; ++i) c[i] = new Ln(s[i], t, e);
                return c
            },
            unsubscribe_: function(t) {
                var e = this._bindingsIndicesByPath,
                    i = e[t];
                if (void 0 !== i) {
                    var n = this._paths,
                        r = this._parsedPaths,
                        o = this._bindings,
                        a = o.length - 1,
                        s = o[a];
                    e[t[a]] = i, o[i] = s, o.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop()
                }
            }
        }), Object.assign(On.prototype, {
            play: function() {
                return this._mixer._activateAction(this), this
            },
            stop: function() {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(t) {
                return this._startTime = t, this
            },
            setLoop: function(t, e) {
                return this.loop = t, this.repetitions = e, this
            },
            setEffectiveWeight: function(t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(t) {
                return this._scheduleFading(t, 0, 1)
            },
            fadeOut: function(t) {
                return this._scheduleFading(t, 1, 0)
            },
            crossFadeFrom: function(t, e, i) {
                if (t.fadeOut(e), this.fadeIn(e), i) {
                    i = this._clip.duration;
                    var n = t._clip.duration,
                        r = i / n;
                    t.warp(1, n / i, e), this.warp(r, 1, e)
                }
                return this
            },
            crossFadeTo: function(t, e, i) {
                return t.crossFadeFrom(this, e, i)
            },
            stopFading: function() {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            setEffectiveTimeScale: function(t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            },
            syncWith: function(t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            },
            halt: function(t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            },
            warp: function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    o = this._timeScaleInterpolant,
                    a = this.timeScale;
                return null === o && (this._timeScaleInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, n[1] = r + i, o[0] = t / a, o[1] = e / a, this
            },
            stopWarping: function() {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(t, e, i, n) {
                if (this.enabled) {
                    var r = this._startTime;
                    if (null !== r) {
                        if (e = (t - r) * i, 0 > e || 0 === i) return;
                        this._startTime = null, e *= i
                    }
                    if (e *= this._updateTimeScale(t), i = this._updateTime(e), t = this._updateWeight(t), 0 < t) {
                        e = this._interpolants;
                        for (var r = this._propertyBindings, o = 0, a = e.length; o !== a; ++o) e[o].evaluate(i), r[o].accumulate(n, t)
                    }
                } else this._updateWeight(t)
            },
            _updateWeight: function(t) {
                var e = 0;
                if (this.enabled) {
                    var e = this.weight,
                        i = this._weightInterpolant;
                    if (null !== i) {
                        var n = i.evaluate(t)[0],
                            e = e * n;
                        t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e
            },
            _updateTimeScale: function(t) {
                var e = 0;
                if (!this.paused) {
                    var e = this.timeScale,
                        i = this._timeScaleInterpolant;
                    if (null !== i) {
                        var n = i.evaluate(t)[0],
                            e = e * n;
                        t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                    }
                }
                return this._effectiveTimeScale = e
            },
            _updateTime: function(t) {
                var e = this.time + t;
                if (0 === t) return e;
                var i = this._clip.duration,
                    n = this.loop,
                    r = this._loopCount;
                if (2200 === n) t: {
                    if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), e >= i) e = i;
                    else {
                        if (!(0 > e)) break t;
                        e = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 > t ? -1 : 1
                    })
                }
                else {
                    if (n = 2202 === n, -1 === r && (0 <= t ? (r = 0, this._setEndings(!0, 0 === this.repetitions, n)) : this._setEndings(0 === this.repetitions, !0, n)), e >= i || 0 > e) {
                        var o = Math.floor(e / i),
                            e = e - i * o,
                            r = r + Math.abs(o),
                            a = this.repetitions - r;
                        0 > a ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = 0 < t ? i : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: 0 < t ? 1 : -1
                        })) : (0 === a ? (t = 0 > t, this._setEndings(t, !t, n)) : this._setEndings(!1, !1, n), this._loopCount = r, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: o
                        }))
                    }
                    if (n && 1 === (1 & r)) return this.time = e, i - e
                }
                return this.time = e
            },
            _setEndings: function(t, e, i) {
                var n = this._interpolantSettings;
                i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
            },
            _scheduleFading: function(t, e, i) {
                var n = this._mixer,
                    r = n.time,
                    o = this._weightInterpolant;
                return null === o && (this._weightInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, o[0] = e, n[1] = r + t, o[1] = i, this
            }
        }), Object.assign(Dn.prototype, e.prototype, {
            _bindAction: function(t, e) {
                var i = t._localRoot || this._root,
                    n = t._clip.tracks,
                    r = n.length,
                    o = t._propertyBindings,
                    a = t._interpolants,
                    s = i.uuid,
                    l = this._bindingsByRootAndName,
                    c = l[s];
                for (void 0 === c && (c = {}, l[s] = c), l = 0; l !== r; ++l) {
                    var h = n[l],
                        u = h.name,
                        d = c[u];
                    if (void 0 === d) {
                        if (d = o[l], void 0 !== d) {
                            null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, u));
                            continue
                        }
                        d = new Pn(Ln.create(i, u, e && e._propertyBindings[l].binding.parsedPath), h.ValueTypeName, h.getValueSize()), ++d.referenceCount, this._addInactiveBinding(d, s, u)
                    }
                    o[l] = d, a[l].resultBuffer = d.buffer
                }
            },
            _activateAction: function(t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        var e = (t._localRoot || this._root).uuid,
                            i = t._clip.uuid,
                            n = this._actionsByClip[i];
                        this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                    }
                    for (e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                        var r = e[i];
                        0 === r.useCount++ && (this._lendBinding(r), r.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            },
            _deactivateAction: function(t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                        var r = e[i];
                        0 === --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                    }
                    this._takeBackAction(t)
                }
            },
            _initMemoryManager: function() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        },
                        get inUse() {
                            return t._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return t._bindings.length
                        },
                        get inUse() {
                            return t._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        },
                        get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(t) {
                return t = t._cacheIndex, null !== t && t < this._nActiveActions
            },
            _addInactiveAction: function(t, e, i) {
                var n = this._actions,
                    r = this._actionsByClip,
                    o = r[e];
                void 0 === o ? (o = {
                    knownActions: [t],
                    actionByRoot: {}
                }, t._byClipCacheIndex = 0, r[e] = o) : (e = o.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = n.length, n.push(t), o.actionByRoot[i] = t
            },
            _removeInactiveAction: function(t) {
                var e = this._actions,
                    i = e[e.length - 1],
                    n = t._cacheIndex;
                i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
                var e = t._clip.uuid,
                    i = this._actionsByClip,
                    n = i[e],
                    r = n.knownActions,
                    o = r[r.length - 1],
                    a = t._byClipCacheIndex;
                o._byClipCacheIndex = a, r[a] = o, r.pop(), t._byClipCacheIndex = null, delete n.actionByRoot[(t._localRoot || this._root).uuid], 0 === r.length && delete i[e], this._removeInactiveBindingsForAction(t)
            },
            _removeInactiveBindingsForAction: function(t) {
                t = t._propertyBindings;
                for (var e = 0, i = t.length; e !== i; ++e) {
                    var n = t[e];
                    0 === --n.referenceCount && this._removeInactiveBinding(n)
                }
            },
            _lendAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = this._nActiveActions++,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _takeBackAction: function(t) {
                var e = this._actions,
                    i = t._cacheIndex,
                    n = --this._nActiveActions,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _addInactiveBinding: function(t, e, i) {
                var n = this._bindingsByRootAndName,
                    r = n[e],
                    o = this._bindings;
                void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = o.length, o.push(t)
            },
            _removeInactiveBinding: function(t) {
                var e = this._bindings,
                    i = t.binding,
                    n = i.rootNode.uuid,
                    i = i.path,
                    r = this._bindingsByRootAndName,
                    o = r[n],
                    a = e[e.length - 1];
                t = t._cacheIndex, a._cacheIndex = t, e[t] = a, e.pop(), delete o[i];
                t: {
                    for (var s in o) break t;delete r[n]
                }
            },
            _lendBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = this._nActiveBindings++,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _takeBackBinding: function(t) {
                var e = this._bindings,
                    i = t._cacheIndex,
                    n = --this._nActiveBindings,
                    r = e[n];
                t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
            },
            _lendControlInterpolant: function() {
                var t = this._controlInterpolants,
                    e = this._nActiveControlInterpolants++,
                    i = t[e];
                return void 0 === i && (i = new ji(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = e, t[e] = i), i
            },
            _takeBackControlInterpolant: function(t) {
                var e = this._controlInterpolants,
                    i = t.__cacheIndex,
                    n = --this._nActiveControlInterpolants,
                    r = e[n];
                t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
            },
            _controlInterpolantsResultBuffer: new Float32Array(1),
            clipAction: function(t, e) {
                var i = e || this._root,
                    n = i.uuid,
                    r = "string" == typeof t ? Ki.findByName(i, t) : t,
                    i = null !== r ? r.uuid : t,
                    o = this._actionsByClip[i],
                    a = null;
                if (void 0 !== o) {
                    if (a = o.actionByRoot[n], void 0 !== a) return a;
                    a = o.knownActions[0], null === r && (r = a._clip)
                }
                return null === r ? null : (r = new On(this, r, e), this._bindAction(r, a), this._addInactiveAction(r, i, n), r)
            },
            existingAction: function(t, e) {
                var i = e || this._root,
                    n = i.uuid,
                    i = "string" == typeof t ? Ki.findByName(i, t) : t,
                    i = this._actionsByClip[i ? i.uuid : t];
                return void 0 !== i ? i.actionByRoot[n] || null : null
            },
            stopAllAction: function() {
                for (var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== e; ++r) t[r].reset();
                for (r = 0; r !== n; ++r) i[r].useCount = 0;
                return this
            },
            update: function(t) {
                t *= this.timeScale;
                for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== i; ++a) e[a]._update(n, t, r, o);
                for (t = this._bindings, e = this._nActiveBindings, a = 0; a !== e; ++a) t[a].apply(o);
                return this
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(t) {
                var e = this._actions;
                t = t.uuid;
                var i = this._actionsByClip,
                    n = i[t];
                if (void 0 !== n) {
                    for (var n = n.knownActions, r = 0, o = n.length; r !== o; ++r) {
                        var a = n[r];
                        this._deactivateAction(a);
                        var s = a._cacheIndex,
                            l = e[e.length - 1];
                        a._cacheIndex = null, a._byClipCacheIndex = null, l._cacheIndex = s, e[s] = l, e.pop(), this._removeInactiveBindingsForAction(a)
                    }
                    delete i[t]
                }
            },
            uncacheRoot: function(t) {
                t = t.uuid;
                var e, i = this._actionsByClip;
                for (e in i) {
                    var n = i[e].actionByRoot[t];
                    void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
                if (e = this._bindingsByRootAndName[t], void 0 !== e)
                    for (var r in e) t = e[r], t.restoreOriginalState(), this._removeInactiveBinding(t)
            },
            uncacheAction: function(t, e) {
                var i = this.existingAction(t, e);
                null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
        }), In.prototype.clone = function() {
            return new In(void 0 === this.value.clone ? this.value : this.value.clone())
        }, Nn.prototype = Object.assign(Object.create(Tt.prototype), {
            constructor: Nn,
            isInstancedBufferGeometry: !0,
            addGroup: function(t, e, i) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: i
                })
            },
            copy: function(t) {
                var e = t.index;
                null !== e && this.setIndex(e.clone());
                var i, e = t.attributes;
                for (i in e) this.addAttribute(i, e[i].clone());
                for (t = t.groups, i = 0, e = t.length; i < e; i++) {
                    var n = t[i];
                    this.addGroup(n.start, n.count, n.materialIndex)
                }
                return this
            }
        }), Object.defineProperties(Bn.prototype, {
            count: {
                get: function() {
                    return this.data.count
                }
            },
            array: {
                get: function() {
                    return this.data.array
                }
            }
        }), Object.assign(Bn.prototype, {
            isInterleavedBufferAttribute: !0,
            setX: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            },
            setY: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            },
            setZ: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            },
            setW: function(t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            },
            getX: function(t) {
                return this.data.array[t * this.data.stride + this.offset]
            },
            getY: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            },
            getZ: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            },
            getW: function(t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            },
            setXY: function(t, e, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
            },
            setXYZ: function(t, e, i, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
            },
            setXYZW: function(t, e, i, n, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
            }
        }), Object.defineProperty(Un.prototype, "needsUpdate", {
            set: function(t) {
                !0 === t && this.version++
            }
        }), Object.assign(Un.prototype, {
            isInterleavedBuffer: !0,
            setArray: function(t) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t
            },
            setDynamic: function(t) {
                return this.dynamic = t, this
            },
            copy: function(t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
            },
            copyAt: function(t, e, i) {
                t *= this.stride, i *= e.stride;
                for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                return this
            },
            set: function(t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            onUpload: function(t) {
                return this.onUploadCallback = t, this
            }
        }), Fn.prototype = Object.assign(Object.create(Un.prototype), {
            constructor: Fn,
            isInstancedInterleavedBuffer: !0,
            copy: function(t) {
                return Un.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), zn.prototype = Object.assign(Object.create(ht.prototype), {
            constructor: zn,
            isInstancedBufferAttribute: !0,
            copy: function(t) {
                return ht.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
            }
        }), Object.assign(Hn.prototype, {
            linePrecision: 1,
            set: function(t, e) {
                this.ray.set(t, e)
            },
            setFromCamera: function(t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(t, e) {
                var i = [];
                return Gn(t, this, i, e), i.sort(jn), i
            },
            intersectObjects: function(t, e) {
                var i = [];
                if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                for (var n = 0, r = t.length; n < r; n++) Gn(t[n], this, i, e);
                return i.sort(jn), i
            }
        }), Object.assign(Vn.prototype, {
            start: function() {
                this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
            },
            stop: function() {
                this.getElapsedTime(), this.running = !1
            },
            getElapsedTime: function() {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function() {
                var t = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    var e = ("undefined" == typeof performance ? Date : performance).now(),
                        t = (e - this.oldTime) / 1e3;
                    this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }), Object.assign(Wn.prototype, {
            set: function(t, e, i) {
                return this.radius = t, this.phi = e, this.theta = i, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            },
            makeSafe: function() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            },
            setFromVector3: function(t) {
                return this.radius = t.length(), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t.x, t.z), this.phi = Math.acos(yr.clamp(t.y / this.radius, -1, 1))), this
            }
        }), Object.assign(Xn.prototype, {
            set: function(t, e, i) {
                return this.radius = t, this.theta = e, this.y = i, this;
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
            },
            setFromVector3: function(t) {
                return this.radius = Math.sqrt(t.x * t.x + t.z * t.z), this.theta = Math.atan2(t.x, t.z), this.y = t.y, this
            }
        }), qn.prototype = Object.create(St.prototype), qn.prototype.constructor = qn, qn.prototype.createAnimation = function(t, e, i, n) {
            e = {
                start: e,
                end: i,
                length: i - e + 1,
                fps: n,
                duration: (i - e) / n,
                lastFrame: 0,
                currentFrame: 0,
                active: !1,
                time: 0,
                direction: 1,
                weight: 1,
                directionBackwards: !1,
                mirroredLoop: !1
            }, this.animationsMap[t] = e, this.animationsList.push(e)
        }, qn.prototype.autoCreateAnimations = function(t) {
            for (var e, i = /([a-z]+)_?(\d+)/i, n = {}, r = this.geometry, o = 0, a = r.morphTargets.length; o < a; o++) {
                var s = r.morphTargets[o].name.match(i);
                if (s && 1 < s.length) {
                    var l = s[1];
                    n[l] || (n[l] = {
                        start: 1 / 0,
                        end: -(1 / 0)
                    }), s = n[l], o < s.start && (s.start = o), o > s.end && (s.end = o), e || (e = l)
                }
            }
            for (l in n) s = n[l], this.createAnimation(l, s.start, s.end, t);
            this.firstAnimation = e
        }, qn.prototype.setAnimationDirectionForward = function(t) {
            (t = this.animationsMap[t]) && (t.direction = 1, t.directionBackwards = !1)
        }, qn.prototype.setAnimationDirectionBackward = function(t) {
            (t = this.animationsMap[t]) && (t.direction = -1, t.directionBackwards = !0)
        }, qn.prototype.setAnimationFPS = function(t, e) {
            var i = this.animationsMap[t];
            i && (i.fps = e, i.duration = (i.end - i.start) / i.fps)
        }, qn.prototype.setAnimationDuration = function(t, e) {
            var i = this.animationsMap[t];
            i && (i.duration = e, i.fps = (i.end - i.start) / i.duration)
        }, qn.prototype.setAnimationWeight = function(t, e) {
            var i = this.animationsMap[t];
            i && (i.weight = e)
        }, qn.prototype.setAnimationTime = function(t, e) {
            var i = this.animationsMap[t];
            i && (i.time = e)
        }, qn.prototype.getAnimationTime = function(t) {
            var e = 0;
            return (t = this.animationsMap[t]) && (e = t.time), e
        }, qn.prototype.getAnimationDuration = function(t) {
            var e = -1;
            return (t = this.animationsMap[t]) && (e = t.duration), e
        }, qn.prototype.playAnimation = function(t) {
            var e = this.animationsMap[t];
            e ? (e.time = 0, e.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + t + "] undefined in .playAnimation()")
        }, qn.prototype.stopAnimation = function(t) {
            (t = this.animationsMap[t]) && (t.active = !1)
        }, qn.prototype.update = function(t) {
            for (var e = 0, i = this.animationsList.length; e < i; e++) {
                var n = this.animationsList[e];
                if (n.active) {
                    var r = n.duration / n.length;
                    n.time += n.direction * t, n.mirroredLoop ? (n.time > n.duration || 0 > n.time) && (n.direction *= -1, n.time > n.duration && (n.time = n.duration, n.directionBackwards = !0), 0 > n.time && (n.time = 0, n.directionBackwards = !1)) : (n.time %= n.duration, 0 > n.time && (n.time += n.duration));
                    var o = n.start + yr.clamp(Math.floor(n.time / r), 0, n.length - 1),
                        a = n.weight;
                    o !== n.currentFrame && (this.morphTargetInfluences[n.lastFrame] = 0, this.morphTargetInfluences[n.currentFrame] = 1 * a, this.morphTargetInfluences[o] = 0, n.lastFrame = n.currentFrame, n.currentFrame = o), r = n.time % r / r, n.directionBackwards && (r = 1 - r), n.currentFrame !== n.lastFrame ? (this.morphTargetInfluences[n.currentFrame] = r * a, this.morphTargetInfluences[n.lastFrame] = (1 - r) * a) : this.morphTargetInfluences[n.currentFrame] = a
                }
            }
        }, $n.prototype = Object.create(ot.prototype), $n.prototype.constructor = $n, $n.prototype.isImmediateRenderObject = !0, Yn.prototype = Object.create(be.prototype), Yn.prototype.constructor = Yn, Yn.prototype.update = function() {
            var t = new l,
                e = new l,
                i = new J;
            return function() {
                var n = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                var r = this.object.matrixWorld,
                    o = this.geometry.attributes.position,
                    a = this.object.geometry;
                if (a && a.isGeometry)
                    for (var s = a.vertices, l = a.faces, c = a = 0, h = l.length; c < h; c++)
                        for (var u = l[c], d = 0, p = u.vertexNormals.length; d < p; d++) {
                            var f = u.vertexNormals[d];
                            t.copy(s[u[n[d]]]).applyMatrix4(r), e.copy(f).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(a, t.x, t.y, t.z), a += 1, o.setXYZ(a, e.x, e.y, e.z), a += 1
                        } else if (a && a.isBufferGeometry)
                            for (n = a.attributes.position, s = a.attributes.normal, d = a = 0, p = n.count; d < p; d++) t.set(n.getX(d), n.getY(d), n.getZ(d)).applyMatrix4(r), e.set(s.getX(d), s.getY(d), s.getZ(d)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(a, t.x, t.y, t.z), a += 1, o.setXYZ(a, e.x, e.y, e.z), a += 1;
                o.needsUpdate = !0
            }
        }(), Zn.prototype = Object.create(ot.prototype), Zn.prototype.constructor = Zn, Zn.prototype.dispose = function() {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, Zn.prototype.update = function() {
            var t = new l,
                e = new l;
            return function() {
                var i = this.light.distance ? this.light.distance : 1e3,
                    n = i * Math.tan(this.light.angle);
                this.cone.scale.set(n, n, i), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.cone.material.color.copy(this.light.color)
            }
        }(), Qn.prototype = Object.create(be.prototype), Qn.prototype.constructor = Qn, Qn.prototype.getBoneList = function(t) {
            var e = [];
            t && t.isBone && e.push(t);
            for (var i = 0; i < t.children.length; i++) e.push.apply(e, this.getBoneList(t.children[i]));
            return e
        }, Qn.prototype.update = function() {
            var t = new l,
                e = new c,
                i = new c;
            return function() {
                var n = this.geometry,
                    r = n.getAttribute("position");
                i.getInverse(this.root.matrixWorld);
                for (var o = 0, a = 0; o < this.bones.length; o++) {
                    var s = this.bones[o];
                    s.parent && s.parent.isBone && (e.multiplyMatrices(i, s.matrixWorld), t.setFromMatrixPosition(e), r.setXYZ(a, t.x, t.y, t.z), e.multiplyMatrices(i, s.parent.matrixWorld), t.setFromMatrixPosition(e), r.setXYZ(a + 1, t.x, t.y, t.z), a += 2)
                }
                n.getAttribute("position").needsUpdate = !0
            }
        }(), Jn.prototype = Object.create(St.prototype), Jn.prototype.constructor = Jn, Jn.prototype.dispose = function() {
            this.geometry.dispose(), this.material.dispose()
        }, Jn.prototype.update = function() {
            this.material.color.copy(this.light.color)
        }, Kn.prototype = Object.create(ot.prototype), Kn.prototype.constructor = Kn, Kn.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, Kn.prototype.update = function() {
            var t = this.children[0];
            t.material.color.copy(this.light.color);
            var e = .5 * this.light.width,
                i = .5 * this.light.height,
                t = t.geometry.attributes.position,
                n = t.array;
            n[0] = e, n[1] = -i, n[2] = 0, n[3] = e, n[4] = i, n[5] = 0, n[6] = -e, n[7] = i, n[8] = 0, n[9] = -e, n[10] = -i, n[11] = 0, n[12] = e, n[13] = -i, n[14] = 0, t.needsUpdate = !0
        }, tr.prototype = Object.create(ot.prototype), tr.prototype.constructor = tr, tr.prototype.dispose = function() {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, tr.prototype.update = function() {
            var t = new l,
                e = new G,
                i = new G;
            return function() {
                var n = this.children[0],
                    r = n.geometry.getAttribute("color");
                e.copy(this.light.color), i.copy(this.light.groundColor);
                for (var o = 0, a = r.count; o < a; o++) {
                    var s = o < a / 2 ? e : i;
                    r.setXYZ(o, s.r, s.g, s.b)
                }
                n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()), r.needsUpdate = !0
            }
        }(), er.prototype = Object.create(be.prototype), er.prototype.constructor = er, ir.prototype = Object.create(be.prototype), ir.prototype.constructor = ir, nr.prototype = Object.create(be.prototype), nr.prototype.constructor = nr, nr.prototype.update = function() {
            var t = new l,
                e = new l,
                i = new J;
            return function() {
                this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, o = o.faces, s = 0, l = 0, c = o.length; l < c; l++) {
                    var h = o[l],
                        u = h.normal;
                    t.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(n), e.copy(u).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(s, t.x, t.y, t.z), s += 1, r.setXYZ(s, e.x, e.y, e.z), s += 1
                }
                r.needsUpdate = !0
            }
        }(), rr.prototype = Object.create(ot.prototype), rr.prototype.constructor = rr, rr.prototype.dispose = function() {
            var t = this.children[0],
                e = this.children[1];
            t.geometry.dispose(), t.material.dispose(), e.geometry.dispose(), e.material.dispose()
        }, rr.prototype.update = function() {
            var t = new l,
                e = new l,
                i = new l;
            return function() {
                t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t);
                var n = this.children[0],
                    r = this.children[1];
                n.lookAt(i), n.material.color.copy(this.light.color), r.lookAt(i), r.scale.z = i.length()
            }
        }(), or.prototype = Object.create(be.prototype), or.prototype.constructor = or, or.prototype.update = function() {
            function t(t, o, a, s) {
                if (n.set(o, a, s).unproject(r), t = i[t], void 0 !== t)
                    for (o = e.getAttribute("position"), a = 0, s = t.length; a < s; a++) o.setXYZ(t[a], n.x, n.y, n.z)
            }
            var e, i, n = new l,
                r = new Pt;
            return function() {
                e = this.geometry, i = this.pointMap, r.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", .7, 1.1, -1), t("u2", -.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0
            }
        }(), ar.prototype = Object.create(be.prototype), ar.prototype.constructor = ar, ar.prototype.update = function() {
            var t = new Z;
            return function(e) {
                if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                    e = t.min;
                    var i = t.max,
                        n = this.geometry.attributes.position,
                        r = n.array;
                    r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = e.x, r[4] = i.y, r[5] = i.z, r[6] = e.x, r[7] = e.y, r[8] = i.z, r[9] = i.x, r[10] = e.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = e.z, r[15] = e.x, r[16] = i.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = i.x, r[22] = e.y, r[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }
        }(), ar.prototype.setFromObject = function(t) {
            return this.object = t, this.update(), this
        };
        var Zr, Qr;
        sr.prototype = Object.create(ot.prototype), sr.prototype.constructor = sr, sr.prototype.setDirection = function() {
            var t, e = new l;
            return function(i) {
                .99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (e.set(i.z, 0, -i.x).normalize(), t = Math.acos(i.y), this.quaternion.setFromAxisAngle(e, t))
            }
        }(), sr.prototype.setLength = function(t, e, i) {
            void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
        }, sr.prototype.setColor = function(t) {
            this.line.material.color.copy(t), this.cone.material.color.copy(t)
        }, lr.prototype = Object.create(be.prototype), lr.prototype.constructor = lr;
        var Jr = new l,
            Kr = new cr,
            to = new cr,
            eo = new cr;
        hr.prototype = Object.create(cn.prototype), hr.prototype.constructor = hr, hr.prototype.getPoint = function(t) {
            var e = this.points,
                i = e.length;
            2 > i && console.log("duh, you need at least 2 points"), t *= i - (this.closed ? 0 : 1);
            var n = Math.floor(t);
            t -= n, this.closed ? n += 0 < n ? 0 : (Math.floor(Math.abs(n) / e.length) + 1) * e.length : 0 === t && n === i - 1 && (n = i - 2, t = 1);
            var r, o, a;
            if (this.closed || 0 < n ? r = e[(n - 1) % i] : (Jr.subVectors(e[0], e[1]).add(e[0]), r = Jr), o = e[n % i], a = e[(n + 1) % i], this.closed || n + 2 < i ? e = e[(n + 2) % i] : (Jr.subVectors(e[i - 1], e[i - 2]).add(e[i - 1]), e = Jr), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                var s = "chordal" === this.type ? .5 : .25,
                    i = Math.pow(r.distanceToSquared(o), s),
                    n = Math.pow(o.distanceToSquared(a), s),
                    s = Math.pow(a.distanceToSquared(e), s);
                1e-4 > n && (n = 1), 1e-4 > i && (i = n), 1e-4 > s && (s = n), Kr.initNonuniformCatmullRom(r.x, o.x, a.x, e.x, i, n, s), to.initNonuniformCatmullRom(r.y, o.y, a.y, e.y, i, n, s), eo.initNonuniformCatmullRom(r.z, o.z, a.z, e.z, i, n, s)
            } else "catmullrom" === this.type && (i = void 0 !== this.tension ? this.tension : .5, Kr.initCatmullRom(r.x, o.x, a.x, e.x, i), to.initCatmullRom(r.y, o.y, a.y, e.y, i), eo.initCatmullRom(r.z, o.z, a.z, e.z, i));
            return new l(Kr.calc(t), to.calc(t), eo.calc(t))
        }, ur.prototype = Object.create(cn.prototype), ur.prototype.constructor = ur, ur.prototype.getPoint = function(t) {
            var e = this.v0,
                i = this.v1,
                n = this.v2,
                r = this.v3;
            return new l(ln(t, e.x, i.x, n.x, r.x), ln(t, e.y, i.y, n.y, r.y), ln(t, e.z, i.z, n.z, r.z))
        }, dr.prototype = Object.create(cn.prototype), dr.prototype.constructor = dr, dr.prototype.getPoint = function(t) {
            var e = this.v0,
                i = this.v1,
                n = this.v2;
            return new l(sn(t, e.x, i.x, n.x), sn(t, e.y, i.y, n.y), sn(t, e.z, i.z, n.z))
        }, pr.prototype = Object.create(cn.prototype), pr.prototype.constructor = pr, pr.prototype.getPoint = function(t) {
            if (1 === t) return this.v2.clone();
            var e = new l;
            return e.subVectors(this.v2, this.v1), e.multiplyScalar(t), e.add(this.v1), e
        }, fr.prototype = Object.create(dn.prototype), fr.prototype.constructor = fr, cn.create = function(t, e) {
            return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(cn.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
        }, mr.prototype = Object.create(hr.prototype), gr.prototype = Object.create(hr.prototype), vr.prototype = Object.create(hr.prototype), Object.assign(vr.prototype, {
            initFromArray: function(t) {
                console.error("THREE.Spline: .initFromArray() has been removed.")
            },
            getControlPointsArray: function(t) {
                console.error("THREE.Spline: .getControlPointsArray() has been removed.")
            },
            reparametrizeByArcLength: function(t) {
                console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
            }
        }), er.prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, Object.assign(V.prototype, {
            center: function(t) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
            },
            empty: function() {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function(t) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            size: function(t) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), Object.assign(Z.prototype, {
            center: function(t) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            },
            empty: function() {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function(t) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            isIntersectionSphere: function(t) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            },
            size: function(t) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), at.prototype.center = function(t) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, yr.random16 = function() {
            return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random()
        }, Object.assign(J.prototype, {
            flattenToArrayOffset: function(t, e) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            },
            multiplyVector3: function(t) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            },
            multiplyVector3Array: function(t) {
                return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t)
            },
            applyToBuffer: function(t, e, i) {
                return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            },
            applyToVector3Array: function(t, e, i) {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }
        }), Object.assign(c.prototype, {
            extractPosition: function(t) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
            },
            flattenToArrayOffset: function(t, e) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            },
            getPosition: function() {
                var t;
                return function() {
                    return void 0 === t && (t = new l), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
                }
            }(),
            setRotationFromQuaternion: function(t) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
            },
            multiplyToArray: function() {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            },
            multiplyVector3: function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            multiplyVector4: function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            multiplyVector3Array: function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t)
            },
            rotateAxis: function(t) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
            },
            crossVector: function(t) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            },
            translate: function() {
                console.error("THREE.Matrix4: .translate() has been removed.")
            },
            rotateX: function() {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            },
            rotateY: function() {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            },
            rotateZ: function() {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            },
            rotateByAxis: function() {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            },
            applyToBuffer: function(t, e, i) {
                return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            },
            applyToVector3Array: function(t, e, i) {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            },
            makeFrustum: function(t, e, i, n, r, o) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, o)
            }
        }), K.prototype.isIntersectionLine = function(t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
        }, s.prototype.multiplyVector3 = function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        }, Object.assign(it.prototype, {
            isIntersectionBox: function(t) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            },
            isIntersectionPlane: function(t) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
            },
            isIntersectionSphere: function(t) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }
        }), Object.assign(vn.prototype, {
            extrude: function(t) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Ye(this, t)
            },
            makeGeometry: function(t) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new oi(this, t)
            }
        }), Object.assign(i.prototype, {
            fromAttribute: function(t, e, i) {
                return console.error("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            }
        }), Object.assign(l.prototype, {
            setEulerFromRotationMatrix: function() {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            },
            setEulerFromQuaternion: function() {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            },
            getPositionFromMatrix: function(t) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
            },
            getScaleFromMatrix: function(t) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
            },
            getColumnFromMatrix: function(t, e) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
            },
            applyProjection: function(t) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
            },
            fromAttribute: function(t, e, i) {
                return console.error("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            }
        }), Object.assign(r.prototype, {
            fromAttribute: function(t, e, i) {
                return console.error("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
            }
        }), wt.prototype.computeTangents = function() {
            console.warn("THREE.Geometry: .computeTangents() has been removed.")
        }, Object.assign(ot.prototype, {
            getChildByName: function(t) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
            },
            renderDepth: function() {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            },
            translate: function(t, e) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
            }
        }), Object.defineProperties(ot.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function(t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), Object.defineProperties(me.prototype, {
            objects: {
                get: function() {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        }), Object.defineProperty(ge.prototype, "useVertexTexture", {
            get: function() {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            },
            set: function() {
                console.warn("THREE.Skeleton: useVertexTexture has been removed.")
            }
        }), Object.defineProperty(cn.prototype, "__arcLengthDivisions", {
            get: function() {
                return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
            },
            set: function(t) {
                console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
            }
        }), Rt.prototype.setLens = function(t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(Ri.prototype, {
            onlyShadow: {
                set: function() {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                }
            },
            shadowCameraLeft: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                }
            },
            shadowCameraRight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                }
            },
            shadowCameraTop: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                }
            },
            shadowCameraBottom: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                }
            },
            shadowCameraNear: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                }
            },
            shadowCameraFar: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                }
            },
            shadowCameraVisible: {
                set: function() {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                }
            },
            shadowDarkness: {
                set: function() {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                }
            },
            shadowMapHeight: {
                set: function(t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties(ht.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            }
        }), Object.assign(Tt.prototype, {
            addIndex: function(t) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
            },
            addDrawCall: function(t, e, i) {
                void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
            },
            clearDrawCalls: function() {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            },
            computeTangents: function() {
                console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
            },
            computeOffsets: function() {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }
        }), Object.defineProperties(Tt.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Object.defineProperties(In.prototype, {
            dynamic: {
                set: function() {
                    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                }
            },
            onUpdate: {
                value: function() {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                }
            }
        }), Object.defineProperties(q.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                },
                set: function() {
                    console.warn("THREE.Material: .wrapAround has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE.Material: .wrapRGB has been removed."), new G
                }
            }
        }), Object.defineProperties(yi.prototype, {
            metal: {
                get: function() {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                },
                set: function() {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }), Object.defineProperties($.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function(t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                }
            }
        }), Object.assign(le.prototype, {
            getCurrentRenderTarget: function() {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            },
            supportsFloatTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            },
            supportsHalfFloatTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            },
            supportsStandardDerivatives: function() {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            },
            supportsCompressedTextureS3TC: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            },
            supportsCompressedTexturePVRTC: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            },
            supportsBlendMinMax: function() {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            },
            supportsVertexTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            },
            supportsInstancedArrays: function() {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            },
            enableScissorTest: function(t) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
            },
            initMaterial: function() {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            },
            addPrePlugin: function() {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            },
            addPostPlugin: function() {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            },
            updateShadowMap: function() {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }
        }), Object.defineProperties(le.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                }
            },
            shadowMapCullFace: {
                get: function() {
                    return this.shadowMap.cullFace
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = t
                }
            }
        }), Object.defineProperties(et.prototype, {
            cullFace: {
                get: function() {
                    return this.renderReverseSided ? 2 : 1
                },
                set: function(t) {
                    t = 1 !== t, console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + t + "."), this.renderReverseSided = t
                }
            }
        }), Object.defineProperties(o.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                        this.texture.generateMipmaps
                },
                set: function(t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                }
            }
        }), En.prototype.load = function(t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            var e = this;
            return (new bn).load(t, function(t) {
                e.setBuffer(t)
            }), this
        }, Cn.prototype.getData = function() {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
        }, t.WebGLRenderTargetCube = a, t.WebGLRenderTarget = o, t.WebGLRenderer = le, t.ShaderLib = Lr, t.UniformsLib = Cr, t.UniformsUtils = Pr, t.ShaderChunk = Rr, t.FogExp2 = ce, t.Fog = he, t.Scene = ue, t.LensFlare = de, t.Sprite = fe, t.LOD = me, t.SkinnedMesh = ye, t.Skeleton = ge, t.Bone = ve, t.Mesh = St, t.LineSegments = be, t.LineLoop = we, t.Line = xe, t.Points = Se, t.Group = Me, t.VideoTexture = Ee, t.DataTexture = h, t.CompressedTexture = Ae, t.CubeTexture = u, t.CanvasTexture = Ce, t.DepthTexture = Pe, t.Texture = n, t.CompressedTextureLoader = Mi, t.DataTextureLoader = Ei, t.CubeTextureLoader = Ci, t.TextureLoader = Pi, t.ObjectLoader = on, t.MaterialLoader = tn, t.BufferGeometryLoader = en, t.DefaultLoadingManager = zr, t.LoadingManager = Ti, t.JSONLoader = rn, t.ImageLoader = Ai, t.FontLoader = xn, t.FileLoader = Si, t.Loader = nn, t.Cache = Fr, t.AudioLoader = bn, t.SpotLightShadow = Oi, t.SpotLight = Di, t.PointLight = Ii, t.RectAreaLight = Fi, t.HemisphereLight = Li, t.DirectionalLightShadow = Ni, t.DirectionalLight = Bi, t.AmbientLight = Ui, t.LightShadow = ki, t.Light = Ri, t.StereoCamera = wn, t.PerspectiveCamera = Rt, t.OrthographicCamera = Lt, t.CubeCamera = Tn, t.ArrayCamera = Sn, t.Camera = Pt, t.AudioListener = Mn, t.PositionalAudio = An, t.AudioContext = Yr, t.AudioAnalyser = Cn, t.Audio = En, t.VectorKeyframeTrack = Wi, t.StringKeyframeTrack = Yi, t.QuaternionKeyframeTrack = qi, t.NumberKeyframeTrack = $i, t.ColorKeyframeTrack = Qi, t.BooleanKeyframeTrack = Zi, t.PropertyMixer = Pn, t.PropertyBinding = Ln, t.KeyframeTrack = Ji, t.AnimationUtils = Hr, t.AnimationObjectGroup = kn, t.AnimationMixer = Dn, t.AnimationClip = Ki, t.Uniform = In, t.InstancedBufferGeometry = Nn, t.BufferGeometry = Tt, t.GeometryIdCount = function() {
            return Dr++
        }, t.Geometry = wt, t.InterleavedBufferAttribute = Bn, t.InstancedInterleavedBuffer = Fn, t.InterleavedBuffer = Un, t.InstancedBufferAttribute = zn, t.Face3 = lt, t.Object3D = ot, t.Raycaster = Hn, t.Layers = rt, t.EventDispatcher = e, t.Clock = Vn, t.QuaternionLinearInterpolant = Xi, t.LinearInterpolant = ji, t.DiscreteInterpolant = Gi, t.CubicInterpolant = Hi, t.Interpolant = zi, t.Triangle = st, t.Math = yr, t.Spherical = Wn, t.Cylindrical = Xn, t.Plane = K, t.Frustum = tt, t.Sphere = Q, t.Ray = it, t.Matrix4 = c, t.Matrix3 = J, t.Box3 = Z, t.Box2 = V, t.Line3 = at, t.Euler = nt, t.Vector4 = r, t.Vector3 = l, t.Vector2 = i, t.Quaternion = s, t.Color = G, t.MorphBlendMesh = qn, t.ImmediateRenderObject = $n, t.VertexNormalsHelper = Yn, t.SpotLightHelper = Zn, t.SkeletonHelper = Qn, t.PointLightHelper = Jn, t.RectAreaLightHelper = Kn, t.HemisphereLightHelper = tr, t.GridHelper = er, t.PolarGridHelper = ir, t.FaceNormalsHelper = nr, t.DirectionalLightHelper = rr, t.CameraHelper = or, t.BoxHelper = ar, t.ArrowHelper = sr, t.AxisHelper = lr, t.CatmullRomCurve3 = hr, t.CubicBezierCurve3 = ur, t.QuadraticBezierCurve3 = dr, t.LineCurve3 = pr, t.ArcCurve = fr, t.EllipseCurve = dn, t.SplineCurve = pn, t.CubicBezierCurve = fn, t.QuadraticBezierCurve = mn, t.LineCurve = hn, t.Shape = vn, t.Path = gn;
        t.ShapePath = yn;
        t.Font = _n, t.CurvePath = un, t.Curve = cn, t.ShapeUtils = Nr, t.SceneUtils = {
            createMultiMaterialObject: function(t, e) {
                for (var i = new Me, n = 0, r = e.length; n < r; n++) i.add(new St(t, e[n]));
                return i
            },
            detach: function(t, e, i) {
                t.applyMatrix(e.matrixWorld), e.remove(t), i.add(t)
            },
            attach: function(t, e, i) {
                var n = new c;
                n.getInverse(i.matrixWorld), t.applyMatrix(n), e.remove(t), i.add(t)
            }
        }, t.WireframeGeometry = Re, t.ParametricGeometry = Le, t.ParametricBufferGeometry = ke, t.TetrahedronGeometry = Ie, t.TetrahedronBufferGeometry = Ne, t.OctahedronGeometry = Be, t.OctahedronBufferGeometry = Ue, t.IcosahedronGeometry = Fe, t.IcosahedronBufferGeometry = ze, t.DodecahedronGeometry = He, t.DodecahedronBufferGeometry = je, t.PolyhedronGeometry = Oe, t.PolyhedronBufferGeometry = De, t.TubeGeometry = Ge, t.TubeBufferGeometry = Ve, t.TorusKnotGeometry = We, t.TorusKnotBufferGeometry = Xe, t.TorusGeometry = qe, t.TorusBufferGeometry = $e, t.TextGeometry = Qe, t.TextBufferGeometry = Je, t.SphereGeometry = Ke, t.SphereBufferGeometry = ti, t.RingGeometry = ei, t.RingBufferGeometry = ii, t.PlaneGeometry = At, t.PlaneBufferGeometry = Ct, t.LatheGeometry = ni, t.LatheBufferGeometry = ri, t.ShapeGeometry = oi, t.ShapeBufferGeometry = ai, t.ExtrudeGeometry = Ye, t.ExtrudeBufferGeometry = Ze, t.EdgesGeometry = si, t.ConeGeometry = hi, t.ConeBufferGeometry = ui, t.CylinderGeometry = li, t.CylinderBufferGeometry = ci, t.CircleGeometry = di, t.CircleBufferGeometry = pi, t.BoxGeometry = Mt, t.BoxBufferGeometry = Et, t.ShadowMaterial = fi, t.SpriteMaterial = pe, t.RawShaderMaterial = mi, t.ShaderMaterial = $, t.PointsMaterial = Te, t.MeshPhysicalMaterial = vi, t.MeshStandardMaterial = gi, t.MeshPhongMaterial = yi, t.MeshToonMaterial = _i, t.MeshNormalMaterial = xi, t.MeshLambertMaterial = bi, t.MeshDepthMaterial = Y, t.MeshBasicMaterial = ct, t.LineDashedMaterial = wi, t.LineBasicMaterial = _e, t.Material = q, t.Float64BufferAttribute = _t, t.Float32BufferAttribute = yt, t.Uint32BufferAttribute = vt, t.Int32BufferAttribute = gt, t.Uint16BufferAttribute = mt, t.Int16BufferAttribute = ft, t.Uint8ClampedBufferAttribute = pt, t.Uint8BufferAttribute = dt, t.Int8BufferAttribute = ut, t.BufferAttribute = ht, t.REVISION = "85", t.MOUSE = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        }, t.CullFaceNone = 0, t.CullFaceBack = 1, t.CullFaceFront = 2, t.CullFaceFrontBack = 3, t.FrontFaceDirectionCW = 0, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = 1, t.PCFSoftShadowMap = 2, t.FrontSide = 0, t.BackSide = 1, t.DoubleSide = 2, t.FlatShading = 1, t.SmoothShading = 2, t.NoColors = 0, t.FaceColors = 1, t.VertexColors = 2, t.NoBlending = 0, t.NormalBlending = 1, t.AdditiveBlending = 2, t.SubtractiveBlending = 3, t.MultiplyBlending = 4, t.CustomBlending = 5, t.AddEquation = 100, t.SubtractEquation = 101, t.ReverseSubtractEquation = 102, t.MinEquation = 103, t.MaxEquation = 104, t.ZeroFactor = 200, t.OneFactor = 201, t.SrcColorFactor = 202, t.OneMinusSrcColorFactor = 203, t.SrcAlphaFactor = 204, t.OneMinusSrcAlphaFactor = 205, t.DstAlphaFactor = 206, t.OneMinusDstAlphaFactor = 207, t.DstColorFactor = 208, t.OneMinusDstColorFactor = 209, t.SrcAlphaSaturateFactor = 210, t.NeverDepth = 0, t.AlwaysDepth = 1, t.LessDepth = 2, t.LessEqualDepth = 3, t.EqualDepth = 4, t.GreaterEqualDepth = 5, t.GreaterDepth = 6, t.NotEqualDepth = 7, t.MultiplyOperation = 0, t.MixOperation = 1, t.AddOperation = 2, t.NoToneMapping = 0, t.LinearToneMapping = 1, t.ReinhardToneMapping = 2, t.Uncharted2ToneMapping = 3, t.CineonToneMapping = 4, t.UVMapping = 300, t.CubeReflectionMapping = 301, t.CubeRefractionMapping = 302, t.EquirectangularReflectionMapping = 303, t.EquirectangularRefractionMapping = 304, t.SphericalReflectionMapping = 305, t.CubeUVReflectionMapping = 306, t.CubeUVRefractionMapping = 307, t.RepeatWrapping = 1e3, t.ClampToEdgeWrapping = 1001, t.MirroredRepeatWrapping = 1002, t.NearestFilter = 1003, t.NearestMipMapNearestFilter = 1004, t.NearestMipMapLinearFilter = 1005, t.LinearFilter = 1006, t.LinearMipMapNearestFilter = 1007, t.LinearMipMapLinearFilter = 1008, t.UnsignedByteType = 1009, t.ByteType = 1010, t.ShortType = 1011, t.UnsignedShortType = 1012, t.IntType = 1013, t.UnsignedIntType = 1014, t.FloatType = 1015, t.HalfFloatType = 1016, t.UnsignedShort4444Type = 1017, t.UnsignedShort5551Type = 1018, t.UnsignedShort565Type = 1019, t.UnsignedInt248Type = 1020, t.AlphaFormat = 1021, t.RGBFormat = 1022, t.RGBAFormat = 1023, t.LuminanceFormat = 1024, t.LuminanceAlphaFormat = 1025, t.RGBEFormat = 1023, t.DepthFormat = 1026, t.DepthStencilFormat = 1027, t.RGB_S3TC_DXT1_Format = 2001, t.RGBA_S3TC_DXT1_Format = 2002, t.RGBA_S3TC_DXT3_Format = 2003, t.RGBA_S3TC_DXT5_Format = 2004, t.RGB_PVRTC_4BPPV1_Format = 2100, t.RGB_PVRTC_2BPPV1_Format = 2101, t.RGBA_PVRTC_4BPPV1_Format = 2102, t.RGBA_PVRTC_2BPPV1_Format = 2103, t.RGB_ETC1_Format = 2151, t.LoopOnce = 2200, t.LoopRepeat = 2201, t.LoopPingPong = 2202, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.ZeroCurvatureEnding = 2400, t.ZeroSlopeEnding = 2401, t.WrapAroundEnding = 2402, t.TrianglesDrawMode = 0, t.TriangleStripDrawMode = 1, t.TriangleFanDrawMode = 2, t.LinearEncoding = 3e3, t.sRGBEncoding = 3001, t.GammaEncoding = 3007, t.RGBEEncoding = 3002, t.LogLuvEncoding = 3003, t.RGBM7Encoding = 3004, t.RGBM16Encoding = 3005, t.RGBDEncoding = 3006, t.BasicDepthPacking = 3200, t.RGBADepthPacking = 3201, t.CubeGeometry = Mt, t.Face4 = function(t, e, i, n, r, o, a) {
            return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new lt(t, e, i, r, o, a)
        };
        t.LineStrip = 0;
        t.LinePieces = 1, t.MeshFaceMaterial = function(t) {
            return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
        }, t.MultiMaterial = function(t) {
            return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                return t.slice()
            }, t
        }, t.PointCloud = function(t, e) {
            return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Se(t, e)
        }, t.Particle = function(t) {
            return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new fe(t)
        }, t.ParticleSystem = function(t, e) {
            return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Se(t, e)
        }, t.PointCloudMaterial = function(t) {
            return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Te(t)
        }, t.ParticleBasicMaterial = function(t) {
            return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Te(t)
        }, t.ParticleSystemMaterial = function(t) {
            return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Te(t)
        }, t.Vertex = function(t, e, i) {
            return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new l(t, e, i)
        }, t.DynamicBufferAttribute = function(t, e) {
            return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new ht(t, e).setDynamic(!0)
        }, t.Int8Attribute = function(t, e) {
            return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new ut(t, e)
        }, t.Uint8Attribute = function(t, e) {
            return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new dt(t, e)
        }, t.Uint8ClampedAttribute = function(t, e) {
            return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new pt(t, e)
        }, t.Int16Attribute = function(t, e) {
            return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new ft(t, e)
        }, t.Uint16Attribute = function(t, e) {
            return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new mt(t, e)
        }, t.Int32Attribute = function(t, e) {
            return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new gt(t, e)
        }, t.Uint32Attribute = function(t, e) {
            return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new vt(t, e)
        }, t.Float32Attribute = function(t, e) {
            return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new yt(t, e)
        }, t.Float64Attribute = function(t, e) {
            return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new _t(t, e)
        }, t.ClosedSplineCurve3 = mr, t.SplineCurve3 = gr, t.Spline = vr, t.BoundingBoxHelper = function(t, e) {
            return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new ar(t, e)
        }, t.EdgesHelper = function(t, e) {
            return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new be(new si(t.geometry), new _e({
                color: void 0 !== e ? e : 16777215
            }))
        }, t.WireframeHelper = function(t, e) {
            return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new be(new Re(t.geometry), new _e({
                color: void 0 !== e ? e : 16777215
            }))
        }, t.XHRLoader = function(t) {
            return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Si(t)
        }, t.BinaryTextureLoader = function(t) {
            return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ei(t)
        }, t.GeometryUtils = {
            merge: function(t, e, i) {
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                var n;
                e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, i)
            },
            center: function(t) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
            }
        }, t.ImageUtils = {
            crossOrigin: void 0,
            loadTexture: function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new Pi;
                return r.setCrossOrigin(this.crossOrigin), t = r.load(t, i, void 0, n), e && (t.mapping = e), t
            },
            loadTextureCube: function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new Ci;
                return r.setCrossOrigin(this.crossOrigin), t = r.load(t, i, void 0, n), e && (t.mapping = e), t
            },
            loadCompressedTexture: function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            },
            loadCompressedTextureCube: function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }
        }, t.Projector = function() {
            console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
                console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
            }, this.unprojectVector = function(t, e) {
                console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
            }, this.pickingRay = function() {
                console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
            }
        }, t.CanvasRenderer = function() {
            console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
        }, Object.defineProperty(t, "__esModule", {
            value: !0
        })
    })
}, function(t, e) {
    THREE.SpriteCanvasMaterial = function(t) {
        THREE.Material.call(this), this.type = "SpriteCanvasMaterial", this.color = new THREE.Color(16777215), this.program = function() {}, this.setValues(t)
    }, THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteCanvasMaterial.prototype.constructor = THREE.SpriteCanvasMaterial, THREE.SpriteCanvasMaterial.prototype.isSpriteCanvasMaterial = !0, THREE.SpriteCanvasMaterial.prototype.clone = function() {
        var t = new THREE.SpriteCanvasMaterial;
        return t.copy(this), t.color.copy(this.color), t.program = this.program, t
    }, THREE.CanvasRenderer = function(t) {
        function e() {
            gt.setRGB(0, 0, 0), vt.setRGB(0, 0, 0), yt.setRGB(0, 0, 0);
            for (var t = 0, e = w.length; t < e; t++) {
                var i = w[t],
                    n = i.color;
                i.isAmbientLight ? gt.add(n) : i.isDirectionalLight ? vt.add(n) : i.isPointLight && yt.add(n)
            }
        }

        function i(t, e, i) {
            for (var n = 0, r = w.length; n < r; n++) {
                var o = w[n];
                if (ut.copy(o.color), o.isDirectionalLight) {
                    var a = _t.setFromMatrixPosition(o.matrixWorld).normalize(),
                        s = e.dot(a);
                    if (s <= 0) continue;
                    s *= o.intensity, i.add(ut.multiplyScalar(s))
                } else if (o.isPointLight) {
                    var a = _t.setFromMatrixPosition(o.matrixWorld),
                        s = e.dot(_t.subVectors(a, t).normalize());
                    if (s <= 0) continue;
                    if (s *= 0 == o.distance ? 1 : 1 - Math.min(t.distanceTo(a) / o.distance, 1), 0 == s) continue;
                    s *= o.intensity, i.add(ut.multiplyScalar(s))
                }
            }
        }

        function n(t, e, i) {
            d(i.opacity), p(i.blending);
            var n = e.scale.x * V,
                r = e.scale.y * W,
                o = Math.sqrt(n * n + r * r);
            if (mt.min.set(t.x - o, t.y - o), mt.max.set(t.x + o, t.y + o), i.isSpriteMaterial) {
                var a = i.map;
                if (null !== a) {
                    var s = dt[a.id];
                    if (void 0 !== s && s.version === a.version || (s = c(a), dt[a.id] = s), void 0 !== s.canvas) {
                        y(s.canvas);
                        var l = a.image,
                            h = l.width * a.offset.x,
                            u = l.height * a.offset.y,
                            f = l.width * a.repeat.x,
                            m = l.height * a.repeat.y,
                            g = n / f,
                            _ = r / m;
                        Q.save(), Q.translate(t.x, t.y), 0 !== i.rotation && Q.rotate(i.rotation), Q.translate(-n / 2, -r / 2), Q.scale(g, _), Q.translate(-h, -u), Q.fillRect(h, u, f, m), Q.restore()
                    }
                } else y(i.color.getStyle()), Q.save(), Q.translate(t.x, t.y), 0 !== i.rotation && Q.rotate(i.rotation), Q.scale(n, -r), Q.fillRect(-.5, -.5, 1, 1), Q.restore()
            } else i.isSpriteCanvasMaterial ? (v(i.color.getStyle()), y(i.color.getStyle()), Q.save(), Q.translate(t.x, t.y), 0 !== i.rotation && Q.rotate(i.rotation), Q.scale(n, r), i.program(Q), Q.restore()) : i.isPointsMaterial && (y(i.color.getStyle()), Q.save(), Q.translate(t.x, t.y), 0 !== i.rotation && Q.rotate(i.rotation), Q.scale(n * i.size, -r * i.size), Q.fillRect(-.5, -.5, 1, 1), Q.restore())
        }

        function r(t, e, i, n) {
            if (d(n.opacity), p(n.blending), Q.beginPath(), Q.moveTo(t.positionScreen.x, t.positionScreen.y), Q.lineTo(e.positionScreen.x, e.positionScreen.y), n.isLineBasicMaterial) {
                if (f(n.linewidth), m(n.linecap), g(n.linejoin), n.vertexColors !== THREE.VertexColors) v(n.color.getStyle());
                else {
                    var r = i.vertexColors[0].getStyle(),
                        o = i.vertexColors[1].getStyle();
                    if (r === o) v(r);
                    else {
                        try {
                            var a = Q.createLinearGradient(t.positionScreen.x, t.positionScreen.y, e.positionScreen.x, e.positionScreen.y);
                            a.addColorStop(0, r), a.addColorStop(1, o)
                        } catch (t) {
                            a = r
                        }
                        v(a)
                    }
                }
                Q.stroke(), mt.expandByScalar(2 * n.linewidth)
            } else n.isLineDashedMaterial && (f(n.linewidth), m(n.linecap), g(n.linejoin), v(n.color.getStyle()), _([n.dashSize, n.gapSize]), Q.stroke(), mt.expandByScalar(2 * n.linewidth), _([]))
        }

        function o(t, e, n, r, o, c, u, f) {
            if (F.info.render.vertices += 3, F.info.render.faces++, d(f.opacity), p(f.blending), E = t.positionScreen.x, A = t.positionScreen.y, C = e.positionScreen.x, P = e.positionScreen.y, R = n.positionScreen.x, L = n.positionScreen.y, a(E, A, C, P, R, L), (f.isMeshLambertMaterial || f.isMeshPhongMaterial || f.isMeshStandardMaterial) && null === f.map) ct.copy(f.color), ht.copy(f.emissive), f.vertexColors === THREE.FaceColors && ct.multiply(u.color), lt.copy(gt), xt.copy(t.positionWorld).add(e.positionWorld).add(n.positionWorld).divideScalar(3), i(xt, u.normalModel, lt), lt.multiply(ct).add(ht), f.wireframe === !0 ? s(lt, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : l(lt);
            else if (f.isMeshBasicMaterial || f.isMeshLambertMaterial || f.isMeshPhongMaterial || f.isMeshStandardMaterial)
                if (null !== f.map) {
                    var m = f.map.mapping;
                    m === THREE.UVMapping && (k = u.uvs, h(E, A, C, P, R, L, k[r].x, k[r].y, k[o].x, k[o].y, k[c].x, k[c].y, f.map))
                } else null !== f.envMap ? f.envMap.mapping === THREE.SphericalReflectionMapping && (bt.copy(u.vertexNormalsModel[r]).applyMatrix3(wt), O = .5 * bt.x + .5, D = .5 * bt.y + .5, bt.copy(u.vertexNormalsModel[o]).applyMatrix3(wt), I = .5 * bt.x + .5, N = .5 * bt.y + .5, bt.copy(u.vertexNormalsModel[c]).applyMatrix3(wt), B = .5 * bt.x + .5, U = .5 * bt.y + .5, h(E, A, C, P, R, L, O, D, I, N, B, U, f.envMap)) : (lt.copy(f.color), f.vertexColors === THREE.FaceColors && lt.multiply(u.color), f.wireframe === !0 ? s(lt, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : l(lt));
            else f.isMeshNormalMaterial ? (bt.copy(u.normalModel).applyMatrix3(wt), lt.setRGB(bt.x, bt.y, bt.z).multiplyScalar(.5).addScalar(.5), f.wireframe === !0 ? s(lt, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : l(lt)) : (lt.setRGB(1, 1, 1), f.wireframe === !0 ? s(lt, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : l(lt))
        }

        function a(t, e, i, n, r, o) {
            Q.beginPath(), Q.moveTo(t, e), Q.lineTo(i, n), Q.lineTo(r, o), Q.closePath()
        }

        function s(t, e, i, n) {
            f(e), m(i), g(n), v(t.getStyle()), Q.stroke(), mt.expandByScalar(2 * e)
        }

        function l(t) {
            y(t.getStyle()), Q.fill()
        }

        function c(t) {
            if (0 === t.version || t instanceof THREE.CompressedTexture || t instanceof THREE.DataTexture) return {
                canvas: void 0,
                version: t.version
            };
            var e = t.image;
            if (e.complete === !1) return {
                canvas: void 0,
                version: 0
            };
            var i = t.wrapS === THREE.RepeatWrapping || t.wrapS === THREE.MirroredRepeatWrapping,
                n = t.wrapT === THREE.RepeatWrapping || t.wrapT === THREE.MirroredRepeatWrapping,
                r = t.wrapS === THREE.MirroredRepeatWrapping,
                o = t.wrapT === THREE.MirroredRepeatWrapping,
                a = document.createElement("canvas");
            a.width = e.width * (r ? 2 : 1), a.height = e.height * (o ? 2 : 1);
            var s = a.getContext("2d");
            s.setTransform(1, 0, 0, -1, 0, e.height), s.drawImage(e, 0, 0), r === !0 && (s.setTransform(-1, 0, 0, -1, e.width, e.height), s.drawImage(e, -e.width, 0)), o === !0 && (s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(e, 0, e.height)), r === !0 && o === !0 && (s.setTransform(-1, 0, 0, 1, e.width, 0), s.drawImage(e, -e.width, e.height));
            var l = "no-repeat";
            i === !0 && n === !0 ? l = "repeat" : i === !0 ? l = "repeat-x" : n === !0 && (l = "repeat-y");
            var c = Q.createPattern(a, l);
            return t.onUpdate && t.onUpdate(t), {
                canvas: c,
                version: t.version
            }
        }

        function h(t, e, i, n, r, o, a, s, l, h, u, d, p) {
            var f = dt[p.id];
            if (void 0 !== f && f.version === p.version || (f = c(p), dt[p.id] = f), void 0 === f.canvas) return y("rgba( 0, 0, 0, 1)"), void Q.fill();
            y(f.canvas);
            var m, g, v, _, x, b, w, T, S = p.offset.x / p.repeat.x,
                M = p.offset.y / p.repeat.y,
                E = p.image.width * p.repeat.x,
                A = p.image.height * p.repeat.y;
            a = (a + S) * E, s = (s + M) * A, l = (l + S) * E, h = (h + M) * A, u = (u + S) * E, d = (d + M) * A, i -= t, n -= e, r -= t, o -= e, l -= a, h -= s, u -= a, d -= s, w = l * d - u * h, 0 !== w && (T = 1 / w, m = (d * i - h * r) * T, g = (d * n - h * o) * T, v = (l * r - u * i) * T, _ = (l * o - u * n) * T, x = t - m * a - v * s, b = e - g * a - _ * s, Q.save(), Q.transform(m, g, v, _, x, b), Q.fill(), Q.restore())
        }

        function u(t, e, i) {
            var n, r = e.x - t.x,
                o = e.y - t.y,
                a = r * r + o * o;
            0 !== a && (n = i / Math.sqrt(a), r *= n, o *= n, e.x += r, e.y += o, t.x -= r, t.y -= o)
        }

        function d(t) {
            tt !== t && (Q.globalAlpha = t, tt = t)
        }

        function p(t) {
            et !== t && (t === THREE.NormalBlending ? Q.globalCompositeOperation = "source-over" : t === THREE.AdditiveBlending ? Q.globalCompositeOperation = "lighter" : t === THREE.SubtractiveBlending ? Q.globalCompositeOperation = "darker" : t === THREE.MultiplyBlending && (Q.globalCompositeOperation = "multiply"), et = t)
        }

        function f(t) {
            rt !== t && (Q.lineWidth = t, rt = t)
        }

        function m(t) {
            ot !== t && (Q.lineCap = t, ot = t)
        }

        function g(t) {
            at !== t && (Q.lineJoin = t, at = t)
        }

        function v(t) {
            it !== t && (Q.strokeStyle = t, it = t)
        }

        function y(t) {
            nt !== t && (Q.fillStyle = t, nt = t)
        }

        function _(t) {
            st.length !== t.length && (Q.setLineDash(t), st = t)
        }
        console.log("THREE.CanvasRenderer", THREE.REVISION), t = t || {};
        var x, b, w, T, S, M, E, A, C, P, R, L, k, O, D, I, N, B, U, F = this,
            z = new THREE.Projector,
            H = void 0 !== t.canvas ? t.canvas : document.createElement("canvas"),
            j = H.width,
            G = H.height,
            V = Math.floor(j / 2),
            W = Math.floor(G / 2),
            X = 0,
            q = 0,
            $ = j,
            Y = G,
            Z = 1,
            Q = H.getContext("2d", {
                alpha: t.alpha === !0
            }),
            J = new THREE.Color(0),
            K = t.alpha === !0 ? 0 : 1,
            tt = 1,
            et = 0,
            it = null,
            nt = null,
            rt = null,
            ot = null,
            at = null,
            st = [],
            lt = new THREE.Color,
            ct = new THREE.Color,
            ht = new THREE.Color,
            ut = new THREE.Color,
            dt = {},
            pt = new THREE.Box2,
            ft = new THREE.Box2,
            mt = new THREE.Box2,
            gt = new THREE.Color,
            vt = new THREE.Color,
            yt = new THREE.Color,
            _t = new THREE.Vector3,
            xt = new THREE.Vector3,
            bt = new THREE.Vector3,
            wt = new THREE.Matrix3;
        void 0 === Q.setLineDash && (Q.setLineDash = function() {}), this.domElement = H, this.autoClear = !0, this.sortObjects = !0, this.sortElements = !0, this.info = {
            render: {
                vertices: 0,
                faces: 0
            }
        }, this.supportsVertexTextures = function() {}, this.setFaceCulling = function() {}, this.getContext = function() {
            return Q
        }, this.getContextAttributes = function() {
            return Q.getContextAttributes()
        }, this.getPixelRatio = function() {
            return Z
        }, this.setPixelRatio = function(t) {
            void 0 !== t && (Z = t)
        }, this.setSize = function(t, e, i) {
            j = t * Z, G = e * Z, H.width = j, H.height = G, V = Math.floor(j / 2), W = Math.floor(G / 2), i !== !1 && (H.style.width = t + "px", H.style.height = e + "px"), pt.min.set(-V, -W), pt.max.set(V, W), ft.min.set(-V, -W), ft.max.set(V, W), tt = 1, et = 0, it = null, nt = null, rt = null, ot = null, at = null, this.setViewport(0, 0, t, e)
        }, this.setViewport = function(t, e, i, n) {
            X = t * Z, q = e * Z, $ = i * Z, Y = n * Z
        }, this.setScissor = function() {}, this.setScissorTest = function() {}, this.setClearColor = function(t, e) {
            J.set(t), K = void 0 !== e ? e : 1, ft.min.set(-V, -W), ft.max.set(V, W)
        }, this.setClearColorHex = function(t, e) {
            console.warn("THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(t, e)
        }, this.getClearColor = function() {
            return J
        }, this.getClearAlpha = function() {
            return K
        }, this.getMaxAnisotropy = function() {
            return 0
        }, this.clear = function() {
            ft.isEmpty() === !1 && (ft.intersect(pt), ft.expandByScalar(2), ft.min.x = ft.min.x + V, ft.min.y = -ft.min.y + W, ft.max.x = ft.max.x + V, ft.max.y = -ft.max.y + W, K < 1 && Q.clearRect(0 | ft.min.x, 0 | ft.max.y, ft.max.x - ft.min.x | 0, ft.min.y - ft.max.y | 0), K > 0 && (p(THREE.NormalBlending), d(1), y("rgba(" + Math.floor(255 * J.r) + "," + Math.floor(255 * J.g) + "," + Math.floor(255 * J.b) + "," + K + ")"), Q.fillRect(0 | ft.min.x, 0 | ft.max.y, ft.max.x - ft.min.x | 0, ft.min.y - ft.max.y | 0)), ft.makeEmpty())
        }, this.clearColor = function() {}, this.clearDepth = function() {}, this.clearStencil = function() {}, this.render = function(t, i) {
            if (void 0 === i.isCamera) return void console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
            var a = t.background;
            a && a.isColor ? (y("rgb(" + Math.floor(255 * a.r) + "," + Math.floor(255 * a.g) + "," + Math.floor(255 * a.b) + ")"), Q.fillRect(0, 0, j, G)) : this.autoClear === !0 && this.clear(), F.info.render.vertices = 0, F.info.render.faces = 0, Q.setTransform($ / j, 0, 0, -Y / G, X, G - q), Q.translate(V, W), x = z.projectScene(t, i, this.sortObjects, this.sortElements), b = x.elements, w = x.lights, wt.getNormalMatrix(i.matrixWorldInverse), e();
            for (var s = 0, l = b.length; s < l; s++) {
                var c = b[s],
                    h = c.material;
                if (void 0 !== h && 0 !== h.opacity) {
                    if (mt.makeEmpty(), c instanceof THREE.RenderableSprite) T = c, T.x *= V, T.y *= W, n(T, c, h);
                    else if (c instanceof THREE.RenderableLine) T = c.v1, S = c.v2, T.positionScreen.x *= V, T.positionScreen.y *= W, S.positionScreen.x *= V, S.positionScreen.y *= W, mt.setFromPoints([T.positionScreen, S.positionScreen]), pt.intersectsBox(mt) === !0 && r(T, S, c, h);
                    else if (c instanceof THREE.RenderableFace) {
                        if (T = c.v1, S = c.v2, M = c.v3, T.positionScreen.z < -1 || T.positionScreen.z > 1) continue;
                        if (S.positionScreen.z < -1 || S.positionScreen.z > 1) continue;
                        if (M.positionScreen.z < -1 || M.positionScreen.z > 1) continue;
                        T.positionScreen.x *= V, T.positionScreen.y *= W, S.positionScreen.x *= V, S.positionScreen.y *= W, M.positionScreen.x *= V, M.positionScreen.y *= W, h.overdraw > 0 && (u(T.positionScreen, S.positionScreen, h.overdraw), u(S.positionScreen, M.positionScreen, h.overdraw), u(M.positionScreen, T.positionScreen, h.overdraw)), mt.setFromPoints([T.positionScreen, S.positionScreen, M.positionScreen]), pt.intersectsBox(mt) === !0 && o(T, S, M, 0, 1, 2, c, h)
                    }
                    ft.union(mt)
                }
            }
            Q.setTransform(1, 0, 0, 1, 0, 0)
        }
    }
}, function(t, e) {
    THREE.RenderableObject = function() {
        this.id = 0, this.object = null, this.z = 0, this.renderOrder = 0
    }, THREE.RenderableFace = function() {
        this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.v3 = new THREE.RenderableVertex, this.normalModel = new THREE.Vector3, this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], this.vertexNormalsLength = 0, this.color = new THREE.Color, this.material = null, this.uvs = [new THREE.Vector2, new THREE.Vector2, new THREE.Vector2], this.z = 0, this.renderOrder = 0
    }, THREE.RenderableVertex = function() {
        this.position = new THREE.Vector3, this.positionWorld = new THREE.Vector3, this.positionScreen = new THREE.Vector4, this.visible = !0
    }, THREE.RenderableVertex.prototype.copy = function(t) {
        this.positionWorld.copy(t.positionWorld), this.positionScreen.copy(t.positionScreen)
    }, THREE.RenderableLine = function() {
        this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.vertexColors = [new THREE.Color, new THREE.Color], this.material = null, this.z = 0, this.renderOrder = 0
    }, THREE.RenderableSprite = function() {
        this.id = 0, this.object = null, this.x = 0, this.y = 0, this.z = 0, this.rotation = 0, this.scale = new THREE.Vector2, this.material = null, this.renderOrder = 0
    }, THREE.Projector = function() {
        function t(i) {
            if (i.visible !== !1) {
                if (i instanceof THREE.Light) L.lights.push(i);
                else if (i instanceof THREE.Mesh || i instanceof THREE.Line || i instanceof THREE.Points) {
                    if (i.material.visible === !1) return;
                    if (i.frustumCulled === !0 && H.intersectsObject(i) === !1) return;
                    e(i)
                } else if (i instanceof THREE.Sprite) {
                    if (i.material.visible === !1) return;
                    if (i.frustumCulled === !0 && H.intersectsSprite(i) === !1) return;
                    e(i)
                }
                for (var n = i.children, r = 0, o = n.length; r < o; r++) t(n[r])
            }
        }

        function e(t) {
            h = n(), h.id = t.id, h.object = t, k.setFromMatrixPosition(t.matrixWorld), k.applyMatrix4(U), h.z = k.z, h.renderOrder = t.renderOrder, L.objects.push(h)
        }

        function i(t, e, i) {
            var n = 1 / t.w;
            t.z *= n, t.z >= -1 && t.z <= 1 && (y = s(), y.id = e.id, y.x = t.x * n, y.y = t.y * n, y.z = t.z, y.renderOrder = e.renderOrder, y.object = e, y.rotation = e.rotation, y.scale.x = e.scale.x * Math.abs(y.x - (t.x + i.projectionMatrix.elements[0]) / (t.w + i.projectionMatrix.elements[12])), y.scale.y = e.scale.y * Math.abs(y.y - (t.y + i.projectionMatrix.elements[5]) / (t.w + i.projectionMatrix.elements[13])), y.material = e.material, L.elements.push(y))
        }

        function n() {
            if (u === w) {
                var t = new THREE.RenderableObject;
                return b.push(t), w++, u++, t
            }
            return b[u++]
        }

        function r() {
            if (p === S) {
                var t = new THREE.RenderableVertex;
                return T.push(t), S++, p++, t
            }
            return T[p++]
        }

        function o() {
            if (m === E) {
                var t = new THREE.RenderableFace;
                return M.push(t), E++, m++, t
            }
            return M[m++]
        }

        function a() {
            if (v === C) {
                var t = new THREE.RenderableLine;
                return A.push(t), C++, v++, t
            }
            return A[v++]
        }

        function s() {
            if (_ === R) {
                var t = new THREE.RenderableSprite;
                return P.push(t), R++, _++, t
            }
            return P[_++]
        }

        function l(t, e) {
            return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id !== e.id ? t.id - e.id : 0
        }

        function c(t, e) {
            var i = 0,
                n = 1,
                r = t.z + t.w,
                o = e.z + e.w,
                a = -t.z + t.w,
                s = -e.z + e.w;
            return r >= 0 && o >= 0 && a >= 0 && s >= 0 || !(r < 0 && o < 0 || a < 0 && s < 0) && (r < 0 ? i = Math.max(i, r / (r - o)) : o < 0 && (n = Math.min(n, r / (r - o))), a < 0 ? i = Math.max(i, a / (a - s)) : s < 0 && (n = Math.min(n, a / (a - s))), !(n < i) && (t.lerp(e, i), e.lerp(t, 1 - n), !0))
        }
        var h, u, d, p, f, m, g, v, y, _, x, b = [],
            w = 0,
            T = [],
            S = 0,
            M = [],
            E = 0,
            A = [],
            C = 0,
            P = [],
            R = 0,
            L = {
                objects: [],
                lights: [],
                elements: []
            },
            k = new THREE.Vector3,
            O = new THREE.Vector4,
            D = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
            I = new THREE.Box3,
            N = new Array(3),
            B = new THREE.Matrix4,
            U = new THREE.Matrix4,
            F = new THREE.Matrix4,
            z = new THREE.Matrix3,
            H = new THREE.Frustum,
            j = new THREE.Vector4,
            G = new THREE.Vector4;
        this.projectVector = function(t, e) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
        }, this.unprojectVector = function(t, e) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
        }, this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        };
        var V = function() {
                function t(t) {
                    b = t, w = b.material, S.getNormalMatrix(b.matrixWorld), v.length = 0, y.length = 0, _.length = 0
                }

                function e(t) {
                    var e = t.position,
                        i = t.positionWorld,
                        n = t.positionScreen;
                    i.copy(e).applyMatrix4(x), n.copy(i).applyMatrix4(U);
                    var r = 1 / n.w;
                    n.x *= r, n.y *= r, n.z *= r, t.visible = n.x >= -1 && n.x <= 1 && n.y >= -1 && n.y <= 1 && n.z >= -1 && n.z <= 1
                }

                function i(t, i, n) {
                    d = r(), d.position.set(t, i, n), e(d)
                }

                function n(t, e, i) {
                    v.push(t, e, i)
                }

                function s(t, e, i) {
                    y.push(t, e, i)
                }

                function l(t, e) {
                    _.push(t, e)
                }

                function h(t, e, i) {
                    return t.visible === !0 || e.visible === !0 || i.visible === !0 || (N[0] = t.positionScreen, N[1] = e.positionScreen, N[2] = i.positionScreen, D.intersectsBox(I.setFromPoints(N)))
                }

                function u(t, e, i) {
                    return (i.positionScreen.x - t.positionScreen.x) * (e.positionScreen.y - t.positionScreen.y) - (i.positionScreen.y - t.positionScreen.y) * (e.positionScreen.x - t.positionScreen.x) < 0
                }

                function p(t, e) {
                    var i = T[t],
                        n = T[e];
                    i.positionScreen.copy(i.position).applyMatrix4(F), n.positionScreen.copy(n.position).applyMatrix4(F), c(i.positionScreen, n.positionScreen) === !0 && (i.positionScreen.multiplyScalar(1 / i.positionScreen.w), n.positionScreen.multiplyScalar(1 / n.positionScreen.w), g = a(), g.id = b.id, g.v1.copy(i), g.v2.copy(n), g.z = Math.max(i.positionScreen.z, n.positionScreen.z), g.renderOrder = b.renderOrder, g.material = b.material, b.material.vertexColors === THREE.VertexColors && (g.vertexColors[0].fromArray(y, 3 * t), g.vertexColors[1].fromArray(y, 3 * e)), L.elements.push(g))
                }

                function m(t, e, i) {
                    var n = T[t],
                        r = T[e],
                        a = T[i];
                    if (h(n, r, a) !== !1 && (w.side === THREE.DoubleSide || u(n, r, a) === !0)) {
                        f = o(), f.id = b.id, f.v1.copy(n), f.v2.copy(r), f.v3.copy(a), f.z = (n.positionScreen.z + r.positionScreen.z + a.positionScreen.z) / 3, f.renderOrder = b.renderOrder, f.normalModel.fromArray(v, 3 * t), f.normalModel.applyMatrix3(S).normalize();
                        for (var s = 0; s < 3; s++) {
                            var l = f.vertexNormalsModel[s];
                            l.fromArray(v, 3 * arguments[s]), l.applyMatrix3(S).normalize();
                            var c = f.uvs[s];
                            c.fromArray(_, 2 * arguments[s])
                        }
                        f.vertexNormalsLength = 3, f.material = b.material, L.elements.push(f)
                    }
                }
                var v = [],
                    y = [],
                    _ = [],
                    b = null,
                    w = null,
                    S = new THREE.Matrix3;
                return {
                    setObject: t,
                    projectVertex: e,
                    checkTriangleVisibility: h,
                    checkBackfaceCulling: u,
                    pushVertex: i,
                    pushNormal: n,
                    pushColor: s,
                    pushUv: l,
                    pushLine: p,
                    pushTriangle: m
                }
            },
            W = new V;
        this.projectScene = function(e, n, s, h) {
            m = 0, v = 0, _ = 0, L.elements.length = 0, e.autoUpdate === !0 && e.updateMatrixWorld(), null === n.parent && n.updateMatrixWorld(), B.copy(n.matrixWorldInverse.getInverse(n.matrixWorld)), U.multiplyMatrices(n.projectionMatrix, B), H.setFromMatrix(U), u = 0, L.objects.length = 0, L.lights.length = 0, t(e), s === !0 && L.objects.sort(l);
            for (var d = L.objects, y = 0, b = d.length; y < b; y++) {
                var w = d[y].object,
                    S = w.geometry;
                if (W.setObject(w), x = w.matrixWorld, p = 0, w instanceof THREE.Mesh) {
                    if (S instanceof THREE.BufferGeometry) {
                        var M = S.attributes,
                            E = S.groups;
                        if (void 0 === M.position) continue;
                        for (var A = M.position.array, C = 0, P = A.length; C < P; C += 3) W.pushVertex(A[C], A[C + 1], A[C + 2]);
                        if (void 0 !== M.normal)
                            for (var R = M.normal.array, C = 0, P = R.length; C < P; C += 3) W.pushNormal(R[C], R[C + 1], R[C + 2]);
                        if (void 0 !== M.uv)
                            for (var D = M.uv.array, C = 0, P = D.length; C < P; C += 2) W.pushUv(D[C], D[C + 1]);
                        if (null !== S.index) {
                            var I = S.index.array;
                            if (E.length > 0)
                                for (var N = 0; N < E.length; N++)
                                    for (var V = E[N], C = V.start, P = V.start + V.count; C < P; C += 3) W.pushTriangle(I[C], I[C + 1], I[C + 2]);
                            else
                                for (var C = 0, P = I.length; C < P; C += 3) W.pushTriangle(I[C], I[C + 1], I[C + 2])
                        } else
                            for (var C = 0, P = A.length / 3; C < P; C += 3) W.pushTriangle(C, C + 1, C + 2)
                    } else if (S instanceof THREE.Geometry) {
                        var X = S.vertices,
                            q = S.faces,
                            $ = S.faceVertexUvs[0];
                        z.getNormalMatrix(x);
                        for (var Y = w.material, Z = Array.isArray(Y), Q = 0, J = X.length; Q < J; Q++) {
                            var K = X[Q];
                            if (k.copy(K), Y.morphTargets === !0)
                                for (var tt = S.morphTargets, et = w.morphTargetInfluences, it = 0, nt = tt.length; it < nt; it++) {
                                    var rt = et[it];
                                    if (0 !== rt) {
                                        var ot = tt[it],
                                            at = ot.vertices[Q];
                                        k.x += (at.x - K.x) * rt, k.y += (at.y - K.y) * rt, k.z += (at.z - K.z) * rt
                                    }
                                }
                            W.pushVertex(k.x, k.y, k.z)
                        }
                        for (var st = 0, lt = q.length; st < lt; st++) {
                            var ct = q[st];
                            if (Y = Z === !0 ? w.material[ct.materialIndex] : w.material, void 0 !== Y) {
                                var ht = Y.side,
                                    ut = T[ct.a],
                                    dt = T[ct.b],
                                    pt = T[ct.c];
                                if (W.checkTriangleVisibility(ut, dt, pt) !== !1) {
                                    var ft = W.checkBackfaceCulling(ut, dt, pt);
                                    if (ht !== THREE.DoubleSide) {
                                        if (ht === THREE.FrontSide && ft === !1) continue;
                                        if (ht === THREE.BackSide && ft === !0) continue
                                    }
                                    f = o(), f.id = w.id, f.v1.copy(ut), f.v2.copy(dt), f.v3.copy(pt), f.normalModel.copy(ct.normal), ft !== !1 || ht !== THREE.BackSide && ht !== THREE.DoubleSide || f.normalModel.negate(), f.normalModel.applyMatrix3(z).normalize();
                                    for (var mt = ct.vertexNormals, gt = 0, vt = Math.min(mt.length, 3); gt < vt; gt++) {
                                        var yt = f.vertexNormalsModel[gt];
                                        yt.copy(mt[gt]), ft !== !1 || ht !== THREE.BackSide && ht !== THREE.DoubleSide || yt.negate(), yt.applyMatrix3(z).normalize()
                                    }
                                    f.vertexNormalsLength = mt.length;
                                    var _t = $[st];
                                    if (void 0 !== _t)
                                        for (var xt = 0; xt < 3; xt++) f.uvs[xt].copy(_t[xt]);
                                    f.color = ct.color, f.material = Y, f.z = (ut.positionScreen.z + dt.positionScreen.z + pt.positionScreen.z) / 3, f.renderOrder = w.renderOrder, L.elements.push(f)
                                }
                            }
                        }
                    }
                } else if (w instanceof THREE.Line) {
                    if (F.multiplyMatrices(U, x), S instanceof THREE.BufferGeometry) {
                        var M = S.attributes;
                        if (void 0 !== M.position) {
                            for (var A = M.position.array, C = 0, P = A.length; C < P; C += 3) W.pushVertex(A[C], A[C + 1], A[C + 2]);
                            if (void 0 !== M.color)
                                for (var bt = M.color.array, C = 0, P = bt.length; C < P; C += 3) W.pushColor(bt[C], bt[C + 1], bt[C + 2]);
                            if (null !== S.index)
                                for (var I = S.index.array, C = 0, P = I.length; C < P; C += 2) W.pushLine(I[C], I[C + 1]);
                            else
                                for (var wt = w instanceof THREE.LineSegments ? 2 : 1, C = 0, P = A.length / 3 - 1; C < P; C += wt) W.pushLine(C, C + 1)
                        }
                    } else if (S instanceof THREE.Geometry) {
                        var X = w.geometry.vertices;
                        if (0 === X.length) continue;
                        ut = r(), ut.positionScreen.copy(X[0]).applyMatrix4(F);
                        for (var wt = w instanceof THREE.LineSegments ? 2 : 1, Q = 1, J = X.length; Q < J; Q++) ut = r(), ut.positionScreen.copy(X[Q]).applyMatrix4(F), (Q + 1) % wt > 0 || (dt = T[p - 2], j.copy(ut.positionScreen), G.copy(dt.positionScreen), c(j, G) === !0 && (j.multiplyScalar(1 / j.w), G.multiplyScalar(1 / G.w), g = a(), g.id = w.id, g.v1.positionScreen.copy(j), g.v2.positionScreen.copy(G), g.z = Math.max(j.z, G.z), g.renderOrder = w.renderOrder, g.material = w.material, w.material.vertexColors === THREE.VertexColors && (g.vertexColors[0].copy(w.geometry.colors[Q]), g.vertexColors[1].copy(w.geometry.colors[Q - 1])), L.elements.push(g)))
                    }
                } else if (w instanceof THREE.Points) {
                    if (F.multiplyMatrices(U, x), S instanceof THREE.Geometry)
                        for (var X = w.geometry.vertices, Q = 0, J = X.length; Q < J; Q++) {
                            var K = X[Q];
                            O.set(K.x, K.y, K.z, 1), O.applyMatrix4(F), i(O, w, n)
                        }
                } else w instanceof THREE.Sprite && (O.set(x.elements[12], x.elements[13], x.elements[14], 1), O.applyMatrix4(U), i(O, w, n))
            }
            return h === !0 && L.elements.sort(l), L
        }
    }
}, function(t, e) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = function() {
        Element.prototype.matches || (Element.prototype.matches = function(t) {
            for (var e = this, i = (e.document || e.ownerDocument).querySelectorAll(t), n = 0; i[n] && i[n] !== e;) ++n;
            return Boolean(i[n])
        }), Element.prototype.closest || (Element.prototype.closest = function(t) {
            for (var e = this; e;) {
                if (e.matches(t)) return e;
                e = e.parentElement
            }
            return null
        }), "function" != typeof Object.assign && (Object.assign = function(t, e) {
            if (null == t) throw new TypeError("Cannot convert undefined or null to object");
            for (var i = Object(t), n = 1; n < arguments.length; n++) {
                var r = arguments[n];
                if (null != r)
                    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (i[o] = r[o])
            }
            return i
        })
    }
}, function(t, e, i) {
    "use strict";

    function n(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = i(1),
        o = n(r);
    e.default = function() {
        (function() {
            var t;
            t = (0, o.default)(window), o.default.fn.stick_in_parent = function(e) {
                var i, n, r, a, s, l, c, h, u, d, p, f, m;
                for (null == e && (e = {}), m = e.sticky_class, l = e.inner_scrolling, f = e.recalc_every, p = e.parent, u = e.offset_top, h = e.spacer, r = e.bottoming, null == u && (u = 0), null == p && (p = void 0), null == l && (l = !0), null == m && (m = "is_stuck"), i = (0, o.default)(document), null == r && (r = !0), d = function(t) {
                        var e, i, n;
                        return window.getComputedStyle ? (e = t[0], i = window.getComputedStyle(t[0]), n = parseFloat(i.getPropertyValue("width")) + parseFloat(i.getPropertyValue("margin-left")) + parseFloat(i.getPropertyValue("margin-right")), "border-box" !== i.getPropertyValue("box-sizing") && (n += parseFloat(i.getPropertyValue("border-left-width")) + parseFloat(i.getPropertyValue("border-right-width")) + parseFloat(i.getPropertyValue("padding-left")) + parseFloat(i.getPropertyValue("padding-right"))), n) : t.outerWidth(!0)
                    }, a = function(e, n, a, s, c, g, v, y) {
                        var _, x, b, w, T, S, M, E, A, C, P, R;
                        if (!e.data("sticky_kit")) {
                            if (e.data("sticky_kit", !0), T = i.height(), M = e.parent(), null != p && (M = M.closest(p)), !M.length) throw "failed to find stick parent";
                            if (b = !1, _ = !1, P = null != h ? h && e.closest(h) : (0, o.default)("<div />"), P && P.css("position", e.css("position")), E = function() {
                                    var t, r, o;
                                    if (!y) return T = i.height(), t = parseInt(M.css("border-top-width"), 10), r = parseInt(M.css("padding-top"), 10), n = parseInt(M.css("padding-bottom"), 10), a = M.offset().top + t + r, s = M.height(), b && (b = !1, _ = !1, null == h && (e.insertAfter(P), P.detach()), e.css({
                                        position: "",
                                        top: "",
                                        width: "",
                                        bottom: ""
                                    }).removeClass(m), o = !0), c = e.offset().top - (parseInt(e.css("margin-top"), 10) || 0) - u, g = e.outerHeight(!0), v = e.css("float"), P && P.css({
                                        width: d(e),
                                        height: g,
                                        display: e.css("display"),
                                        "vertical-align": e.css("vertical-align"),
                                        float: v
                                    }), o ? R() : void 0
                                }, E(), g !== s) return w = void 0, S = u, C = f, R = function() {
                                var o, d, p, x, A, R;
                                if (!y) return p = !1, null != C && (C -= 1, C <= 0 && (C = f, E(), p = !0)), p || i.height() === T || (E(), p = !0), x = t.scrollTop(), null != w && (d = x - w), w = x, b ? (r && (A = x + g + S > s + a, _ && !A && (_ = !1, e.css({
                                    position: "fixed",
                                    bottom: "",
                                    top: S
                                }).trigger("sticky_kit:unbottom"))), x < c && (b = !1, S = u, null == h && ("left" !== v && "right" !== v || e.insertAfter(P), P.detach()), o = {
                                    position: "",
                                    width: "",
                                    top: ""
                                }, e.css(o).removeClass(m).trigger("sticky_kit:unstick")), l && (R = t.height(), g + u > R && (_ || (S -= d, S = Math.max(R - g, S), S = Math.min(u, S), b && e.css({
                                    top: S + "px"
                                }))))) : x > c && (b = !0, o = {
                                    position: "fixed",
                                    top: S
                                }, o.width = "border-box" === e.css("box-sizing") ? e.outerWidth() + "px" : e.width() + "px", e.css(o).addClass(m), null == h && (e.after(P), "left" !== v && "right" !== v || P.append(e)), e.trigger("sticky_kit:stick")), b && r && (null == A && (A = x + g + S > s + a), !_ && A) ? (_ = !0, "static" === M.css("position") && M.css({
                                    position: "relative"
                                }), e.css({
                                    position: "absolute",
                                    bottom: n,
                                    top: "auto"
                                }).trigger("sticky_kit:bottom")) : void 0
                            }, A = function() {
                                return E(), R()
                            }, x = function() {
                                if (y = !0, t.off("touchmove", R), t.off("scroll", R), t.off("resize", A), (0, o.default)(document.body).off("sticky_kit:recalc", A), e.off("sticky_kit:detach", x), e.removeData("sticky_kit"), e.css({
                                        position: "",
                                        bottom: "",
                                        top: "",
                                        width: ""
                                    }), M.position("position", ""), b) return null == h && ("left" !== v && "right" !== v || e.insertAfter(P), P.remove()), e.removeClass(m)
                            }, t.on("touchmove", R), t.on("scroll", R), t.on("resize", A), (0, o.default)(document.body).on("sticky_kit:recalc", A), e.on("sticky_kit:detach", x), setTimeout(R, 0)
                        }
                    }, s = 0, c = this.length; s < c; s++) n = this[s], a((0, o.default)(n));
                return this
            }
        }).call(void 0), window.innerWidth > 1250 && (0, o.default)(".portfolio-inner .description-box").stick_in_parent({
            offset_top: 92
        }), window.innerWidth > 1023 && (0, o.default)(".keys-sidebar").stick_in_parent({
            offset_top: 92
        })
    }
}, function(t, e) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = function() {
        $("img.svg").each(function() {
            var t = jQuery(this),
                e = t.attr("id"),
                i = t.attr("class"),
                n = t.attr("src");
            jQuery.get(n, function(n) {
                var r = jQuery(n).find("svg");
                "undefined" != typeof e && (r = r.attr("id", e)), "undefined" != typeof i && (r = r.attr("class", i + " replaced-svg")), r = r.removeAttr("xmlns:a"), !r.attr("viewBox") && r.attr("height") && r.attr("width") && r.attr("viewBox", "0 0 " + r.attr("height") + " " + r.attr("width")), t.replaceWith(r)
            }, "xml")
        })
    }
}, function(t, e) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    }), e.default = function() {
        ! function() {
            function t(t) {
                var e = document.cookie.match(new RegExp("(?:^|; )" + t.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1") + "=([^;]*)"));
                return e ? decodeURIComponent(e[1]) : void 0
            }
            $(".lemonschool").on("click", function() {
                document.cookie = "lemonschool=false", $(this).css("display", "none")
            }), "false" != t("lemonschool") && $(".lemonschool").css("display", "block")
        }(),
        function(t, e, i, n) {
            function r() {
                var t = 0;
                _.length && (_.css({
                    left: -99999
                }), setTimeout(function() {
                    var e = _.outerHeight();
                    x.height(e);
                    var n = x.offset().top,
                        r = i("#wrapper").height();
                    _.css({
                        bottom: r - n - e + t,
                        left: 0,
                        right: 0,
                        opacity: 1
                    })
                }, 400))
            }

            function o() {
                lamp = !1, i(".btn-bx em").removeClass("active")
            }
            var a = (i("body"), "MozAppearance" in e.documentElement.style),
                s = i(".blog-image"),
                l = !1,
                c = i(".about-us-info"),
                h = i(".video-slide"),
                u = e.getElementById("client-slider"),
                d = h.find("video"),
                p = e.getElementById("team-slider"),
                f = i(".portfolio-section .social-networks .heart"),
                m = !0,
                g = !0,
                v = i("#nav"),
                y = i(".navigation"),
                _ = i(".dom-top-block"),
                x = i(".dom-top-block-holder"),
                b = i("a.popup"),
                w = i(".arrow-top"),
                T = i(".manager-box"),
                S = T.outerHeight(),
                M = T.find(".callback"),
                E = i(".lang-list"),
                A = "",
                C = i("#big-slider");
            if (c.find("video").length && (d = c.find("video")), C.length) {
                var P = function() {
                        return 1 == t.stopHand ? (O.animate({
                            opacity: 0
                        }, 1e3, "swing"), !1) : void O.animate({
                            left: 132
                        }, 1500, "swing", L)
                    },
                    R = function() {
                        D.animate({
                            top: 0
                        }, {
                            duration: 10,
                            step: function(t, e) {
                                i(this).css("top", t)
                            },
                            complete: function() {
                                P()
                            }
                        }, "linear")
                    },
                    L = function() {
                        D.animate({
                            top: -750
                        }, {
                            duration: 10,
                            step: function(t, e) {
                                i(this).css("top", t)
                            },
                            complete: function() {
                                k()
                            }
                        }, "linear")
                    },
                    k = function() {
                        O.animate({
                            left: 0
                        }, 1500, "swing", R)
                    };
                C.animate({
                    opacity: 1
                }, 500), i(t).on("scroll", function() {
                    i(this).scrollTop() > h.height() && (h.find("video").prop("muted", !0), i(".video-slide .mute").addClass("disable"))
                });
                var O = i(".hand"),
                    D = O.find("svg");
                setTimeout(P, 2e3), C.owlCarousel({
                    loop: !1,
                    items: 1,
                    dots: !1
                }), h.find("video").get(0).play()
            }
            s.length && s.find("img").width() < 800 && s.addClass("image-left"), i(".jcf-scrollable, .jcf-select , .jcf-file").length && (jcf.setOptions("Select", {
                wrapNativeOnMobile: !1,
                wrapNative: !1,
                fakeDropInBody: !1
            }), jcf.replaceAll());
            var I = i("#video-box");
            if (i("body").on("click", ".video-opener", function(t) {
                    t.stopPropagation(), i(this).hasClass("jobs") ? i("#video-box").append('<iframe src="https://player.vimeo.com/video/274895532?autoplay=1&loop=1&autopause=0" width="640" height="360" frameborder="0" autoplay allowfullscreen></iframe>') : i("#video-box").append('<iframe src="https://player.vimeo.com/video/274895572?autoplay=1&loop=1&autopause=0" width="640" height="360" frameborder="0" autoplay allowfullscreen></iframe>'), setTimeout(function() {
                        I.toggle().animate({
                            top: 0
                        }, 500), I.find("video").get(0).play()
                    }, 500)
                }), I.find(".close-btn").click(function(t) {
                    t.stopPropagation(), I.animate({
                        top: -1e3
                    }, 500, function() {
                        i(this).css("display", "none"), i("#video-box").find("video").remove(), i("#video-box").find("iframe").remove()
                    })
                }), a || i(e).on("click", "video", function(t) {
                    t.stopPropagation(), i(this).get(0).paused ? i(this).get(0).play() : i(this).get(0).pause()
                }), c.length && !l) {
                var N = c.position().top + c.outerHeight();
                i(t).on("scroll", function() {
                    l && (i(this).scrollTop() >= N ? (d.prop("volume", 0), i(".mute").addClass("disable")) : (d.prop("volume", 1), i(".mute").removeClass("disable")))
                })
            }
            d.prop("muted", !0), i(".mute").addClass("disable"), i(e).on("click", ".mute", function(t) {
                t.stopPropagation(), l ? (d.prop("muted", !0), i(this).addClass("disable")) : (d.prop("muted", !1), i(this).removeClass("disable")), l = !l
            }), i(".close-btn").click(function() {
                i(this).parents(".close-content").css("display", "none")
            }), i(".popup-link").click(function() {
                i(".callback-form.wu-form").addClass("active")
            }), i(".callback-form.wu-form .close-btn").click(function() {
                i(this).parents(".callback-form.wu-form").removeClass("active")
            }), i("#art-carousel").length && ! function() {
                var t = i("#art-carousel"),
                    e = t.find("> li").length,
                    n = 1;
                t.find("> li").each(function() {
                    n <= e ? i(this).children("a").append("<em>" + n + "</em>") : i(this).children("a").append("<em>1</em>"), n++
                })
            }(), u && i("#client-slider").owlCarousel({
                loop: !0,
                items: 3,
                lazyLoad: !0,
                responsive: {
                    768: {
                        items: 1
                    },
                    1023: {
                        items: 2
                    },
                    1365: {
                        items: 3
                    }
                }
            }), p && i("#team-slider").owlCarousel({
                items: 5,
                loop: !0,
                dots: !1,
                stopOnHover: !0,
                pagination: !1,
                scrollPerPage: !1,
                addClassActive: !0,
                nav: !0,
                responsive: {
                    0: {
                        items: 1
                    },
                    768: {
                        items: 2
                    },
                    980: {
                        items: 3
                    },
                    1199: {
                        items: 4
                    },
                    1365: {
                        items: 5
                    }
                }
            }), i("a[href*=\\#]:not([href=\\#])").click(function() {
                if (location.pathname.replace(/^\//, "") == this.pathname.replace(/^\//, "") && location.hostname == this.hostname) {
                    var t = i(this.hash);
                    if (t = t.length ? t : i("[name=" + this.hash.slice(1) + "]"), t.length) return i("html,body").animate({
                        scrollTop: t.offset().top
                    }, 1e3), !1
                }
            }), i("a[href*=\\#tab]").click(function() {
                i("html,body").stop()
            }), i(e).on("click focus", "input.error,textarea.error", function() {
                i(this).removeClass("error")
            });
            var B = i("#comments"),
                U = i(".comment-form"),
                F = U.find("textarea");
            B.length && (F.focusin(function() {
                i(this).addClass("focus")
            }), F.focusout(function() {
                "" == i(this).val() && i(this).removeClass("focus")
            })), i(".bg").click(function() {
                i(this).parent().toggle()
            }), i(".usability-form .opener-form").click(function() {
                i(".popup-form.ui").toggle(), i(this).hasClass("item1") && i('input[name="popup-form-ui-packet"]').attr("value", "ÐÐ°ÐºÐµÑ1"), i(this).hasClass("item2") && i('input[name="popup-form-ui-packet"]').attr("value", "ÐÐ°ÐºÐµÑ2"), i(this).hasClass("item3") && i('input[name="popup-form-ui-packet"]').attr("value", "ÐÐ°ÐºÐµÑ3")
            }), i(".f-opener").click(function() {
                i("input#type").attr("value", i(this).parents("li").find("a.opener").text()), i(".alertj").toggle()
            }), f.click(function() {
                i(this).toggleClass("active"), i(this).hasClass("active") ? i(this).next("ul").animate({
                    height: 44,
                    opacity: 1
                }, 400) : i(this).next("ul").animate({
                    height: 0,
                    opacity: 0
                }, 200)
            }), i(".imperative-box ol").length && i(".imperative-box").each(function() {
                for (var t = i(this).find("li"), e = t.length / 2, n = 0; n < e; n++) t[n].className = t[n].className + "left"
            }), i(".mobile-phone").click(function() {
                i(this).toggleClass("active"), i(".mobile-phones").toggle()
            }), i(".navigation-box").on("click", ".menu-icon", function() {
                i(this).toggleClass("active"), v.animate({
                    width: "100%"
                }, 200), g ? v.stop().animate({
                    width: "100%"
                }, 200) : v.stop().animate({
                    width: 0
                }, 200), g = !g
            }), i(".menu-block, .close-nav").click(function() {
                i(this).toggleClass("active"), y.animate({
                    width: "100%"
                }, 200), g ? y.stop().animate({
                    width: "100%"
                }, 200) : y.stop().animate({
                    width: 0
                }, 200), g = !g
            }), i(t).resize(function() {
                i(this).width() > 767 && (v.removeAttr("style"), i(".menu-icon").removeClass("active"), g = !0), r()
            }), r(), b.click(function() {
                var t = "#" + i(this).data("popup");
                i(t).parent().css("display", "block")
            }), i(e).on("mousemove", ".paralax-holder", function(t) {
                var e = -1 * parseInt(t.pageX),
                    n = -1 * parseInt(t.pageY);
                i(this).find(".slide-decor-1").attr("style", "transform:translate3d(" + .1 * e + "px ," + .06 * n + "px, 0); -webkit-transform: translate3d(" + .1 * e + "px ," + .06 * n + "px, 0)"), i(this).find(".slide-decor-2").attr("style", "transform:translate3d(" + .01 * e + "px ," + .05 * n + "px, 0); -webkit-transform: translate3d(" + .01 * e + "px ," + .05 * n + "px, 0)")
            }), i(e).on("click", ".read-original.review-page", function() {
                i(this).parents(".comment-section").find(".fancybox-button").trigger("click")
            }), i(".portfolio-btn").hover(function() {
                lamp = !0, i(".btn-bx em").addClass("active"), setTimeout(function() {
                    lamp && i(".btn-bx em").removeClass("active")
                }, 100), setTimeout(function() {
                    lamp && i(".btn-bx em").addClass("active")
                }, 300), setTimeout(function() {
                    lamp && i(".btn-bx em").removeClass("active")
                }, 600), setTimeout(function() {
                    lamp && i(".btn-bx em").addClass("active")
                }, 800)
            }, o), setTimeout(function() {
                T.length && (A = T.offset().top)
            }, 2e3), i(t).scroll(function() {
                i(this).scrollTop() > 0 ? w.fadeIn() : w.fadeOut(), i(this).scrollTop() > A - S && (M.addClass("pulse"), setTimeout(function() {
                    M.removeClass("pulse")
                }, 4e3))
            }), w.click(function() {
                return i("body,html").animate({
                    scrollTop: 0
                }, 400), !1
            }), i(".play-holder").click(function() {
                i(this).toggleClass("active"), m ? i(this).siblings("video").get(0).play() : i(this).siblings("video").get(0).pause(), m = !m
            }), i("#header-phone").find("li").on("click", function() {
                i(this).each(function() {
                    i("#header-phone").find("li").removeClass("active"), i(this).addClass("active"), i(".header-holder .tel").removeClass("active"), i(".header-holder .tel.item" + i(this).index()).addClass("active")
                })
            }), E.find(".active-lang a").text(E.find(".active a").text()), E.hover(function() {
                E.find("ul").fadeIn()
            }, function() {
                E.find("ul").fadeOut()
            }), i(".information-holder .text-holder").click(function() {
                i(this).addClass("active")
            })
        }(window, document, jQuery)
    }
}, function(t, e, i) {
    (function(t) {
        "use strict";

        function n(t) {
            return t && t.__esModule ? t : {
                default: t
            }
        }
        Object.defineProperty(e, "__esModule", {
            value: !0
        });
        var r = i(1),
            o = n(r);
        i(11), e.default = function() {
            document.querySelectorAll('a[href^="#"]').forEach(function(t) {
                t.addEventListener("click", function(t) {
                    t.preventDefault(), document.querySelector(this.getAttribute("href")).scrollIntoView({
                        behavior: "smooth"
                    })
                })
            }), (0, o.default)(".trust-section-button").click(function() {
                (0, o.default)(this).toggleClass("active"), (0, o.default)(".trust-section-button__title").toggleClass("active"), (0, o.default)(".trust-section__box").toggleClass("active")
            }), (0, o.default)(".trust-section-button__title").click(function() {
                return !(0, o.default)(this).hasClass("active") && ((0, o.default)(".trust-section-button__title").removeClass("active"), (0, o.default)(this).toggleClass("active"), (0, o.default)(".trust-section-button").toggleClass("active"), (0, o.default)(".trust-section__box").toggleClass("active"), void 0)
            }), (0, o.default)(".new-cases-slider").slick({
                slidesToShow: 2,
                slidesToScroll: 1,
                arrows: !0,
                prevArrow: (0, o.default)(".new-cases-nav__item--prev"),
                nextArrow: (0, o.default)(".new-cases-nav__item--next"),
                dots: !1
            }), (0, o.default)(".call-new-video-popup").click(function() {
                (0, o.default)(".new-popup--video").addClass("active"), (0, o.default)(".new-popup__video").get(0).play(), t.stopScroling = !0
            }), (0, o.default)(".new-popup__close").click(function() {
                (0, o.default)(".new-popup").removeClass("active"), (0, o.default)(".new-popup__video").get(0).pause(), t.stopScroling = !1
            }), (0, o.default)(".new-vacancies__heading").click(function() {
                (0, o.default)(this).parent(".new-vacancies__row").toggleClass("active")
            })
        }
    }).call(e, function() {
        return this
    }())
}, function(t, e, i) {
    var n, r;
    ! function(i, o) {
        n = [], r = function() {
            return i.svg4everybody = o()
        }.apply(e, n), !(void 0 !== r && (t.exports = r))
    }(this, function() {
        function t(t, e, i) {
            if (i) {
                var n = document.createDocumentFragment(),
                    r = !e.hasAttribute("viewBox") && i.getAttribute("viewBox");
                r && e.setAttribute("viewBox", r);
                for (var o = i.cloneNode(!0); o.childNodes.length;) n.appendChild(o.firstChild);
                t.appendChild(n)
            }
        }

        function e(e) {
            e.onreadystatechange = function() {
                if (4 === e.readyState) {
                    var i = e._cachedDocument;
                    i || (i = e._cachedDocument = document.implementation.createHTMLDocument(""), i.body.innerHTML = e.responseText, e._cachedTarget = {}), e._embeds.splice(0).map(function(n) {
                        var r = e._cachedTarget[n.id];
                        r || (r = e._cachedTarget[n.id] = i.getElementById(n.id)), t(n.parent, n.svg, r)
                    })
                }
            }, e.onreadystatechange()
        }

        function i(i) {
            function r() {
                for (var i = 0; i < f.length;) {
                    var s = f[i],
                        l = s.parentNode,
                        c = n(l),
                        h = s.getAttribute("xlink:href") || s.getAttribute("href");
                    if (!h && a.attributeName && (h = s.getAttribute(a.attributeName)), c && h) {
                        if (o)
                            if (!a.validate || a.validate(h, c, s)) {
                                l.removeChild(s);
                                var u = h.split("#"),
                                    g = u.shift(),
                                    v = u.join("#");
                                if (g.length) {
                                    var y = d[g];
                                    y || (y = d[g] = new XMLHttpRequest, y.open("GET", g), y.send(), y._embeds = []), y._embeds.push({
                                        parent: l,
                                        svg: c,
                                        id: v
                                    }), e(y)
                                } else t(l, c, document.getElementById(v))
                            } else ++i, ++m
                    } else ++i
                }(!f.length || f.length - m > 0) && p(r, 67)
            }
            var o, a = Object(i),
                s = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/,
                l = /\bAppleWebKit\/(\d+)\b/,
                c = /\bEdge\/12\.(\d+)\b/,
                h = /\bEdge\/.(\d+)\b/,
                u = window.top !== window.self;
            o = "polyfill" in a ? a.polyfill : s.test(navigator.userAgent) || (navigator.userAgent.match(c) || [])[1] < 10547 || (navigator.userAgent.match(l) || [])[1] < 537 || h.test(navigator.userAgent) && u;
            var d = {},
                p = window.requestAnimationFrame || setTimeout,
                f = document.getElementsByTagName("use"),
                m = 0;
            o && r()
        }

        function n(t) {
            for (var e = t;
                "svg" !== e.nodeName.toLowerCase() && (e = e.parentNode););
            return e
        }
        return i
    })
}]);